<!DOCTYPE html>
<!-- Production Build - 2026-01-22T20:59:17.026Z -->
<!-- Quik Darts v1.1 - January 2026 -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <!-- Security Headers (X-Frame-Options and frame-ancestors require HTTP headers, not meta tags) -->
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  <meta name="referrer" content="strict-origin-when-cross-origin">
  <!-- CSP: Allow scripts from trusted CDNs only -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdnjs.cloudflare.com https://www.gstatic.com https://apis.google.com https://unpkg.com https://*.firebasedatabase.app; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; connect-src 'self' https://*.firebaseio.com https://*.firebasedatabase.app wss://*.firebaseio.com wss://*.firebasedatabase.app https://identitytoolkit.googleapis.com https://securetoken.googleapis.com https://unpkg.com https://www.gstatic.com https://*.cloudfunctions.net; frame-src https://*.firebaseapp.com https://*.firebasedatabase.app; img-src 'self' data: https: blob:;">

  <meta name="description" content="Quik Darts - Championship-style online darts. Play solo, challenge friends, or compete online. No download required.">
  <title>Quik Darts - Championship Edition</title>

  <!-- Favicons - Google requires 48x48 minimum -->
  <link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="48x48" href="/favicon-48x48.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta name="theme-color" content="#0D1117">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">

  <!-- External Scripts with Subresource Integrity (SRI) for supply chain protection -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js" integrity="sha512-8Q6Y9XnTbOE+JNvjBQwJ2H8S+UV4uA6hiRykhdtIyDYZ2TprdNmWOUaKdGzOhyr4dCyk287OejbPvwl7lrfqrQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js" integrity="sha512-MOCpqoRoisCTwJ8vQQiciZv0qcpROCidek3GTFS6KTk2+y7munJIlKCVkFCYY+p3ErYFXCjmFjnfTTRSC1OHWQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <!-- Firebase SDKs with SRI -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js" integrity="sha384-yuGdyIzzYtOBlBG6JOWn+Ey9kpq7HocusNuxEGyyohr1eEyXpeEyehIIXC/hznw4" crossorigin="anonymous"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js" integrity="sha384-lI+CxEx/bCvWP1b0OK13j5HTrTZP7yf1xle8TVOFq2smz6KC1RChTarRV/RHP5PP" crossorigin="anonymous"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js" integrity="sha384-M6AmjBRXEjkdGzRN1Y94xtkmblFbYBSLkqzyZ8rPvpRM2c48nhjIRFXVvUM/VATL" crossorigin="anonymous"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-functions-compat.js" crossorigin="anonymous"></script>
  <style>
    /* CSS Custom Properties - Design System */
    :root {
      --color-primary: #1B4332;
      --color-primary-light: #2D6A4F;
      --color-primary-dark: #143728;
      --color-accent: #D4A03A;
      --color-accent-light: #E8B94A;
      --color-accent-dark: #B8862E;
      --color-background: #0D1117;
      --color-background-light: #161B22;
      --color-background-card: #1C2128;
      --color-text: #F5F5F5;
      --color-text-muted: #8B949E;
      --color-text-dark: #0D1117;
      --color-success: #2D8A2D;
      --color-error: #C92A2A;
      --font-primary: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      --font-mono: 'Roboto Mono', monospace;
      --radius-sm: 6px;
      --radius-md: 10px;
      --radius-lg: 16px;
      --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);
      --shadow-md: 0 8px 24px rgba(0, 0, 0, 0.4);
      --shadow-lg: 0 16px 48px rgba(0, 0, 0, 0.5);
      --transition-fast: 0.15s ease;
      --transition-normal: 0.3s ease;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    html { scroll-behavior: smooth; }

    body {
      font-family: var(--font-primary);
      background: var(--color-background);
      color: var(--color-text);
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      touch-action: manipulation;
      line-height: 1.5;
    }

    /* Typography */
    h1, h2, h3, h4 { font-weight: 700; line-height: 1.2; }
    h1 { font-size: clamp(2rem, 5vw, 3.5rem); }
    h2 { font-size: clamp(1.5rem, 4vw, 2.5rem); }
    h3 { font-size: clamp(1.25rem, 3vw, 1.75rem); }

    /* Navigation */
    .nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      background: rgba(13, 17, 23, 0.95);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      transition: var(--transition-normal);
    }
    .nav-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 24px;
      height: 64px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .nav-logo {
      font-size: 1.25rem;
      font-weight: 800;
      color: var(--color-accent);
      text-decoration: none;
      letter-spacing: 1px;
    }
    .nav-links {
      display: flex;
      align-items: center;
      gap: 32px;
      list-style: none;
    }
    .nav-link {
      color: var(--color-text-muted);
      text-decoration: none;
      font-size: 0.9rem;
      font-weight: 500;
      transition: var(--transition-fast);
      cursor: pointer;
    }
    .nav-link:hover { color: var(--color-text); }
    .nav-cta {
      background: var(--color-accent);
      color: var(--color-text-dark);
      padding: 10px 20px;
      border-radius: var(--radius-sm);
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
      border: none;
      transition: var(--transition-fast);
    }
    .nav-cta:hover {
      background: var(--color-accent-light);
      transform: translateY(-1px);
    }
    .nav-hamburger {
      display: none;
      flex-direction: column;
      gap: 5px;
      cursor: pointer;
      padding: 8px;
      background: none;
      border: none;
    }
    .nav-hamburger span {
      width: 24px;
      height: 2px;
      background: var(--color-text);
      transition: var(--transition-fast);
    }
    .nav-mobile {
      display: none;
      position: fixed;
      top: 64px;
      left: 0;
      right: 0;
      background: var(--color-background);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding: 16px 24px;
    }
    .nav-mobile.open { display: block; }
    .nav-mobile-links {
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    @media (max-width: 768px) {
      .nav-links { display: none; }
      .nav-hamburger { display: flex; }
      .game-layout { flex-direction: column !important; }
      .game-dartboard { order: 1 !important; }
      .game-history { order: 2 !important; max-height: 180px !important; }
      .game-scoreboard { order: 3 !important; }
    }

    /* Buttons */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 14px 28px;
      font-family: var(--font-primary);
      font-size: 1rem;
      font-weight: 600;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all var(--transition-normal);
      text-decoration: none;
      min-height: 48px;
    }
    .btn-primary {
      background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-dark) 100%);
      color: var(--color-text-dark);
      box-shadow: 0 4px 16px rgba(212, 160, 58, 0.3);
    }
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(212, 160, 58, 0.4);
    }
    .btn-secondary {
      background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
      color: var(--color-text);
      box-shadow: 0 4px 16px rgba(27, 67, 50, 0.3);
    }
    .btn-secondary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(27, 67, 50, 0.4);
    }
    .btn-ghost {
      background: transparent;
      color: var(--color-text);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .btn-ghost:hover {
      background: rgba(255, 255, 255, 0.05);
      border-color: rgba(255, 255, 255, 0.3);
    }
    .btn:active { transform: translateY(0) scale(0.98); }

    /* Footer */
    .footer {
      background: var(--color-background);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      padding: 48px 24px 24px;
    }
    .footer-container {
      max-width: 1200px;
      margin: 0 auto;
    }
    .footer-content {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      flex-wrap: wrap;
      gap: 32px;
      margin-bottom: 32px;
    }
    .footer-brand h3 {
      color: var(--color-accent);
      margin-bottom: 8px;
    }
    .footer-brand p {
      color: var(--color-text-muted);
      font-size: 0.9rem;
    }
    .footer-links {
      display: flex;
      gap: 48px;
      flex-wrap: wrap;
    }
    .footer-links-group h4 {
      color: var(--color-text);
      font-size: 0.9rem;
      margin-bottom: 12px;
    }
    .footer-links-group ul {
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .footer-links-group a {
      color: var(--color-text-muted);
      text-decoration: none;
      font-size: 0.85rem;
      transition: var(--transition-fast);
      cursor: pointer;
    }
    .footer-links-group a:hover { color: var(--color-text); }
    .footer-bottom {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-top: 24px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      flex-wrap: wrap;
      gap: 16px;
    }
    .footer-bottom p {
      color: var(--color-text-muted);
      font-size: 0.8rem;
    }
    .footer-social {
      display: flex;
      gap: 16px;
    }
    .footer-social a {
      color: var(--color-text-muted);
      transition: var(--transition-fast);
    }
    .footer-social a:hover { color: var(--color-accent); }

    /* Animations */
    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    @keyframes almostTherePulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(212, 160, 58, 0); }
      50% { box-shadow: 0 0 20px 2px rgba(212, 160, 58, 0.3); }
    }
    @keyframes achievementUnlock {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }
    @keyframes iconBounce {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @keyframes confetti0 {
      0% { transform: translate(0, 0) scale(0); opacity: 1; }
      100% { transform: translate(-80px, -100px) scale(1); opacity: 0; }
    }
    @keyframes confetti1 {
      0% { transform: translate(0, 0) scale(0); opacity: 1; }
      100% { transform: translate(80px, -90px) scale(1); opacity: 0; }
    }
    @keyframes confetti2 {
      0% { transform: translate(0, 0) scale(0); opacity: 1; }
      100% { transform: translate(-70px, 80px) scale(1); opacity: 0; }
    }
    @keyframes confetti3 {
      0% { transform: translate(0, 0) scale(0); opacity: 1; }
      100% { transform: translate(90px, 70px) scale(1); opacity: 0; }
    }
    @keyframes rareShimmer {
      0%, 100% { box-shadow: 0 0 15px rgba(52, 152, 219, 0.3); }
      50% { box-shadow: 0 0 25px rgba(52, 152, 219, 0.5); }
    }
    @keyframes epicGlow {
      0%, 100% { box-shadow: 0 0 20px rgba(155, 89, 182, 0.4), inset 0 0 30px rgba(155, 89, 182, 0.1); }
      50% { box-shadow: 0 0 35px rgba(155, 89, 182, 0.6), inset 0 0 40px rgba(155, 89, 182, 0.15); }
    }
    @keyframes legendaryPulse {
      0%, 100% { box-shadow: 0 0 25px rgba(243, 156, 18, 0.5), 0 0 50px rgba(243, 156, 18, 0.2); }
      50% { box-shadow: 0 0 40px rgba(243, 156, 18, 0.7), 0 0 70px rgba(243, 156, 18, 0.3); }
    }
    @keyframes mythicGlow {
      0%, 100% {
        box-shadow: 0 0 30px rgba(231, 76, 60, 0.6), 0 0 60px rgba(231, 76, 60, 0.3), inset 0 0 40px rgba(231, 76, 60, 0.1);
        border-color: rgba(231, 76, 60, 0.8);
      }
      50% {
        box-shadow: 0 0 50px rgba(231, 76, 60, 0.8), 0 0 80px rgba(231, 76, 60, 0.4), inset 0 0 50px rgba(231, 76, 60, 0.15);
        border-color: rgba(231, 76, 60, 1);
      }
    }
    /* Wagered Match Header Animations */
    @keyframes potPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.06); }
      100% { transform: scale(1); }
    }
    @keyframes potGlow {
      0% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
      50% { box-shadow: 0 0 30px rgba(255, 215, 0, 1); }
      100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.7); }
    }
    @keyframes wagerFadeInUp {
      0% { opacity: 0; transform: translateY(10px); }
      100% { opacity: 1; transform: translateY(0); }
    }
    @keyframes skeletonPulse {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 0.8; }
    }
    .animate-fade-in { animation: fadeInUp 0.6s ease forwards; }
    .animate-delay-2 { animation-delay: 0.2s; opacity: 0; }

    /* Utility */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      border: 0;
    }

    /* ===== MATCHMAKING OVERLAY ===== */

    /* Backdrop */
    .qd-mmBackdrop {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: radial-gradient(60% 60% at 50% 45%, rgba(0,0,0,0.25), rgba(0,0,0,0.55));
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      z-index: 9999;
      pointer-events: auto; /* Prevent clicks passing through to background */
    }

    /* Matchmaking Card */
    .qd-mmCard {
      width: min(420px, calc(100vw - 32px));
      padding: 28px 26px 22px;
      border-radius: 18px;
      background: rgba(22, 26, 30, 0.92);
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow: 0 28px 70px rgba(0,0,0,0.55);
      text-align: center;
    }

    .qd-mmIcon {
      font-size: 30px;
      opacity: 0.95;
      margin-bottom: 10px;
    }

    .qd-mmTitle {
      font-weight: 900;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(226, 186, 92, 0.95);
      font-size: 20px;
    }

    .qd-mmTitle.green {
      color: rgba(80, 200, 120, 0.95);
    }

    .qd-mmSub {
      margin-top: 10px;
      font-size: 13px;
      color: rgba(255,255,255,0.55);
    }

    .qd-mmHint {
      margin-top: 12px;
      font-size: 12px;
      color: rgba(255,255,255,0.6);
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.06);
    }

    .qd-mmDots {
      margin: 14px auto 18px;
      display: flex;
      gap: 8px;
      justify-content: center;
    }

    .qd-mmDots span {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: rgba(80, 200, 120, 0.5);
      animation: qdDot 1.1s infinite ease-in-out;
    }

    .qd-mmDots span:nth-child(2) { animation-delay: 0.15s; opacity: 0.7; }
    .qd-mmDots span:nth-child(3) { animation-delay: 0.3s; opacity: 0.9; }

    @keyframes qdDot {
      0%, 80%, 100% { transform: translateY(0); opacity: 0.35; }
      40% { transform: translateY(-6px); opacity: 0.95; }
    }

    .qd-mmBtn {
      pointer-events: auto;
      padding: 10px 16px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.8);
      font-weight: 700;
      cursor: pointer;
      transition: background 0.2s;
    }

    .qd-mmBtn:hover {
      background: rgba(255,255,255,0.09);
    }

    /* Opponent block */
    .qd-mmOpponent {
      margin: 18px auto 6px;
      padding: 14px 14px;
      border-radius: 16px;
      width: min(320px, 100%);
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.06);
      display: grid;
      justify-items: center;
      gap: 10px;
    }

    .qd-mmAvatar {
      width: 44px;
      height: 44px;
      border-radius: 14px;
      overflow: hidden;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.08);
    }

    .qd-mmAvatar img { width: 100%; height: 100%; object-fit: cover; }

    .qd-mmAvatarFallback {
      width: 100%;
      height: 100%;
      display: grid;
      place-items: center;
      font-weight: 900;
      color: rgba(255,255,255,0.8);
    }

    .qd-mmName {
      font-weight: 800;
      color: rgba(226, 186, 92, 0.95);
    }

    /* VS Intro Screen */
    .qd-vsWrap {
      width: min(920px, calc(100vw - 32px));
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      gap: 32px;
      padding: 28px 30px;
      border-radius: 22px;
      background: rgba(14, 18, 22, 0.78);
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow: 0 28px 90px rgba(0,0,0,0.62);
      animation: qdIntroIn 420ms ease-out;
    }

    @keyframes qdIntroIn {
      from { opacity: 0; transform: translateY(8px) scale(0.99); }
      to   { opacity: 1; transform: translateY(0) scale(1); }
    }

    .qd-vsPlayer {
      display: grid;
      justify-items: center;
      gap: 8px;
      opacity: 0.96;
    }

    .qd-vsPlayer.left { animation: qdSlideLeft 520ms ease-out; }
    .qd-vsPlayer.right { animation: qdSlideRight 520ms ease-out; }

    @keyframes qdSlideLeft { from { transform: translateX(-10px); opacity: 0; } to { transform: translateX(0); opacity: 0.96; } }
    @keyframes qdSlideRight { from { transform: translateX(10px); opacity: 0; } to { transform: translateX(0); opacity: 0.96; } }

    .qd-vsAvatar {
      width: 74px;
      height: 74px;
      border-radius: 22px;
      overflow: hidden;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 18px 40px rgba(0,0,0,0.45);
    }

    .qd-vsAvatar img { width: 100%; height: 100%; object-fit: cover; }

    .qd-vsAvatarFallback {
      width: 100%;
      height: 100%;
      display: grid;
      place-items: center;
      font-weight: 900;
      font-size: 28px;
      color: rgba(255,255,255,0.82);
    }

    .qd-vsName {
      font-weight: 900;
      color: rgba(255,255,255,0.92);
    }

    .qd-vsLvl {
      font-size: 12px;
      letter-spacing: 0.06em;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.08);
      color: rgba(255,255,255,0.75);
    }

    .qd-vsCenter {
      display: grid;
      justify-items: center;
      gap: 14px;
      padding: 10px 0;
    }

    .qd-vsText {
      font-size: 40px;
      font-weight: 900;
      letter-spacing: 0.08em;
      color: rgba(226, 186, 92, 0.95);
      text-shadow: 0 10px 22px rgba(0,0,0,0.55);
    }

    .qd-vsPot {
      display: grid;
      justify-items: center;
      gap: 6px;
    }

    .qd-vsChip {
      animation: qdChipPop 520ms cubic-bezier(.2,.9,.2,1.15);
      mix-blend-mode: lighten;
      filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.5));
    }

    @keyframes qdChipPop {
      0% { transform: scale(0.92); opacity: 0; }
      60% { transform: scale(1.04); opacity: 1; }
      100% { transform: scale(1); }
    }

    .qd-vsPotLabel {
      font-size: 11px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.55);
    }

    .qd-vsPotAmount {
      font-size: 22px;
      font-weight: 900;
      color: rgba(255,255,255,0.92);
    }

    /* Accessibility - Reduced Motion */
    @media (prefers-reduced-motion: reduce) {
      .qd-mmDots span,
      .qd-vsPlayer,
      .qd-vsChip,
      .qd-vsWrap {
        animation: none;
      }
    }

    /* Mobile Responsive */
    @media (max-width: 640px) {
      .qd-vsWrap {
        grid-template-columns: 1fr;
        gap: 20px;
        padding: 20px;
      }

      .qd-vsPlayer.left,
      .qd-vsPlayer.right {
        animation: none;
      }

      .qd-vsCenter {
        order: -1;
      }

      .qd-vsText {
        font-size: 32px;
      }

      .qd-vsAvatar {
        width: 60px;
        height: 60px;
      }

      .qd-vsAvatarFallback {
        font-size: 22px;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script>
/**
 * Quik Darts - Championship Edition
 * Copyright (c) 2026 Quik Darts. All Rights Reserved.
 *
 * NOTICE: This is proprietary software. Unauthorized copying, modification,
 * distribution, or use of this software, via any medium, is strictly prohibited.
 *
 * This code is protected by copyright law and international treaties.
 * Violators will be prosecuted to the fullest extent of the law.
 */
const {
  useState,
  useRef,
  useEffect,
  useCallback,
  useMemo
} = React;
const firebaseConfig = {
  apiKey: "AIzaSyAapEmqdhRMQgRyrXIzhhMGSvNbpfQlaoM",
  authDomain: "quikdarts.firebaseapp.com",
  databaseURL: "https://quikdarts-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "quikdarts",
  storageBucket: "quikdarts.firebasestorage.app",
  messagingSenderId: "287454496132",
  appId: "1:287454496132:web:dd17354a71f9eb907f89d1",
  measurementId: "G-TE4B2W2CEJ"
};
let database = null;
let auth = null;
let functions = null;
let currentAuthUser = null;
let authReadyResolve;
const authReadyPromise = new Promise(resolve => {
  authReadyResolve = resolve;
});
try {
  if (!firebase.apps.length) {
    firebase.initializeApp(firebaseConfig);
  }
  database = firebase.database();
  auth = firebase.auth();
  functions = firebase.app().functions('europe-west1');
  auth.onAuthStateChanged(user => {
    if (user) {
      currentAuthUser = user;
      authReadyResolve(user);
    } else {
      auth.signInAnonymously().catch(error => {
        console.warn('Anonymous auth failed:', error);
        authReadyResolve(null);
      });
    }
  });
} catch (error) {
  console.warn('Firebase not configured. Online multiplayer disabled.', error);
  authReadyResolve(null);
}
const DartIcon = ({
  size = 20,
  color = 'currentColor'
}) => React.createElement("svg", {
  width: size,
  height: size,
  viewBox: "0 0 24 24",
  fill: "none",
  "aria-hidden": "true",
  style: {
    marginRight: '12px',
    flexShrink: 0
  }
}, React.createElement("path", {
  d: "M22 2L13 11M22 2L18 22L13 11M22 2L2 7L13 11",
  stroke: color,
  strokeWidth: "2",
  strokeLinecap: "round",
  strokeLinejoin: "round"
}));
const GlobeIcon = ({
  size = 20,
  color = 'currentColor'
}) => React.createElement("svg", {
  width: size,
  height: size,
  viewBox: "0 0 24 24",
  fill: "none",
  "aria-hidden": "true",
  style: {
    marginRight: '12px',
    flexShrink: 0
  }
}, React.createElement("circle", {
  cx: "12",
  cy: "12",
  r: "10",
  stroke: color,
  strokeWidth: "2"
}), React.createElement("path", {
  d: "M2 12H22M12 2C14.5 4.5 16 8 16 12C16 16 14.5 19.5 12 22C9.5 19.5 8 16 8 12C8 8 9.5 4.5 12 2Z",
  stroke: color,
  strokeWidth: "2"
}));
const TargetIcon = ({
  size = 20,
  color = 'currentColor'
}) => React.createElement("svg", {
  width: size,
  height: size,
  viewBox: "0 0 24 24",
  fill: "none",
  "aria-hidden": "true",
  style: {
    marginRight: '12px',
    flexShrink: 0
  }
}, React.createElement("circle", {
  cx: "12",
  cy: "12",
  r: "10",
  stroke: color,
  strokeWidth: "2"
}), React.createElement("circle", {
  cx: "12",
  cy: "12",
  r: "6",
  stroke: color,
  strokeWidth: "2"
}), React.createElement("circle", {
  cx: "12",
  cy: "12",
  r: "2",
  fill: color
}));
const TrophyIcon = ({
  size = 20,
  color = 'currentColor'
}) => React.createElement("svg", {
  width: size,
  height: size,
  viewBox: "0 0 24 24",
  fill: "none",
  "aria-hidden": "true",
  style: {
    marginRight: '12px',
    flexShrink: 0
  }
}, React.createElement("path", {
  d: "M8 21H16M12 17V21M6 4H18V8C18 11.3137 15.3137 14 12 14C8.68629 14 6 11.3137 6 8V4Z",
  stroke: color,
  strokeWidth: "2",
  strokeLinecap: "round",
  strokeLinejoin: "round"
}), React.createElement("path", {
  d: "M6 4H4V6C4 7.10457 4.89543 8 6 8V4ZM18 4V8C19.1046 8 20 7.10457 20 6V4H18Z",
  stroke: color,
  strokeWidth: "2",
  strokeLinecap: "round",
  strokeLinejoin: "round"
}));
const MenuIcon = ({
  size = 24
}) => React.createElement("svg", {
  width: size,
  height: size,
  viewBox: "0 0 24 24",
  fill: "none",
  "aria-hidden": "true"
}, React.createElement("path", {
  d: "M3 12H21M3 6H21M3 18H21",
  stroke: "currentColor",
  strokeWidth: "2",
  strokeLinecap: "round"
}));
const CloseIcon = ({
  size = 24
}) => React.createElement("svg", {
  width: size,
  height: size,
  viewBox: "0 0 24 24",
  fill: "none",
  "aria-hidden": "true"
}, React.createElement("path", {
  d: "M18 6L6 18M6 6L18 18",
  stroke: "currentColor",
  strokeWidth: "2",
  strokeLinecap: "round"
}));
const PlayIcon = ({
  size = 20
}) => React.createElement("svg", {
  width: size,
  height: size,
  viewBox: "0 0 24 24",
  fill: "currentColor",
  "aria-hidden": "true"
}, React.createElement("path", {
  d: "M8 5v14l11-7z"
}));
const UsersIcon = ({
  size = 20
}) => React.createElement("svg", {
  width: size,
  height: size,
  viewBox: "0 0 24 24",
  fill: "none",
  "aria-hidden": "true",
  style: {
    marginRight: '8px',
    flexShrink: 0
  }
}, React.createElement("path", {
  d: "M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2M9 11a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM23 21v-2a4 4 0 0 0-3-3.87M16 3.13a4 4 0 0 1 0 7.75",
  stroke: "currentColor",
  strokeWidth: "2",
  strokeLinecap: "round",
  strokeLinejoin: "round"
}));
const CoinIcon = ({
  size = 16
}) => React.createElement("img", {
  src: "assets/coin-chip.png",
  alt: "",
  "aria-hidden": "true",
  width: size,
  height: size,
  style: {
    objectFit: 'contain'
  },
  decoding: "async"
});
const StakeChipIcon = ({
  size = 86,
  className = ''
}) => React.createElement("img", {
  className: className,
  src: "assets/chip-stack.png",
  alt: "",
  "aria-hidden": "true",
  width: size,
  height: size,
  draggable: false,
  style: {
    display: 'block',
    userSelect: 'none',
    objectFit: 'contain',
    filter: 'drop-shadow(0 4px 12px rgba(0,0,0,0.5))',
    mixBlendMode: 'lighten'
  }
});
const MatchmakingOverlay = ({
  visible,
  stage,
  isWagered,
  stakeAmount,
  you,
  opponent,
  onCancel
}) => {
  const backdropRef = useRef(null);
  const cancelBtnRef = useRef(null);
  const previousFocusRef = useRef(null);
  const [youAvatarError, setYouAvatarError] = useState(false);
  const [opponentAvatarError, setOpponentAvatarError] = useState(false);
  useEffect(() => {
    if (visible) {
      previousFocusRef.current = document.activeElement;
      if (stage === 'searching' && cancelBtnRef.current) {
        cancelBtnRef.current.focus();
      }
    } else {
      if (previousFocusRef.current && typeof previousFocusRef.current.focus === 'function') {
        previousFocusRef.current.focus();
      }
    }
  }, [visible, stage]);
  useEffect(() => {
    setOpponentAvatarError(false);
    setYouAvatarError(false);
  }, [opponent?.avatarUrl, you?.avatarUrl]);
  const handleKeyDown = e => {
    if (e.key === 'Escape' && stage === 'searching') {
      onCancel();
    }
  };
  const handleBackdropClick = e => {
    if (e.target === e.currentTarget && stage === 'searching') {
      onCancel();
    }
  };
  if (!visible) return null;
  return React.createElement("div", {
    ref: backdropRef,
    className: "qd-mmBackdrop",
    role: "dialog",
    "aria-modal": "true",
    "aria-labelledby": "mm-title",
    onKeyDown: handleKeyDown,
    onClick: handleBackdropClick
  }, stage === 'searching' && React.createElement("div", {
    className: "qd-mmCard"
  }, React.createElement("div", {
    className: "qd-mmIcon"
  }, "\uD83C\uDF0D"), React.createElement("div", {
    id: "mm-title",
    className: "qd-mmTitle"
  }, "FINDING OPPONENT\u2026"), React.createElement("div", {
    className: "qd-mmSub"
  }, "Searching for players worldwide"), isWagered && stakeAmount > 0 && React.createElement("div", {
    className: "qd-mmHint"
  }, "WAGERED MATCH \u2022 Stake locked: ", React.createElement("strong", null, stakeAmount?.toLocaleString())), React.createElement("div", {
    className: "qd-mmDots",
    "aria-hidden": "true"
  }, React.createElement("span", null), React.createElement("span", null), React.createElement("span", null)), React.createElement("button", {
    ref: cancelBtnRef,
    className: "qd-mmBtn",
    onClick: onCancel
  }, "CANCEL")), stage === 'found' && opponent && React.createElement("div", {
    className: "qd-mmCard"
  }, React.createElement("div", {
    className: "qd-mmIcon"
  }, "\u2713"), React.createElement("div", {
    id: "mm-title",
    className: "qd-mmTitle green"
  }, "OPPONENT FOUND!"), React.createElement("div", {
    className: "qd-mmOpponent"
  }, React.createElement("div", {
    className: "qd-mmAvatar"
  }, opponent.avatarUrl && !opponentAvatarError ? React.createElement("img", {
    src: opponent.avatarUrl,
    alt: `${opponent.name}'s avatar`,
    onError: () => setOpponentAvatarError(true)
  }) : React.createElement("div", {
    className: "qd-mmAvatarFallback"
  }, opponent.name?.slice(0, 1)?.toUpperCase() || '?')), React.createElement("div", {
    className: "qd-mmName"
  }, opponent.name)), React.createElement("div", {
    className: "qd-mmSub"
  }, "Starting game\u2026")), stage === 'intro' && opponent && isWagered && React.createElement("div", {
    className: "qd-vsWrap"
  }, React.createElement("div", {
    className: "qd-vsPlayer left"
  }, React.createElement("div", {
    className: "qd-vsAvatar"
  }, you.avatarUrl && !youAvatarError ? React.createElement("img", {
    src: you.avatarUrl,
    alt: `${you.name}'s avatar`,
    onError: () => setYouAvatarError(true)
  }) : React.createElement("div", {
    className: "qd-vsAvatarFallback"
  }, you.name?.slice(0, 1)?.toUpperCase() || '?')), React.createElement("div", {
    className: "qd-vsName"
  }, you.name), React.createElement("div", {
    className: "qd-vsLvl"
  }, "Lv.", you.level)), React.createElement("div", {
    className: "qd-vsCenter"
  }, React.createElement("div", {
    className: "qd-vsText"
  }, "VS"), React.createElement("div", {
    className: "qd-vsPot"
  }, React.createElement(StakeChipIcon, {
    size: 86,
    className: "qd-vsChip"
  }), React.createElement("div", {
    className: "qd-vsPotLabel"
  }, "MATCH STAKE"), React.createElement("div", {
    className: "qd-vsPotAmount"
  }, stakeAmount?.toLocaleString()))), React.createElement("div", {
    className: "qd-vsPlayer right"
  }, React.createElement("div", {
    className: "qd-vsAvatar"
  }, opponent.avatarUrl && !opponentAvatarError ? React.createElement("img", {
    src: opponent.avatarUrl,
    alt: `${opponent.name}'s avatar`,
    onError: () => setOpponentAvatarError(true)
  }) : React.createElement("div", {
    className: "qd-vsAvatarFallback"
  }, opponent.name?.slice(0, 1)?.toUpperCase() || '?')), React.createElement("div", {
    className: "qd-vsName"
  }, opponent.name), React.createElement("div", {
    className: "qd-vsLvl"
  }, "Lv.", opponent.level))));
};
const formatCoins = amount => {
  return amount.toLocaleString();
};
const formatCompactNumber = num => {
  if (num >= 1000000) {
    return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
  }
  return num.toLocaleString('en-US');
};
const COLORS = {
  primary: '#1B4332',
  primaryLight: '#2D6A4F',
  primaryDark: '#143728',
  accent: '#D4A03A',
  accentLight: '#E8B94A',
  accentDark: '#B8862E',
  background: '#0D1117',
  backgroundLight: '#161B22',
  backgroundCard: '#1C2128',
  text: '#F5F5F5',
  textMuted: '#8B949E',
  textDark: '#0D1117',
  success: '#2D8A2D',
  error: '#C92A2A'
};
const BOKEH_LIGHTS = [{
  size: 45,
  left: 10,
  top: 5
}, {
  size: 65,
  left: 22,
  top: 15
}, {
  size: 38,
  left: 34,
  top: 25
}, {
  size: 72,
  left: 46,
  top: 35
}, {
  size: 50,
  left: 58,
  top: 45
}, {
  size: 58,
  left: 70,
  top: 55
}, {
  size: 42,
  left: 82,
  top: 65
}, {
  size: 68,
  left: 94,
  top: 75
}];
const BOARD_SIZE = 500;
const CENTER = BOARD_SIZE / 2;
const SEGMENTS = [20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5];
const SEGMENT_COLORS = ['#0a0a0a', '#f5f0e8'];
const TRIPLE_INNER = 119;
const TRIPLE_OUTER = 134;
const DOUBLE_INNER = 200;
const DOUBLE_OUTER = 215;
const OUTER_BULL = 20;
const INNER_BULL = 10;
const MATCHMAKING_TIMINGS = Object.freeze({
  FOUND_TO_INTRO_DELAY_MS: 700,
  INTRO_DURATION_MS: 2500
});
const THEME_IDS = Object.freeze({
  CLASSIC: 'classic',
  PRO_WIRE: 'proWire',
  NEON_GLOW: 'neonGlow',
  GOLD_ELITE: 'goldElite',
  STEALTH: 'stealth'
});
const NEON_COLOR_OPTIONS = Object.freeze({
  CYAN: 'cyan',
  PINK: 'pink',
  GREEN: 'green'
});
const THEME_CLASSIC = Object.freeze({
  id: THEME_IDS.CLASSIC,
  name: 'Classic',
  description: 'Traditional dartboard matching iOS appearance',
  icon: 'ðŸŽ¯',
  colors: {
    segmentPrimary: '#0a0a0a',
    segmentSecondary: '#f5f0e8',
    doubleTripleEven: '#b8232a',
    doubleTripleOdd: '#0d6b2e',
    outerBull: '#0d6b2e',
    innerBull: '#b8232a',
    wireColor: '#888888',
    wireHighlight: 'rgba(255,255,255,0.6)',
    chromeRing: '#c0c0c0',
    numberRing: '#1a1a2e',
    numberText: '#f5f0e8',
    frameColor: '#b8860b',
    boardBackground: '#1a1a1a'
  },
  effects: {
    useSisalTexture: false,
    useWoodGrain: false,
    useChromeGradient: false,
    useBoardLighting: false,
    glowEffect: false,
    pulseAnimation: false,
    wireWidth: 1.0,
    shadowIntensity: 0
  }
});
const THEME_PRO_WIRE = Object.freeze({
  id: THEME_IDS.PRO_WIRE,
  name: 'Pro Wire',
  description: 'Tournament style with thin metal wire dividers',
  icon: 'ðŸ†',
  colors: {
    segmentPrimary: '#0a0a0a',
    segmentSecondary: '#e8e4dc',
    doubleTripleEven: '#c41e3a',
    doubleTripleOdd: '#1a8b45',
    outerBull: '#1a8b45',
    innerBull: '#c41e3a',
    wireColor: '#d4d4d4',
    wireHighlight: 'rgba(255,255,255,0.9)',
    chromeRing: '#e0e0e0',
    numberRing: '#1a1a2e',
    numberText: '#ffffff',
    frameColor: '#a0a0a0',
    boardBackground: '#1a1a1a'
  },
  effects: {
    useSisalTexture: true,
    useWoodGrain: false,
    useChromeGradient: true,
    useBoardLighting: true,
    glowEffect: false,
    pulseAnimation: false,
    wireWidth: 0.8,
    shadowIntensity: 0.2
  }
});
const THEME_NEON_GLOW = Object.freeze({
  id: THEME_IDS.NEON_GLOW,
  name: 'Neon Glow',
  description: 'Dark board with glowing neon wires',
  icon: 'âœ¨',
  neonColorOptions: [NEON_COLOR_OPTIONS.CYAN, NEON_COLOR_OPTIONS.PINK, NEON_COLOR_OPTIONS.GREEN],
  defaultNeonColor: NEON_COLOR_OPTIONS.CYAN,
  getColors: neonColor => {
    const neonColors = {
      [NEON_COLOR_OPTIONS.CYAN]: {
        primary: '#00ffff',
        secondary: '#00d4ff',
        glow: 'rgba(0, 255, 255, 0.6)'
      },
      [NEON_COLOR_OPTIONS.PINK]: {
        primary: '#ff00ff',
        secondary: '#ff44aa',
        glow: 'rgba(255, 0, 255, 0.6)'
      },
      [NEON_COLOR_OPTIONS.GREEN]: {
        primary: '#00ff66',
        secondary: '#44ff88',
        glow: 'rgba(0, 255, 102, 0.6)'
      }
    };
    const neon = neonColors[neonColor] || neonColors[NEON_COLOR_OPTIONS.CYAN];
    return {
      segmentPrimary: '#0a0a12',
      segmentSecondary: '#1a1a28',
      doubleTripleEven: '#2a0a1a',
      doubleTripleOdd: '#0a1a1a',
      outerBull: '#0a1a1a',
      innerBull: '#2a0a1a',
      wireColor: neon.primary,
      wireHighlight: neon.glow,
      chromeRing: '#1a1a28',
      numberRing: '#0a0a12',
      numberText: neon.primary,
      frameColor: neon.secondary,
      boardBackground: '#050508',
      neonGlow: neon.glow,
      neonPrimary: neon.primary
    };
  },
  effects: {
    useSisalTexture: false,
    useWoodGrain: false,
    useChromeGradient: false,
    useBoardLighting: false,
    glowEffect: true,
    pulseAnimation: true,
    wireWidth: 2.0,
    shadowIntensity: 0.1
  }
});
const THEME_GOLD_ELITE = Object.freeze({
  id: THEME_IDS.GOLD_ELITE,
  name: 'Gold Elite',
  description: 'Black and gold luxury premium theme',
  icon: 'ðŸ‘‘',
  colors: {
    segmentPrimary: '#0a0a0a',
    segmentSecondary: '#1a1a1a',
    doubleTripleEven: '#b8860b',
    doubleTripleOdd: '#daa520',
    outerBull: '#daa520',
    innerBull: '#ffd700',
    wireColor: '#ffd700',
    wireHighlight: 'rgba(255,215,0,0.8)',
    chromeRing: '#ffd700',
    numberRing: '#0a0a0a',
    numberText: '#ffd700',
    frameColor: '#ffd700',
    boardBackground: '#050505',
    metallicSheen: 'rgba(255,215,0,0.15)'
  },
  effects: {
    useSisalTexture: false,
    useWoodGrain: false,
    useChromeGradient: false,
    useBoardLighting: true,
    glowEffect: false,
    pulseAnimation: false,
    wireWidth: 1.2,
    shadowIntensity: 0.4,
    useMetallicSheen: true
  }
});
const THEME_STEALTH = Object.freeze({
  id: THEME_IDS.STEALTH,
  name: 'Stealth',
  description: 'Minimal dark theme - hard mode aesthetic',
  icon: 'ðŸŒ‘',
  colors: {
    segmentPrimary: '#0a0a0a',
    segmentSecondary: '#151515',
    doubleTripleEven: '#1a1a1a',
    doubleTripleOdd: '#222222',
    outerBull: '#1a1a1a',
    innerBull: '#252525',
    wireColor: '#333333',
    wireHighlight: 'rgba(255,255,255,0.1)',
    chromeRing: '#1a1a1a',
    numberRing: '#0a0a0a',
    numberText: '#444444',
    frameColor: '#151515',
    boardBackground: '#050505'
  },
  effects: {
    useSisalTexture: false,
    useWoodGrain: false,
    useChromeGradient: false,
    useBoardLighting: false,
    glowEffect: false,
    pulseAnimation: false,
    wireWidth: 0.5,
    shadowIntensity: 0.1
  }
});
const DARTBOARD_THEMES = Object.freeze({
  [THEME_IDS.CLASSIC]: THEME_CLASSIC,
  [THEME_IDS.PRO_WIRE]: THEME_PRO_WIRE,
  [THEME_IDS.NEON_GLOW]: THEME_NEON_GLOW,
  [THEME_IDS.GOLD_ELITE]: THEME_GOLD_ELITE,
  [THEME_IDS.STEALTH]: THEME_STEALTH
});
const THEME_IDS_LIST = Object.freeze([THEME_IDS.CLASSIC, THEME_IDS.PRO_WIRE, THEME_IDS.NEON_GLOW, THEME_IDS.GOLD_ELITE, THEME_IDS.STEALTH]);
const DEFAULT_THEME_ID = THEME_IDS.CLASSIC;
const isValidThemeId = themeId => {
  return themeId && Object.values(THEME_IDS).includes(themeId);
};
const getThemeById = themeId => {
  if (!isValidThemeId(themeId)) {
    console.warn(`Invalid theme ID: ${themeId}, falling back to default`);
    return DARTBOARD_THEMES[DEFAULT_THEME_ID];
  }
  return DARTBOARD_THEMES[themeId];
};
const getThemeColors = (theme, neonColor = null) => {
  if (theme.id === THEME_IDS.NEON_GLOW && theme.getColors) {
    return theme.getColors(neonColor || theme.defaultNeonColor);
  }
  return theme.colors;
};
const ACHIEVEMENTS_DATA = [{
  id: 'first_game',
  name: 'First Steps',
  description: 'Every champion starts somewhere. Complete your first game.',
  icon: 'ðŸŽ¯',
  rarity: 'common',
  mode: 'offline'
}, {
  id: 'first_win',
  name: 'First Victory',
  description: 'The taste of victory never gets old. Win your first game.',
  icon: 'ðŸ†',
  rarity: 'common',
  mode: 'offline'
}, {
  id: 'first_180',
  name: 'Maximum! I',
  description: 'The crowd goes wild! Hit your first perfect 180.',
  icon: 'ðŸ’¯',
  rarity: 'uncommon',
  mode: 'offline',
  chain: 'maximum',
  tier: 1
}, {
  id: 'ten_180s',
  name: 'Maximum! II',
  description: 'Consistency is key. Land 10 maximum scores.',
  icon: 'ðŸ’¯',
  rarity: 'rare',
  mode: 'offline',
  statKey: 'total180s',
  target: 10,
  chain: 'maximum',
  tier: 2
}, {
  id: 'fifty_180s',
  name: 'Maximum! III',
  description: 'Only the elite reach this level. Hit 50 perfect 180s.',
  icon: 'ðŸ’¯',
  rarity: 'epic',
  mode: 'offline',
  statKey: 'total180s',
  target: 50,
  chain: 'maximum',
  tier: 3
}, {
  id: 'hundred_180s',
  name: 'Maximum! IV',
  description: 'Legendary precision. 100 perfect 180s.',
  icon: 'ðŸ’¯',
  rarity: 'legendary',
  mode: 'offline',
  statKey: 'total180s',
  target: 100,
  chain: 'maximum',
  tier: 4
}, {
  id: 'nine_darter_offline',
  name: 'Perfect Game',
  description: 'The holy grail of darts. Achieve a legendary nine-dart finish.',
  icon: 'ðŸ‘‘',
  rarity: 'legendary',
  mode: 'offline'
}, {
  id: 'nine_darter_online',
  name: 'Online Legend',
  description: 'Perfection under pressure. Nine-dart finish against a real opponent.',
  icon: 'ðŸ’Ž',
  rarity: 'mythic',
  mode: 'online'
}, {
  id: 'perfect9_first',
  name: 'Perfect 9',
  description: 'Complete a leg with 9 perfect darts.',
  icon: '9ï¸âƒ£',
  rarity: 'mythic',
  mode: 'offline',
  chain: 'perfect9',
  tier: 1,
  statKey: 'totalNineDarters',
  target: 1
}, {
  id: 'perfect9_ten',
  name: 'Perfect 9 Master',
  description: 'Complete 10 nine-darters.',
  icon: '9ï¸âƒ£',
  rarity: 'mythic',
  mode: 'offline',
  chain: 'perfect9',
  tier: 2,
  statKey: 'totalNineDarters',
  target: 10
}, {
  id: 'perfect9_hundred',
  name: 'Perfect 9 Legend',
  description: 'Complete 100 nine-darters.',
  icon: '9ï¸âƒ£',
  rarity: 'mythic',
  mode: 'offline',
  chain: 'perfect9',
  tier: 3,
  statKey: 'totalNineDarters',
  target: 100
}, {
  id: 'first_bull',
  name: 'Bullseye! I',
  description: 'Right in the center! Hit your first bullseye.',
  icon: 'ðŸŽ¯',
  rarity: 'common',
  mode: 'offline',
  chain: 'bullseye',
  tier: 1
}, {
  id: 'fifty_bulls',
  name: 'Bullseye! II',
  description: 'Precision personified. Find the bullseye 50 times.',
  icon: 'ðŸŽ¯',
  rarity: 'rare',
  mode: 'offline',
  statKey: 'totalBulls',
  target: 50,
  chain: 'bullseye',
  tier: 2
}, {
  id: 'hundred_bulls',
  name: 'Bullseye! III',
  description: 'The center is your home. 100 bullseyes and counting.',
  icon: 'ðŸŽ¯',
  rarity: 'epic',
  mode: 'offline',
  statKey: 'totalBulls',
  target: 100,
  chain: 'bullseye',
  tier: 3
}, {
  id: 'twofifty_bulls',
  name: 'Bullseye! IV',
  description: 'Master of the center. 250 bullseyes.',
  icon: 'ðŸŽ¯',
  rarity: 'legendary',
  mode: 'offline',
  statKey: 'totalBulls',
  target: 250,
  chain: 'bullseye',
  tier: 4
}, {
  id: 'five_wins',
  name: 'Victory I',
  description: 'You\'re heating up! Claim 5 victories.',
  icon: 'ðŸ†',
  rarity: 'uncommon',
  mode: 'offline',
  statKey: 'totalGamesWon',
  target: 5,
  chain: 'victory',
  tier: 1
}, {
  id: 'twenty_wins',
  name: 'Victory II',
  description: 'They fear your name. Dominate with 20 wins.',
  icon: 'ðŸ†',
  rarity: 'rare',
  mode: 'offline',
  statKey: 'totalGamesWon',
  target: 20,
  chain: 'victory',
  tier: 2
}, {
  id: 'fifty_wins',
  name: 'Victory III',
  description: 'A true champion emerges. Conquer 50 games.',
  icon: 'ðŸ†',
  rarity: 'epic',
  mode: 'offline',
  statKey: 'totalGamesWon',
  target: 50,
  chain: 'victory',
  tier: 3
}, {
  id: 'hundred_wins',
  name: 'Victory IV',
  description: 'Unstoppable force. 100 victories.',
  icon: 'ðŸ†',
  rarity: 'legendary',
  mode: 'offline',
  statKey: 'totalGamesWon',
  target: 100,
  chain: 'victory',
  tier: 4
}, {
  id: 'first_online',
  name: 'Global I',
  description: 'Step into the arena. Face your first online opponent.',
  icon: 'ðŸŒ',
  rarity: 'common',
  mode: 'online',
  chain: 'global',
  tier: 1
}, {
  id: 'first_online_win',
  name: 'Global II',
  description: 'Real opponents, real pressure, real victory.',
  icon: 'ðŸŒ',
  rarity: 'uncommon',
  mode: 'online',
  chain: 'global',
  tier: 2
}, {
  id: 'ten_online_wins',
  name: 'Global III',
  description: 'Battle-tested. Defeat 10 online challengers.',
  icon: 'ðŸŒ',
  rarity: 'rare',
  mode: 'online',
  statKey: 'totalOnlineWins',
  target: 10,
  chain: 'global',
  tier: 3
}, {
  id: 'fifty_online_wins',
  name: 'Global IV',
  description: 'World-class competitor. 50 online victories.',
  icon: 'ðŸŒ',
  rarity: 'epic',
  mode: 'online',
  statKey: 'totalOnlineWins',
  target: 50,
  chain: 'global',
  tier: 4
}, {
  id: 'big_checkout',
  name: 'Checkout I',
  description: 'Nerves of steel. Checkout 100+ in one visit.',
  icon: 'ðŸŽ¯',
  rarity: 'uncommon',
  mode: 'offline',
  statKey: 'highestCheckout',
  target: 100,
  isThreshold: true,
  chain: 'checkout',
  tier: 1
}, {
  id: 'huge_checkout',
  name: 'Checkout II',
  description: 'The impossible made possible. Checkout 150+ points.',
  icon: 'ðŸŽ¯',
  rarity: 'rare',
  mode: 'offline',
  statKey: 'highestCheckout',
  target: 150,
  isThreshold: true,
  chain: 'checkout',
  tier: 2
}, {
  id: 'max_checkout',
  name: 'Checkout III',
  description: 'The ultimate finish. Checkout 170 - the maximum.',
  icon: 'ðŸŽ¯',
  rarity: 'legendary',
  mode: 'offline',
  statKey: 'highestCheckout',
  target: 170,
  isThreshold: true,
  chain: 'checkout',
  tier: 3
}, {
  id: 'fifty_triples',
  name: 'Triple I',
  description: 'Treble trouble for opponents. Hit 50 triples.',
  icon: '3ï¸âƒ£',
  rarity: 'uncommon',
  mode: 'offline',
  statKey: 'totalTriples',
  target: 50,
  chain: 'triple',
  tier: 1
}, {
  id: 'two_hundred_triples',
  name: 'Triple II',
  description: 'The triple 20 is your playground. 200 triples.',
  icon: '3ï¸âƒ£',
  rarity: 'rare',
  mode: 'offline',
  statKey: 'totalTriples',
  target: 200,
  chain: 'triple',
  tier: 2
}, {
  id: 'five_hundred_triples',
  name: 'Triple III',
  description: 'Triple mastery achieved. 500 triples.',
  icon: '3ï¸âƒ£',
  rarity: 'epic',
  mode: 'offline',
  statKey: 'totalTriples',
  target: 500,
  chain: 'triple',
  tier: 3
}];
const TIME_LIMITED_ACHIEVEMENTS = [{
  id: 'weekly_180_sprint',
  name: 'Maximum Week',
  description: 'Hit 10 perfect 180s this week',
  icon: 'ðŸ’¯',
  rarity: 'rare',
  statKey: 'weekly180s',
  target: 10,
  week: 1,
  reward: '180 Master Badge'
}, {
  id: 'weekly_bulls_blitz',
  name: 'Bulls Week',
  description: 'Hit 25 bullseyes this week',
  icon: 'ðŸŽ¯',
  rarity: 'rare',
  statKey: 'weeklyBulls',
  target: 25,
  week: 2,
  reward: 'Bullseye Badge'
}, {
  id: 'weekly_win_streak',
  name: 'Victory Week',
  description: 'Win 10 games this week',
  icon: 'ðŸ†',
  rarity: 'rare',
  statKey: 'weeklyWins',
  target: 10,
  week: 3,
  reward: 'Champion Badge'
}, {
  id: 'weekly_triple_threat',
  name: 'Triples Week',
  description: 'Hit 50 triples this week',
  icon: '3ï¸âƒ£',
  rarity: 'rare',
  statKey: 'weeklyTriples',
  target: 50,
  week: 4,
  reward: 'Triple Badge'
}];
const getCurrentWeekNumber = () => {
  const now = new Date();
  const startOfYear = new Date(now.getFullYear(), 0, 1);
  const weekNumber = Math.ceil(((now - startOfYear) / 86400000 + startOfYear.getDay() + 1) / 7);
  return (weekNumber - 1) % 4 + 1;
};
const getActiveTimeLimitedAchievement = () => {
  const currentWeek = getCurrentWeekNumber();
  return TIME_LIMITED_ACHIEVEMENTS.find(a => a.week === currentWeek);
};
const createDefaultWeeklyChallengeData = weekNumber => ({
  weekNumber: weekNumber,
  challengeId: TIME_LIMITED_ACHIEVEMENTS.find(a => a.week === weekNumber)?.id,
  stats: {
    weekly180s: 0,
    weeklyBulls: 0,
    weeklyWins: 0,
    weeklyTriples: 0
  },
  completed: false,
  completedChallenges: []
});
const isValidWeeklyChallengeData = data => {
  if (!data || typeof data !== 'object') return false;
  if (typeof data.weekNumber !== 'number') return false;
  if (!data.stats || typeof data.stats !== 'object') return false;
  if (typeof data.completed !== 'boolean') return false;
  if (!Array.isArray(data.completedChallenges)) return false;
  return true;
};
const getTimeUntilWeeklyReset = () => {
  const now = new Date();
  const nextSunday = new Date(now);
  nextSunday.setDate(now.getDate() + (7 - now.getDay()));
  nextSunday.setHours(0, 0, 0, 0);
  return nextSunday - now;
};
const formatTimeRemaining = ms => {
  const days = Math.floor(ms / (1000 * 60 * 60 * 24));
  const hours = Math.floor(ms % (1000 * 60 * 60 * 24) / (1000 * 60 * 60));
  const minutes = Math.floor(ms % (1000 * 60 * 60) / (1000 * 60));
  if (days > 0) return `${days}d ${hours}h`;
  if (hours > 0) return `${hours}h ${minutes}m`;
  return `${minutes}m`;
};
const DAILY_CHALLENGES_POOL = [{
  id: 'daily_180_1',
  name: 'Maximum!',
  description: 'Hit 1 perfect 180',
  icon: 'ðŸ’¯',
  statKey: 'daily180s',
  target: 1,
  difficulty: 'easy'
}, {
  id: 'daily_180_3',
  name: 'Triple Maximum',
  description: 'Hit 3 perfect 180s',
  icon: 'ðŸ’¯',
  statKey: 'daily180s',
  target: 3,
  difficulty: 'medium'
}, {
  id: 'daily_180_5',
  name: '180 Machine',
  description: 'Hit 5 perfect 180s',
  icon: 'ðŸ’¯',
  statKey: 'daily180s',
  target: 5,
  difficulty: 'hard'
}, {
  id: 'daily_bulls_5',
  name: 'Bullseye Starter',
  description: 'Hit 5 bullseyes',
  icon: 'ðŸŽ¯',
  statKey: 'dailyBulls',
  target: 5,
  difficulty: 'easy'
}, {
  id: 'daily_bulls_15',
  name: 'Bulls on Target',
  description: 'Hit 15 bullseyes',
  icon: 'ðŸŽ¯',
  statKey: 'dailyBulls',
  target: 15,
  difficulty: 'medium'
}, {
  id: 'daily_bulls_30',
  name: 'Bull Master',
  description: 'Hit 30 bullseyes',
  icon: 'ðŸŽ¯',
  statKey: 'dailyBulls',
  target: 30,
  difficulty: 'hard'
}, {
  id: 'daily_wins_1',
  name: 'First Win',
  description: 'Win 1 game',
  icon: 'ðŸ†',
  statKey: 'dailyWins',
  target: 1,
  difficulty: 'easy'
}, {
  id: 'daily_wins_3',
  name: 'Winning Streak',
  description: 'Win 3 games',
  icon: 'ðŸ†',
  statKey: 'dailyWins',
  target: 3,
  difficulty: 'medium'
}, {
  id: 'daily_wins_5',
  name: 'Dominant Day',
  description: 'Win 5 games',
  icon: 'ðŸ†',
  statKey: 'dailyWins',
  target: 5,
  difficulty: 'hard'
}, {
  id: 'daily_games_3',
  name: 'Warm Up',
  description: 'Play 3 games',
  icon: 'ðŸŽ®',
  statKey: 'dailyGames',
  target: 3,
  difficulty: 'easy'
}, {
  id: 'daily_games_5',
  name: 'Practice Run',
  description: 'Play 5 games',
  icon: 'ðŸŽ®',
  statKey: 'dailyGames',
  target: 5,
  difficulty: 'medium'
}, {
  id: 'daily_games_10',
  name: 'Marathon',
  description: 'Play 10 games',
  icon: 'ðŸŽ®',
  statKey: 'dailyGames',
  target: 10,
  difficulty: 'hard'
}, {
  id: 'daily_triples_10',
  name: 'Triple Starter',
  description: 'Hit 10 triples',
  icon: '3ï¸âƒ£',
  statKey: 'dailyTriples',
  target: 10,
  difficulty: 'easy'
}, {
  id: 'daily_triples_25',
  name: 'Triple Threat',
  description: 'Hit 25 triples',
  icon: '3ï¸âƒ£',
  statKey: 'dailyTriples',
  target: 25,
  difficulty: 'medium'
}, {
  id: 'daily_triples_50',
  name: 'Triple Master',
  description: 'Hit 50 triples',
  icon: '3ï¸âƒ£',
  statKey: 'dailyTriples',
  target: 50,
  difficulty: 'hard'
}, {
  id: 'daily_score_500',
  name: 'Score Seeker',
  description: 'Score 500 points',
  icon: 'ðŸ“Š',
  statKey: 'dailyScore',
  target: 500,
  difficulty: 'easy'
}, {
  id: 'daily_score_1500',
  name: 'Point Collector',
  description: 'Score 1500 points',
  icon: 'ðŸ“Š',
  statKey: 'dailyScore',
  target: 1500,
  difficulty: 'medium'
}, {
  id: 'daily_score_3000',
  name: 'High Scorer',
  description: 'Score 3000 points',
  icon: 'ðŸ“Š',
  statKey: 'dailyScore',
  target: 3000,
  difficulty: 'hard'
}];
const DIFFICULTY_COLORS = {
  easy: '#27ae60',
  medium: '#f39c12',
  hard: '#e74c3c'
};
const AI_DIFFICULTIES = {
  BEGINNER: {
    key: 'beginner',
    accuracy: 35,
    label: 'Beginner'
  },
  INTERMEDIATE: {
    key: 'intermediate',
    accuracy: 60,
    label: 'Intermediate'
  },
  EXPERT: {
    key: 'expert',
    accuracy: 80,
    label: 'Expert'
  },
  IMPOSSIBLE: {
    key: 'impossible',
    accuracy: 95,
    label: 'Impossible'
  }
};
const generateDailyChallenges = dateString => {
  const seed = dateString.split('-').reduce((acc, val) => acc + parseInt(val), 0);
  const shuffled = [...DAILY_CHALLENGES_POOL].sort((a, b) => {
    const hashA = (seed * 31 + a.id.charCodeAt(0)) % 1000;
    const hashB = (seed * 31 + b.id.charCodeAt(0)) % 1000;
    return hashA - hashB;
  });
  const easy = shuffled.find(c => c.difficulty === 'easy');
  const medium = shuffled.find(c => c.difficulty === 'medium');
  const hard = shuffled.find(c => c.difficulty === 'hard');
  return [easy, medium, hard].filter(Boolean);
};
const getTodayString = () => {
  const today = new Date();
  return `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
};
const createDefaultDailyChallengeData = dateString => ({
  date: dateString,
  challenges: generateDailyChallenges(dateString),
  stats: {
    daily180s: 0,
    dailyBulls: 0,
    dailyWins: 0,
    dailyGames: 0,
    dailyTriples: 0,
    dailyScore: 0
  },
  completedChallenges: []
});
const isValidDailyChallengeData = data => {
  if (!data || typeof data !== 'object') return false;
  if (typeof data.date !== 'string') return false;
  if (!Array.isArray(data.challenges)) return false;
  if (!data.stats || typeof data.stats !== 'object') return false;
  if (!Array.isArray(data.completedChallenges)) return false;
  for (const challenge of data.challenges) {
    if (!challenge.id || !challenge.statKey || typeof challenge.target !== 'number') {
      return false;
    }
  }
  return true;
};
const COUNTRIES = [{
  name: 'Afghanistan',
  flag: 'ðŸ‡¦ðŸ‡«'
}, {
  name: 'Albania',
  flag: 'ðŸ‡¦ðŸ‡±'
}, {
  name: 'Algeria',
  flag: 'ðŸ‡©ðŸ‡¿'
}, {
  name: 'Argentina',
  flag: 'ðŸ‡¦ðŸ‡·'
}, {
  name: 'Armenia',
  flag: 'ðŸ‡¦ðŸ‡²'
}, {
  name: 'Australia',
  flag: 'ðŸ‡¦ðŸ‡º'
}, {
  name: 'Austria',
  flag: 'ðŸ‡¦ðŸ‡¹'
}, {
  name: 'Azerbaijan',
  flag: 'ðŸ‡¦ðŸ‡¿'
}, {
  name: 'Bahrain',
  flag: 'ðŸ‡§ðŸ‡­'
}, {
  name: 'Bangladesh',
  flag: 'ðŸ‡§ðŸ‡©'
}, {
  name: 'Belarus',
  flag: 'ðŸ‡§ðŸ‡¾'
}, {
  name: 'Belgium',
  flag: 'ðŸ‡§ðŸ‡ª'
}, {
  name: 'Bolivia',
  flag: 'ðŸ‡§ðŸ‡´'
}, {
  name: 'Bosnia',
  flag: 'ðŸ‡§ðŸ‡¦'
}, {
  name: 'Brazil',
  flag: 'ðŸ‡§ðŸ‡·'
}, {
  name: 'Bulgaria',
  flag: 'ðŸ‡§ðŸ‡¬'
}, {
  name: 'Cambodia',
  flag: 'ðŸ‡°ðŸ‡­'
}, {
  name: 'Canada',
  flag: 'ðŸ‡¨ðŸ‡¦'
}, {
  name: 'Chile',
  flag: 'ðŸ‡¨ðŸ‡±'
}, {
  name: 'China',
  flag: 'ðŸ‡¨ðŸ‡³'
}, {
  name: 'Colombia',
  flag: 'ðŸ‡¨ðŸ‡´'
}, {
  name: 'Costa Rica',
  flag: 'ðŸ‡¨ðŸ‡·'
}, {
  name: 'Croatia',
  flag: 'ðŸ‡­ðŸ‡·'
}, {
  name: 'Cuba',
  flag: 'ðŸ‡¨ðŸ‡º'
}, {
  name: 'Cyprus',
  flag: 'ðŸ‡¨ðŸ‡¾'
}, {
  name: 'Czech Republic',
  flag: 'ðŸ‡¨ðŸ‡¿'
}, {
  name: 'Denmark',
  flag: 'ðŸ‡©ðŸ‡°'
}, {
  name: 'Ecuador',
  flag: 'ðŸ‡ªðŸ‡¨'
}, {
  name: 'Egypt',
  flag: 'ðŸ‡ªðŸ‡¬'
}, {
  name: 'England',
  flag: 'ðŸ´ó §ó ¢ó ¥ó ®ó §ó ¿'
}, {
  name: 'Estonia',
  flag: 'ðŸ‡ªðŸ‡ª'
}, {
  name: 'Ethiopia',
  flag: 'ðŸ‡ªðŸ‡¹'
}, {
  name: 'Finland',
  flag: 'ðŸ‡«ðŸ‡®'
}, {
  name: 'France',
  flag: 'ðŸ‡«ðŸ‡·'
}, {
  name: 'Georgia',
  flag: 'ðŸ‡¬ðŸ‡ª'
}, {
  name: 'Germany',
  flag: 'ðŸ‡©ðŸ‡ª'
}, {
  name: 'Ghana',
  flag: 'ðŸ‡¬ðŸ‡­'
}, {
  name: 'Greece',
  flag: 'ðŸ‡¬ðŸ‡·'
}, {
  name: 'Hong Kong',
  flag: 'ðŸ‡­ðŸ‡°'
}, {
  name: 'Hungary',
  flag: 'ðŸ‡­ðŸ‡º'
}, {
  name: 'Iceland',
  flag: 'ðŸ‡®ðŸ‡¸'
}, {
  name: 'India',
  flag: 'ðŸ‡®ðŸ‡³'
}, {
  name: 'Indonesia',
  flag: 'ðŸ‡®ðŸ‡©'
}, {
  name: 'Iran',
  flag: 'ðŸ‡®ðŸ‡·'
}, {
  name: 'Iraq',
  flag: 'ðŸ‡®ðŸ‡¶'
}, {
  name: 'Ireland',
  flag: 'ðŸ‡®ðŸ‡ª'
}, {
  name: 'Israel',
  flag: 'ðŸ‡®ðŸ‡±'
}, {
  name: 'Italy',
  flag: 'ðŸ‡®ðŸ‡¹'
}, {
  name: 'Jamaica',
  flag: 'ðŸ‡¯ðŸ‡²'
}, {
  name: 'Japan',
  flag: 'ðŸ‡¯ðŸ‡µ'
}, {
  name: 'Jordan',
  flag: 'ðŸ‡¯ðŸ‡´'
}, {
  name: 'Kazakhstan',
  flag: 'ðŸ‡°ðŸ‡¿'
}, {
  name: 'Kenya',
  flag: 'ðŸ‡°ðŸ‡ª'
}, {
  name: 'Kuwait',
  flag: 'ðŸ‡°ðŸ‡¼'
}, {
  name: 'Latvia',
  flag: 'ðŸ‡±ðŸ‡»'
}, {
  name: 'Lebanon',
  flag: 'ðŸ‡±ðŸ‡§'
}, {
  name: 'Libya',
  flag: 'ðŸ‡±ðŸ‡¾'
}, {
  name: 'Lithuania',
  flag: 'ðŸ‡±ðŸ‡¹'
}, {
  name: 'Luxembourg',
  flag: 'ðŸ‡±ðŸ‡º'
}, {
  name: 'Malaysia',
  flag: 'ðŸ‡²ðŸ‡¾'
}, {
  name: 'Malta',
  flag: 'ðŸ‡²ðŸ‡¹'
}, {
  name: 'Mexico',
  flag: 'ðŸ‡²ðŸ‡½'
}, {
  name: 'Morocco',
  flag: 'ðŸ‡²ðŸ‡¦'
}, {
  name: 'Nepal',
  flag: 'ðŸ‡³ðŸ‡µ'
}, {
  name: 'Netherlands',
  flag: 'ðŸ‡³ðŸ‡±'
}, {
  name: 'New Zealand',
  flag: 'ðŸ‡³ðŸ‡¿'
}, {
  name: 'Nigeria',
  flag: 'ðŸ‡³ðŸ‡¬'
}, {
  name: 'North Korea',
  flag: 'ðŸ‡°ðŸ‡µ'
}, {
  name: 'Northern Ireland',
  flag: 'ðŸ‡¬ðŸ‡§'
}, {
  name: 'Norway',
  flag: 'ðŸ‡³ðŸ‡´'
}, {
  name: 'Pakistan',
  flag: 'ðŸ‡µðŸ‡°'
}, {
  name: 'Palestine',
  flag: 'ðŸ‡µðŸ‡¸'
}, {
  name: 'Panama',
  flag: 'ðŸ‡µðŸ‡¦'
}, {
  name: 'Peru',
  flag: 'ðŸ‡µðŸ‡ª'
}, {
  name: 'Philippines',
  flag: 'ðŸ‡µðŸ‡­'
}, {
  name: 'Poland',
  flag: 'ðŸ‡µðŸ‡±'
}, {
  name: 'Portugal',
  flag: 'ðŸ‡µðŸ‡¹'
}, {
  name: 'Qatar',
  flag: 'ðŸ‡¶ðŸ‡¦'
}, {
  name: 'Romania',
  flag: 'ðŸ‡·ðŸ‡´'
}, {
  name: 'Russia',
  flag: 'ðŸ‡·ðŸ‡º'
}, {
  name: 'Saudi Arabia',
  flag: 'ðŸ‡¸ðŸ‡¦'
}, {
  name: 'Scotland',
  flag: 'ðŸ´ó §ó ¢ó ³ó £ó ´ó ¿'
}, {
  name: 'Senegal',
  flag: 'ðŸ‡¸ðŸ‡³'
}, {
  name: 'Serbia',
  flag: 'ðŸ‡·ðŸ‡¸'
}, {
  name: 'Singapore',
  flag: 'ðŸ‡¸ðŸ‡¬'
}, {
  name: 'Slovakia',
  flag: 'ðŸ‡¸ðŸ‡°'
}, {
  name: 'Slovenia',
  flag: 'ðŸ‡¸ðŸ‡®'
}, {
  name: 'South Africa',
  flag: 'ðŸ‡¿ðŸ‡¦'
}, {
  name: 'South Korea',
  flag: 'ðŸ‡°ðŸ‡·'
}, {
  name: 'Spain',
  flag: 'ðŸ‡ªðŸ‡¸'
}, {
  name: 'Sri Lanka',
  flag: 'ðŸ‡±ðŸ‡°'
}, {
  name: 'Sweden',
  flag: 'ðŸ‡¸ðŸ‡ª'
}, {
  name: 'Switzerland',
  flag: 'ðŸ‡¨ðŸ‡­'
}, {
  name: 'Syria',
  flag: 'ðŸ‡¸ðŸ‡¾'
}, {
  name: 'Taiwan',
  flag: 'ðŸ‡¹ðŸ‡¼'
}, {
  name: 'Thailand',
  flag: 'ðŸ‡¹ðŸ‡­'
}, {
  name: 'Tunisia',
  flag: 'ðŸ‡¹ðŸ‡³'
}, {
  name: 'Turkey',
  flag: 'ðŸ‡¹ðŸ‡·'
}, {
  name: 'UAE',
  flag: 'ðŸ‡¦ðŸ‡ª'
}, {
  name: 'Uganda',
  flag: 'ðŸ‡ºðŸ‡¬'
}, {
  name: 'Ukraine',
  flag: 'ðŸ‡ºðŸ‡¦'
}, {
  name: 'United Kingdom',
  flag: 'ðŸ‡¬ðŸ‡§'
}, {
  name: 'Uruguay',
  flag: 'ðŸ‡ºðŸ‡¾'
}, {
  name: 'USA',
  flag: 'ðŸ‡ºðŸ‡¸'
}, {
  name: 'Uzbekistan',
  flag: 'ðŸ‡ºðŸ‡¿'
}, {
  name: 'Venezuela',
  flag: 'ðŸ‡»ðŸ‡ª'
}, {
  name: 'Vietnam',
  flag: 'ðŸ‡»ðŸ‡³'
}, {
  name: 'Wales',
  flag: 'ðŸ´ó §ó ¢ó ·ó ¬ó ³ó ¿'
}, {
  name: 'Yemen',
  flag: 'ðŸ‡¾ðŸ‡ª'
}, {
  name: 'Zimbabwe',
  flag: 'ðŸ‡¿ðŸ‡¼'
}];
const CHECKOUT_SUGGESTIONS = {
  170: 'T20 T20 Bull',
  167: 'T20 T19 Bull',
  164: 'T20 T18 Bull',
  161: 'T20 T17 Bull',
  160: 'T20 T20 D20',
  158: 'T20 T20 D19',
  157: 'T20 T19 D20',
  156: 'T20 T20 D18',
  155: 'T20 T19 D19',
  154: 'T20 T18 D20',
  153: 'T20 T19 D18',
  152: 'T20 T20 D16',
  151: 'T20 T17 D20',
  150: 'T20 T18 D18',
  149: 'T20 T19 D16',
  148: 'T20 T20 D14',
  147: 'T20 T17 D18',
  146: 'T20 T18 D16',
  145: 'T20 T19 D14',
  144: 'T20 T20 D12',
  143: 'T20 T17 D16',
  142: 'T20 T14 D20',
  141: 'T20 T19 D12',
  140: 'T20 T20 D10',
  139: 'T20 T13 D20',
  138: 'T20 T18 D12',
  137: 'T20 T19 D10',
  136: 'T20 T20 D8',
  135: 'T20 T17 D12',
  134: 'T20 T14 D16',
  133: 'T20 T19 D8',
  132: 'T20 T16 D12',
  131: 'T20 T13 D16',
  130: 'T20 T18 D8',
  129: 'T19 T16 D12',
  128: 'T18 T14 D16',
  127: 'T20 T17 D8',
  126: 'T19 T19 D6',
  125: 'T20 T19 D4',
  124: 'T20 T16 D8',
  123: 'T19 T16 D9',
  122: 'T18 T18 D7',
  121: 'T20 T11 D14',
  120: 'T20 S20 D20',
  119: 'T19 T12 D13',
  118: 'T20 S18 D20',
  117: 'T20 S17 D20',
  116: 'T20 S16 D20',
  115: 'T20 S15 D20',
  114: 'T20 S14 D20',
  113: 'T20 S13 D20',
  112: 'T20 S12 D20',
  111: 'T20 S11 D20',
  110: 'T20 S10 D20',
  109: 'T20 S9 D20',
  108: 'T20 S8 D20',
  107: 'T19 S10 D20',
  106: 'T20 S6 D20',
  105: 'T20 S5 D20',
  104: 'T20 S4 D20',
  103: 'T20 S3 D20',
  102: 'T20 S2 D20',
  101: 'T20 S1 D20',
  100: 'T20 D20',
  99: 'T19 S10 D16',
  98: 'T20 D19',
  97: 'T19 D20',
  96: 'T20 D18',
  95: 'T19 D19',
  94: 'T18 D20',
  93: 'T19 D18',
  92: 'T20 D16',
  91: 'T17 D20',
  90: 'T18 D18',
  89: 'T19 D16',
  88: 'T20 D14',
  87: 'T17 D18',
  86: 'T18 D16',
  85: 'T19 D14',
  84: 'T20 D12',
  83: 'T17 D16',
  82: 'T14 D20',
  81: 'T19 D12',
  80: 'T20 D10',
  79: 'T13 D20',
  78: 'T18 D12',
  77: 'T19 D10',
  76: 'T20 D8',
  75: 'T17 D12',
  74: 'T14 D16',
  73: 'T19 D8',
  72: 'T16 D12',
  71: 'T13 D16',
  70: 'T18 D8',
  69: 'T19 D6',
  68: 'T20 D4',
  67: 'T17 D8',
  66: 'T10 D18',
  65: 'T19 D4',
  64: 'T16 D8',
  63: 'T13 D12',
  62: 'T10 D16',
  61: 'T15 D8',
  60: 'S20 D20',
  59: 'S19 D20',
  58: 'S18 D20',
  57: 'S17 D20',
  56: 'S16 D20',
  55: 'S15 D20',
  54: 'S14 D20',
  53: 'S13 D20',
  52: 'S12 D20',
  51: 'S11 D20',
  50: 'S10 D20',
  49: 'S9 D20',
  48: 'S8 D20',
  47: 'S7 D20',
  46: 'S6 D20',
  45: 'S5 D20',
  44: 'S4 D20',
  43: 'S3 D20',
  42: 'S2 D20',
  41: 'S1 D20',
  40: 'D20',
  38: 'D19',
  36: 'D18',
  34: 'D17',
  32: 'D16',
  30: 'D15',
  28: 'D14',
  26: 'D13',
  24: 'D12',
  22: 'D11',
  20: 'D10',
  18: 'D9',
  16: 'D8',
  14: 'D7',
  12: 'D6',
  10: 'D5',
  8: 'D4',
  6: 'D3',
  4: 'D2',
  2: 'D1'
};
const DartsGame = () => {
  const [gameState, setGameState] = useState('landing');
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
  const [players, setPlayers] = useState([]);
  const [currentPlayerIndex, setCurrentPlayerIndex] = useState(0);
  const [dartsThrown, setDartsThrown] = useState(0);
  const [currentTurnScore, setCurrentTurnScore] = useState(0);
  const [throwHistory, setThrowHistory] = useState([]);
  const [aimPosition, setAimPosition] = useState({
    x: CENTER,
    y: CENTER
  });
  const [isAiming, setIsAiming] = useState(false);
  const [power, setPower] = useState(0);
  const [isPowerCharging, setIsPowerCharging] = useState(false);
  const [dartPositions, setDartPositions] = useState([]);
  const [showScorePopup, setShowScorePopup] = useState(null);
  const [gameStats, setGameStats] = useState({});
  const [winner, setWinner] = useState(null);
  const [skillLevel, setSkillLevel] = useState(60);
  const [soundEnabled, setSoundEnabled] = useState(true);
  const [showStats, setShowStats] = useState(false);
  const [playerSetup, setPlayerSetup] = useState({
    count: 1,
    names: ['Player 1', 'Player 2', 'Player 3', 'Player 4'],
    gameMode: 501,
    aiPlayers: [false, false, false, false],
    aiDifficulty: [null, null, null, null],
    legsPerSet: 3,
    setsToWin: 1,
    flags: ['ðŸ´ó §ó ¢ó ¥ó ®ó §ó ¿', 'ðŸ´ó §ó ¢ó ¥ó ®ó §ó ¿', 'ðŸ´ó §ó ¢ó ¥ó ®ó §ó ¿', 'ðŸ´ó §ó ¢ó ¥ó ®ó §ó ¿']
  });
  const [animatingDart, setAnimatingDart] = useState(null);
  const [checkout, setCheckout] = useState(null);
  const [triplesHit, setTriplesHit] = useState(0);
  const [isCheckoutPosition, setIsCheckoutPosition] = useState(false);
  const [legScores, setLegScores] = useState([]);
  const [setScores, setSetScores] = useState([]);
  const [matchWinner, setMatchWinner] = useState(null);
  const [legDartsThrown, setLegDartsThrown] = useState([]);
  const [showNineDarter, setShowNineDarter] = useState(false);
  const [currentTurnThrows, setCurrentTurnThrows] = useState([]);
  const [aimWobble, setAimWobble] = useState({
    x: 0,
    y: 0
  });
  const [isMobile, setIsMobile] = useState(() => {
    const isSmallScreen = window.innerWidth < 600;
    const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    const isMobileUA = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    return isSmallScreen || hasTouchScreen && isMobileUA;
  });
  const [onlineMode, setOnlineMode] = useState(false);
  const [matchmakingState, setMatchmakingState] = useState(null);
  const [gameRoomId, setGameRoomId] = useState(null);
  const [playerId, setPlayerId] = useState(null);
  const [myAuthId, setMyAuthId] = useState(null);
  const [opponentName, setOpponentName] = useState('');
  const [opponentFlag, setOpponentFlag] = useState('ðŸŒ');
  const [opponentLevel, setOpponentLevel] = useState(1);
  const [opponentAvatar, setOpponentAvatar] = useState(null);
  const [pendingGameInfo, setPendingGameInfo] = useState(null);
  const gameRoomRef = useRef(null);
  const opponentWasConnected = useRef(false);
  const earlyDisconnectListenerRef = useRef(null);
  const heartbeatIntervalRef = useRef(null);
  const myPlayerKeyRef = useRef(null);
  const [practiceMode, setPracticeMode] = useState(false);
  const [practiceSkillLevel, setPracticeSkillLevel] = useState(null);
  const [practiceStats, setPracticeStats] = useState({
    dartsThrown: 0,
    t20: 0,
    t19: 0,
    t18: 0,
    bulls: 0,
    singleBull: 0,
    triples: 0,
    doubles: 0,
    totalScore: 0
  });
  const [unlockedAchievements, setUnlockedAchievements] = useState(() => {
    try {
      const saved = localStorage.getItem('quikdarts_achievements');
      if (saved) {
        const parsed = JSON.parse(saved);
        return Array.isArray(parsed) ? parsed.filter(id => typeof id === 'string' && ACHIEVEMENTS_DATA.some(a => a.id === id)) : [];
      }
      return [];
    } catch (error) {
      console.error('Failed to load achievements from localStorage:', error);
      return [];
    }
  });
  const [achievementPopup, setAchievementPopup] = useState(null);
  const [showAchievements, setShowAchievements] = useState(false);
  const [achievementTab, setAchievementTab] = useState('offline');
  const [showLoginModal, setShowLoginModal] = useState(false);
  const [currentUser, setCurrentUser] = useState(null);
  const [coinBalance, setCoinBalance] = useState(0);
  const [dailyBonusAvailable, setDailyBonusAvailable] = useState(false);
  const [showStakeSelection, setShowStakeSelection] = useState(false);
  const [selectedStake, setSelectedStake] = useState(50);
  const [isClaimingBonus, setIsClaimingBonus] = useState(false);
  const [adsRemainingToday, setAdsRemainingToday] = useState(5);
  const [isWatchingAd, setIsWatchingAd] = useState(false);
  const [adError, setAdError] = useState(null);
  const [showCoinShop, setShowCoinShop] = useState(false);
  const [isPurchasing, setIsPurchasing] = useState(false);
  const walletListenerRef = useRef(null);
  const profileListenerRef = useRef(null);
  const [userProfile, setUserProfile] = useState(null);
  const [userProgression, setUserProgression] = useState(null);
  const [userStreaks, setUserStreaks] = useState(null);
  const [showProfileScreen, setShowProfileScreen] = useState(false);
  const [isEditingNickname, setIsEditingNickname] = useState(false);
  const [nicknameInput, setNicknameInput] = useState('');
  const [currentEscrowId, setCurrentEscrowId] = useState(null);
  const [isWageredMatch, setIsWageredMatch] = useState(false);
  const [showLeaveConfirmation, setShowLeaveConfirmation] = useState(false);
  const [isCreatingEscrow, setIsCreatingEscrow] = useState(false);
  const [escrowData, setEscrowData] = useState(null);
  const [scoreConfirming, setScoreConfirming] = useState(false);
  const [rhythmState, setRhythmState] = useState('neutral');
  const [achievementStats, setAchievementStats] = useState(() => {
    try {
      const saved = localStorage.getItem('quikdarts_stats');
      return saved ? JSON.parse(saved) : {
        totalGamesPlayed: 0,
        totalGamesWon: 0,
        total180s: 0,
        totalNineDarters: 0,
        totalOnlineGames: 0,
        totalOnlineWins: 0,
        totalBulls: 0,
        totalTriples: 0,
        highestCheckout: 0
      };
    } catch (error) {
      console.error('Failed to load achievement stats from localStorage:', error);
      return {
        totalGamesPlayed: 0,
        totalGamesWon: 0,
        total180s: 0,
        totalNineDarters: 0,
        totalOnlineGames: 0,
        totalOnlineWins: 0,
        totalBulls: 0,
        totalTriples: 0,
        highestCheckout: 0
      };
    }
  });
  const hasAIOpponent = useMemo(() => {
    return players.length > 1 && players.some(p => p.isAI);
  }, [players]);
  const [weeklyChallenge, setWeeklyChallenge] = useState(() => {
    const currentWeek = getCurrentWeekNumber();
    try {
      const saved = localStorage.getItem('quikdarts_weekly_challenge');
      if (saved) {
        const parsed = JSON.parse(saved);
        if (isValidWeeklyChallengeData(parsed) && parsed.weekNumber === currentWeek) {
          return parsed;
        }
      }
    } catch (error) {
      console.error('Failed to load weekly challenge:', error);
    }
    return createDefaultWeeklyChallengeData(currentWeek);
  });
  const [timeUntilReset, setTimeUntilReset] = useState(getTimeUntilWeeklyReset());
  const [dailyChallengeData, setDailyChallengeData] = useState(() => {
    const today = getTodayString();
    try {
      const saved = localStorage.getItem('quikdarts_daily_challenges');
      if (saved) {
        const parsed = JSON.parse(saved);
        if (isValidDailyChallengeData(parsed) && parsed.date === today) {
          return parsed;
        }
      }
    } catch (error) {
      console.error('Failed to load daily challenges:', error);
    }
    return createDefaultDailyChallengeData(today);
  });
  const [selectedThemeId, setSelectedThemeId] = useState(() => {
    try {
      const saved = localStorage.getItem('quikdarts_theme');
      if (saved) {
        const parsed = JSON.parse(saved);
        if (isValidThemeId(parsed.themeId)) {
          return parsed.themeId;
        }
      }
      return DEFAULT_THEME_ID;
    } catch (error) {
      console.error('Failed to load theme from localStorage:', error);
      return DEFAULT_THEME_ID;
    }
  });
  const [selectedNeonColor, setSelectedNeonColor] = useState(() => {
    try {
      const saved = localStorage.getItem('quikdarts_theme');
      if (saved) {
        const parsed = JSON.parse(saved);
        if (parsed.neonColor && Object.values(NEON_COLOR_OPTIONS).includes(parsed.neonColor)) {
          return parsed.neonColor;
        }
      }
      return NEON_COLOR_OPTIONS.CYAN;
    } catch (error) {
      console.error('Failed to load neon color from localStorage:', error);
      return NEON_COLOR_OPTIONS.CYAN;
    }
  });
  const [neonPulsePhase, setNeonPulsePhase] = useState(0);
  const saveThemeSelection = useCallback((themeId, neonColor) => {
    try {
      const themeData = {
        themeId: themeId,
        neonColor: neonColor,
        savedAt: new Date().toISOString()
      };
      localStorage.setItem('quikdarts_theme', JSON.stringify(themeData));
    } catch (error) {
      console.error('Failed to save theme to localStorage:', error);
    }
  }, []);
  const handleThemeChange = useCallback(themeId => {
    if (isValidThemeId(themeId)) {
      setSelectedThemeId(themeId);
      saveThemeSelection(themeId, selectedNeonColor);
    }
  }, [selectedNeonColor, saveThemeSelection]);
  const handleNeonColorChange = useCallback(neonColor => {
    if (Object.values(NEON_COLOR_OPTIONS).includes(neonColor)) {
      setSelectedNeonColor(neonColor);
      saveThemeSelection(selectedThemeId, neonColor);
    }
  }, [selectedThemeId, saveThemeSelection]);
  const currentTheme = getThemeById(selectedThemeId);
  const currentThemeColors = getThemeColors(currentTheme, selectedNeonColor);
  useEffect(() => {
    if (currentTheme.effects.pulseAnimation) {
      const interval = setInterval(() => {
        setNeonPulsePhase(prev => (prev + 0.05) % (2 * Math.PI));
      }, 50);
      return () => clearInterval(interval);
    }
  }, [currentTheme.effects.pulseAnimation]);
  useEffect(() => {
    const handleResize = () => {
      const isSmallScreen = window.innerWidth < 600;
      const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      const isMobileUA = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      setIsMobile(isSmallScreen || hasTouchScreen && isMobileUA);
    };
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  useEffect(() => {
    if (matchmakingState !== 'found' || !pendingGameInfo) return;
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const delay = prefersReducedMotion ? 0 : MATCHMAKING_TIMINGS.FOUND_TO_INTRO_DELAY_MS;
    const timer = setTimeout(() => {
      if (isWageredMatch) {
        setMatchmakingState('intro');
      } else {
        startOnlineGame(pendingGameInfo.roomId, pendingGameInfo.playerIndex);
        setPendingGameInfo(null);
      }
    }, delay);
    return () => clearTimeout(timer);
  }, [matchmakingState, pendingGameInfo, isWageredMatch]);
  useEffect(() => {
    if (matchmakingState !== 'intro' || !pendingGameInfo) return;
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const delay = prefersReducedMotion ? 0 : MATCHMAKING_TIMINGS.INTRO_DURATION_MS;
    const timer = setTimeout(() => {
      startOnlineGame(pendingGameInfo.roomId, pendingGameInfo.playerIndex);
      setPendingGameInfo(null);
    }, delay);
    return () => clearTimeout(timer);
  }, [matchmakingState, pendingGameInfo]);
  const boardRef = useRef(null);
  const powerIntervalRef = useRef(null);
  const powerResetTimeoutRef = useRef(null);
  const matchmakingIntervalRef = useRef(null);
  const wageredListenerRef = useRef(null);
  const audioContext = useRef(null);
  const aimPositionRef = useRef({
    x: CENTER,
    y: CENTER
  });
  const playSound = useCallback(type => {
    if (!soundEnabled) return;
    if (!audioContext.current) {
      audioContext.current = new (window.AudioContext || window.webkitAudioContext)();
    }
    const ctx = audioContext.current;
    const oscillator = ctx.createOscillator();
    const gainNode = ctx.createGain();
    oscillator.connect(gainNode);
    gainNode.connect(ctx.destination);
    switch (type) {
      case 'throw':
        oscillator.frequency.setValueAtTime(200, ctx.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.1);
        gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
        oscillator.start(ctx.currentTime);
        oscillator.stop(ctx.currentTime + 0.1);
        break;
      case 'hit':
        oscillator.frequency.setValueAtTime(800, ctx.currentTime);
        gainNode.gain.setValueAtTime(0.2, ctx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.05);
        oscillator.start(ctx.currentTime);
        oscillator.stop(ctx.currentTime + 0.05);
        break;
      case 'bullseye':
        oscillator.frequency.setValueAtTime(523, ctx.currentTime);
        oscillator.frequency.setValueAtTime(659, ctx.currentTime + 0.1);
        oscillator.frequency.setValueAtTime(784, ctx.currentTime + 0.2);
        gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
        oscillator.start(ctx.currentTime);
        oscillator.stop(ctx.currentTime + 0.3);
        break;
      case 'bust':
        oscillator.frequency.setValueAtTime(200, ctx.currentTime);
        oscillator.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.3);
        gainNode.gain.setValueAtTime(0.4, ctx.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
        oscillator.start(ctx.currentTime);
        oscillator.stop(ctx.currentTime + 0.3);
        break;
      case 'win':
        [523, 659, 784, 1047].forEach((freq, i) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.frequency.setValueAtTime(freq, ctx.currentTime + i * 0.15);
          gain.gain.setValueAtTime(0.3, ctx.currentTime + i * 0.15);
          gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.15 + 0.2);
          osc.start(ctx.currentTime + i * 0.15);
          osc.stop(ctx.currentTime + i * 0.15 + 0.2);
        });
        break;
      case '180':
        [392, 523, 659, 784, 1047, 1319].forEach((freq, i) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.frequency.setValueAtTime(freq, ctx.currentTime + i * 0.08);
          gain.gain.setValueAtTime(0.4, ctx.currentTime + i * 0.08);
          gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.08 + 0.15);
          osc.start(ctx.currentTime + i * 0.08);
          osc.stop(ctx.currentTime + i * 0.08 + 0.15);
        });
        break;
      case 'ninedarter':
        const bufferSize = ctx.sampleRate * 3;
        const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = Math.random() * 2 - 1;
        }
        const crowdNoise = ctx.createBufferSource();
        crowdNoise.buffer = buffer;
        const crowdFilter = ctx.createBiquadFilter();
        crowdFilter.type = 'bandpass';
        crowdFilter.frequency.setValueAtTime(800, ctx.currentTime);
        crowdFilter.Q.setValueAtTime(1, ctx.currentTime);
        const crowdGain = ctx.createGain();
        crowdGain.gain.setValueAtTime(0, ctx.currentTime);
        crowdGain.gain.linearRampToValueAtTime(0.3, ctx.currentTime + 0.5);
        crowdGain.gain.setValueAtTime(0.3, ctx.currentTime + 2);
        crowdGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 3);
        crowdNoise.connect(crowdFilter);
        crowdFilter.connect(crowdGain);
        crowdGain.connect(ctx.destination);
        crowdNoise.start(ctx.currentTime);
        crowdNoise.stop(ctx.currentTime + 3);
        [523, 659, 784, 1047, 1319, 1568].forEach((freq, i) => {
          const osc = ctx.createOscillator();
          const gain = ctx.createGain();
          osc.type = 'triangle';
          osc.connect(gain);
          gain.connect(ctx.destination);
          osc.frequency.setValueAtTime(freq, ctx.currentTime + i * 0.15);
          gain.gain.setValueAtTime(0.25, ctx.currentTime + i * 0.15);
          gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.15 + 0.4);
          osc.start(ctx.currentTime + i * 0.15);
          osc.stop(ctx.currentTime + i * 0.15 + 0.4);
        });
        break;
    }
  }, [soundEnabled]);
  const sanitizeName = name => {
    if (!name || typeof name !== 'string') return 'Player';
    return name.slice(0, 20).replace(/[^a-zA-Z0-9\s\-_.!?]/g, '').replace(/\s+/g, ' ').trim() || 'Player';
  };
  const sanitizeFlag = flag => {
    if (!flag || typeof flag !== 'string') return 'ðŸŒ';
    const trimmed = flag.slice(0, 50);
    const hasEmoji = /[\u{1F1E6}-\u{1F1FF}]|[\u{1F3F4}]|[\u{1F300}-\u{1F9FF}]/u.test(trimmed);
    return hasEmoji ? trimmed : 'ðŸŒ';
  };
  const sanitizeAvatarUrl = url => {
    if (!url || typeof url !== 'string') return null;
    if (url.length > 500) return null;
    try {
      const parsed = new URL(url);
      if (parsed.protocol !== 'https:') {
        console.warn('[Security] Rejected non-HTTPS avatar URL');
        return null;
      }
      const allowedHosts = ['firebasestorage.googleapis.com', 'lh3.googleusercontent.com', 'storage.googleapis.com'];
      if (!allowedHosts.some(h => parsed.host === h || parsed.host.endsWith('.' + h))) {
        console.warn('[Security] Rejected untrusted avatar domain:', parsed.host);
        return null;
      }
      return url;
    } catch (e) {
      console.warn('[Security] Invalid avatar URL:', e.message);
      return null;
    }
  };
  const sanitizeLevel = level => {
    const num = parseInt(level, 10);
    if (isNaN(num) || num < 1) return 1;
    if (num > 999) return 999;
    return num;
  };
  const saveNickname = useCallback(async () => {
    if (!currentUser || currentUser.isAnonymous || !database) return;
    const sanitized = sanitizeName(nicknameInput);
    if (!sanitized || sanitized.length < 1 || sanitized === 'Player') {
      alert('Please enter a valid nickname (1-20 characters)');
      return;
    }
    try {
      const profileUpdate = {
        displayName: sanitized
      };
      if (userProfile?.flag) {
        profileUpdate.flag = userProfile.flag;
      }
      if (userProfile?.uniqueId) {
        profileUpdate.uniqueId = userProfile.uniqueId;
      }
      if (userProfile?.avatar) {
        profileUpdate.avatar = userProfile.avatar;
      }
      if (userProfile?.createdAt) {
        profileUpdate.createdAt = userProfile.createdAt;
      }
      if (userProfile?.provider) {
        profileUpdate.provider = userProfile.provider;
      }
      await database.ref(`users/${currentUser.uid}/profile`).set(profileUpdate);
      setIsEditingNickname(false);
      setNicknameInput('');
    } catch (error) {
      console.error('Failed to save nickname:', error);
      alert('Failed to save nickname. Please try again.');
    }
  }, [currentUser, database, nicknameInput, userProfile]);
  const validateScore = (score, gameMode) => {
    if (typeof score !== 'number' || !Number.isInteger(score)) return gameMode || 501;
    if (score < 0 || score > 501 || score === 1) return gameMode || 501;
    return score;
  };
  const validatePlayerIndex = index => {
    if (typeof index !== 'number' || !Number.isInteger(index)) return 0;
    return index === 0 || index === 1 ? index : 0;
  };
  const validateDartsThrown = darts => {
    if (typeof darts !== 'number' || !Number.isInteger(darts)) return 0;
    return darts >= 0 && darts <= 3 ? darts : 0;
  };
  const validateTurnScore = score => {
    if (typeof score !== 'number' || !Number.isInteger(score)) return 0;
    return score >= 0 && score <= 180 ? score : 0;
  };
  const validateScoreArray = (arr, defaultValue = 0) => {
    if (!Array.isArray(arr) || arr.length !== 2) return [defaultValue, defaultValue];
    return arr.map(val => {
      if (typeof val !== 'number' || !Number.isInteger(val) || val < 0) return defaultValue;
      return val;
    });
  };
  const validateThrowItem = item => {
    if (!item || typeof item !== 'object') return null;
    const score = typeof item.score === 'number' && item.score >= 0 && item.score <= 180 ? item.score : 0;
    const rawLabel = typeof item.label === 'string' ? item.label : '';
    const label = rawLabel.replace(/[^A-Z0-9!]/gi, '').slice(0, 10) || 'MISS';
    const player = item.player === 0 || item.player === 1 ? item.player : 0;
    const multiplier = typeof item.multiplier === 'number' && item.multiplier >= 0 && item.multiplier <= 3 ? item.multiplier : 1;
    return {
      score,
      label,
      player,
      multiplier
    };
  };
  const validateDartPosition = pos => {
    if (!pos || typeof pos !== 'object') return null;
    const x = typeof pos.x === 'number' && pos.x >= 0 && pos.x <= 500 ? pos.x : 250;
    const y = typeof pos.y === 'number' && pos.y >= 0 && pos.y <= 500 ? pos.y : 250;
    return {
      x,
      y
    };
  };
  const retryFirebaseOperation = async (operation, maxRetries = 3) => {
    let lastError;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        if (attempt < maxRetries - 1) {
          await new Promise(resolve => setTimeout(resolve, 100 * Math.pow(2, attempt)));
        }
      }
    }
    throw lastError;
  };
  const startMatchmaking = useCallback(async () => {
    if (!database) {
      alert('Firebase not configured. Please add your Firebase credentials to play online.');
      return;
    }
    if (matchmakingState === 'searching') {
      return;
    }
    setMatchmakingState('searching');
    setOnlineMode(true);
    const queueRef = database.ref('matchmaking_queue/casual');
    const authUser = await authReadyPromise;
    if (!authUser) {
      console.error('Authentication required for online play');
      setMatchmakingState('idle');
      setOnlineMode(false);
      return;
    }
    const myPlayerId = authUser.uid;
    setMyAuthId(myPlayerId);
    setTimeout(() => {
      queueRef.orderByChild('timestamp').limitToFirst(1).once('value', async snapshot => {
        if (snapshot.exists()) {
          const opponentId = Object.keys(snapshot.val())[0];
          const opponentData = snapshot.val()[opponentId];
          if (opponentData.playerId === myPlayerId) {
            const myQueueEntry = {
              playerId: myPlayerId,
              name: sanitizeName(userProfile?.displayName || currentUser?.displayName) || 'Player',
              flag: sanitizeFlag(userProfile?.flag) || 'ðŸŒ',
              level: userProgression?.level || 1,
              avatarUrl: sanitizeAvatarUrl(userProfile?.avatar) || null,
              timestamp: firebase.database.ServerValue.TIMESTAMP
            };
            queueRef.child(myPlayerId).set(myQueueEntry);
            return;
          }
          if (!functions) {
            console.error('Cloud Functions not available');
            alert('Online play is temporarily unavailable. Please try again later.');
            cancelMatchmaking();
            return;
          }
          try {
            const createGameFn = functions.httpsCallable('createGame');
            const result = await createGameFn({
              player1Id: opponentData.playerId,
              player1Name: sanitizeName(opponentData.name),
              player1Flag: sanitizeFlag(opponentData.flag),
              player2Id: myPlayerId,
              player2Name: sanitizeName(userProfile?.displayName || currentUser?.displayName) || 'Player',
              player2Flag: sanitizeFlag(userProfile?.flag) || 'ðŸŒ',
              gameMode: playerSetup.gameMode,
              isWagered: false
            });
            if (!result.data.success || !result.data.gameId) {
              console.error('Failed to create game:', result.data.error);
              alert('Failed to create game. Please try again.');
              cancelMatchmaking();
              return;
            }
            const roomId = result.data.gameId;
            setGameRoomId(roomId);
            gameRoomRef.current = database.ref(`games/${roomId}`);
            await queueRef.child(opponentData.playerId).update({
              matchedGameId: roomId,
              matchedByName: sanitizeName(userProfile?.displayName || currentUser?.displayName) || 'Player',
              matchedByFlag: sanitizeFlag(userProfile?.flag) || 'ðŸŒ'
            });
            gameRoomRef.current.child('player2/connected').onDisconnect().set(false).then(() => {
              startHeartbeat(gameRoomRef.current, 'player2', 'player1', () => {
                stopHeartbeat();
                alert('Opponent disconnected. Returning to menu.');
                cancelMatchmaking();
              });
              setOpponentName(sanitizeName(opponentData.name));
              setOpponentFlag(sanitizeFlag(opponentData.flag));
              setOpponentLevel(sanitizeLevel(opponentData.level));
              setOpponentAvatar(sanitizeAvatarUrl(opponentData.avatarUrl));
              setPendingGameInfo({
                roomId,
                playerIndex: 1
              });
              setMatchmakingState('found');
            }).catch(err => {
              console.error('[matchmaking] Failed to register onDisconnect:', err);
              setOpponentName(sanitizeName(opponentData.name));
              setOpponentFlag(sanitizeFlag(opponentData.flag));
              setOpponentLevel(sanitizeLevel(opponentData.level));
              setOpponentAvatar(sanitizeAvatarUrl(opponentData.avatarUrl));
              setPendingGameInfo({
                roomId,
                playerIndex: 1
              });
              setMatchmakingState('found');
            });
          } catch (error) {
            console.error('Error creating game:', error);
            alert('Failed to create game. Please try again.');
            cancelMatchmaking();
            return;
          }
        } else {
          const myQueueEntry = {
            playerId: myPlayerId,
            name: sanitizeName(userProfile?.displayName || currentUser?.displayName) || 'Player',
            flag: sanitizeFlag(userProfile?.flag) || 'ðŸŒ',
            level: userProgression?.level || 1,
            avatarUrl: sanitizeAvatarUrl(userProfile?.avatar) || null,
            timestamp: firebase.database.ServerValue.TIMESTAMP
          };
          queueRef.child(myPlayerId).set(myQueueEntry);
          queueRef.child(myPlayerId).onDisconnect().remove();
          const myQueueEntryRef = queueRef.child(myPlayerId);
          let isProcessingMatch = false;
          const queueEntryListener = myQueueEntryRef.on('value', async snapshot => {
            if (isProcessingMatch) return;
            if (!snapshot.exists()) return;
            const myEntry = snapshot.val();
            if (myEntry.matchedGameId) {
              console.log('[casualMatchmaking] Found matchedGameId in queue entry:', myEntry.matchedGameId);
              isProcessingMatch = true;
              const roomId = myEntry.matchedGameId;
              const opponentName = myEntry.matchedByName || 'Opponent';
              const opponentFlag = myEntry.matchedByFlag || 'ðŸŒ';
              myQueueEntryRef.off('value', queueEntryListener);
              if (matchmakingIntervalRef.current) {
                clearInterval(matchmakingIntervalRef.current);
                matchmakingIntervalRef.current = null;
              }
              await myQueueEntryRef.remove();
              setGameRoomId(roomId);
              gameRoomRef.current = database.ref(`games/${roomId}`);
              let gameData;
              try {
                const gameSnap = await gameRoomRef.current.once('value');
                gameData = gameSnap.val();
              } catch (readErr) {
                console.error('[casualMatchmaking] Failed to read game:', readErr);
                isProcessingMatch = false;
                return;
              }
              if (!gameData || gameData.player1?.id !== myPlayerId) {
                console.error('[casualMatchmaking] Invalid game data - ignoring');
                isProcessingMatch = false;
                return;
              }
              gameRoomRef.current.child('player1/connected').onDisconnect().set(false).then(() => {
                gameRoomRef.current.child('player1/connected').set(true);
                opponentWasConnected.current = true;
                startHeartbeat(gameRoomRef.current, 'player1', 'player2', () => {
                  stopHeartbeat();
                  alert('Opponent disconnected. Returning to menu.');
                  cancelMatchmaking();
                });
                setOpponentName(sanitizeName(opponentName));
                setOpponentFlag(sanitizeFlag(opponentFlag));
                setOpponentLevel(sanitizeLevel(gameData.player2?.level));
                setOpponentAvatar(sanitizeAvatarUrl(gameData.player2?.avatarUrl));
                setPendingGameInfo({
                  roomId,
                  playerIndex: 0
                });
                setMatchmakingState('found');
              }).catch(err => {
                console.error('[casualMatchmaking] Failed to register onDisconnect:', err);
                setOpponentName(sanitizeName(opponentName));
                setOpponentFlag(sanitizeFlag(opponentFlag));
                setOpponentLevel(sanitizeLevel(gameData.player2?.level));
                setOpponentAvatar(sanitizeAvatarUrl(gameData.player2?.avatarUrl));
                setPendingGameInfo({
                  roomId,
                  playerIndex: 0
                });
                setMatchmakingState('found');
              });
            }
          });
          matchmakingIntervalRef.current = setInterval(() => {
            if (isProcessingMatch) return;
            queueRef.orderByChild('timestamp').limitToFirst(2).once('value', async queueSnapshot => {
              if (isProcessingMatch) return;
              if (!queueSnapshot.exists()) return;
              const queuePlayers = queueSnapshot.val();
              const otherPlayerId = Object.keys(queuePlayers).find(id => id !== myPlayerId && !queuePlayers[id].matchedGameId);
              if (otherPlayerId) {
                const otherPlayer = queuePlayers[otherPlayerId];
                isProcessingMatch = true;
                myQueueEntryRef.off('value', queueEntryListener);
                if (matchmakingIntervalRef.current) {
                  clearInterval(matchmakingIntervalRef.current);
                  matchmakingIntervalRef.current = null;
                }
                queueRef.child(myPlayerId).remove();
                if (!functions) {
                  console.error('Cloud Functions not available');
                  isProcessingMatch = false;
                  return;
                }
                try {
                  const createGameFn = functions.httpsCallable('createGame');
                  const result = await createGameFn({
                    player1Id: otherPlayer.playerId,
                    player1Name: sanitizeName(otherPlayer.name),
                    player1Flag: sanitizeFlag(otherPlayer.flag),
                    player2Id: myPlayerId,
                    player2Name: sanitizeName(userProfile?.displayName || currentUser?.displayName) || 'Player',
                    player2Flag: sanitizeFlag(userProfile?.flag) || 'ðŸŒ',
                    gameMode: playerSetup.gameMode,
                    isWagered: false
                  });
                  if (!result.data.success || !result.data.gameId) {
                    console.error('Failed to create game:', result.data.error);
                    isProcessingMatch = false;
                    return;
                  }
                  const roomId = result.data.gameId;
                  await queueRef.child(otherPlayer.playerId).update({
                    matchedGameId: roomId,
                    matchedByName: sanitizeName(userProfile?.displayName || currentUser?.displayName) || 'Player',
                    matchedByFlag: sanitizeFlag(userProfile?.flag) || 'ðŸŒ'
                  });
                  setGameRoomId(roomId);
                  gameRoomRef.current = database.ref(`games/${roomId}`);
                  gameRoomRef.current.child('player2/connected').onDisconnect().set(false).then(() => {
                    startHeartbeat(gameRoomRef.current, 'player2', 'player1', () => {
                      stopHeartbeat();
                      alert('Opponent disconnected. Returning to menu.');
                      cancelMatchmaking();
                    });
                    setOpponentName(sanitizeName(otherPlayer.name));
                    setOpponentFlag(sanitizeFlag(otherPlayer.flag));
                    setOpponentLevel(sanitizeLevel(otherPlayer.level));
                    setOpponentAvatar(sanitizeAvatarUrl(otherPlayer.avatarUrl));
                    setPendingGameInfo({
                      roomId,
                      playerIndex: 1
                    });
                    setMatchmakingState('found');
                  });
                } catch (error) {
                  console.error('Error creating game:', error);
                  isProcessingMatch = false;
                }
              }
            });
          }, 2000);
          setTimeout(() => {
            if (matchmakingState === 'searching') {
              if (matchmakingIntervalRef.current) {
                clearInterval(matchmakingIntervalRef.current);
                matchmakingIntervalRef.current = null;
              }
              queueRef.child(myPlayerId).remove();
              cancelMatchmaking();
              alert('No opponent found. Please try again.');
            }
          }, 60000);
        }
      });
    }, 500);
  }, [database, playerSetup, matchmakingState]);
  const startHeartbeat = useCallback((roomRef, myKey, opponentKey, onDisconnect) => {
    if (heartbeatIntervalRef.current) {
      clearInterval(heartbeatIntervalRef.current);
    }
    myPlayerKeyRef.current = myKey;
    const heartbeatStartTime = Date.now();
    roomRef.child(`${myKey}/lastHeartbeat`).set(Date.now());
    heartbeatIntervalRef.current = setInterval(() => {
      if (!roomRef) return;
      roomRef.child(`${myKey}/lastHeartbeat`).set(Date.now()).catch(() => {});
      roomRef.child(`${opponentKey}/lastHeartbeat`).once('value', snapshot => {
        const opponentHeartbeat = snapshot.val();
        const now = Date.now();
        if (opponentHeartbeat) {
          const timeSinceHeartbeat = now - opponentHeartbeat;
          if (timeSinceHeartbeat > 15000) {
            onDisconnect();
          }
        } else {
          const timeSinceStart = now - heartbeatStartTime;
          if (timeSinceStart > 10000) {
            onDisconnect();
          }
        }
      });
    }, 3000);
  }, []);
  const stopHeartbeat = useCallback(() => {
    if (heartbeatIntervalRef.current) {
      clearInterval(heartbeatIntervalRef.current);
      heartbeatIntervalRef.current = null;
    }
  }, []);
  const startOnlineGame = useCallback((roomId, playerIndex) => {
    setMatchmakingState('playing');
    setGameState('playing');
    setPlayerId(playerIndex);
    if (gameRoomRef.current) {
      gameRoomRef.current.off();
      gameRoomRef.current = null;
    }
    earlyDisconnectListenerRef.current = null;
    setWinner(null);
    setMatchWinner(null);
    setTriplesHit(0);
    setIsCheckoutPosition(false);
    setCurrentTurnThrows([]);
    setGameStats({});
    setLegDartsThrown([0, 0]);
    const roomRef = database.ref(`games/${roomId}`);
    gameRoomRef.current = roomRef;
    const myPlayerKey = playerIndex === 0 ? 'player1' : 'player2';
    roomRef.child(`${myPlayerKey}/connected`).set(true);
    roomRef.child(`${myPlayerKey}/connected`).onDisconnect().set(false);
    roomRef.on('value', snapshot => {
      const gameData = snapshot.val();
      if (!gameData || !gameData.player1 || !gameData.player2 || !gameData.gameMode) {
        console.log('[gameListener] Waiting for complete game data...');
        return;
      }
      console.log('[gameListener] Update received:', {
        p1Score: gameData.player1?.score,
        p2Score: gameData.player2?.score,
        currentPlayer: gameData.currentPlayer,
        dartsThrown: gameData.dartsThrown,
        status: gameData.status
      });
      const myPlayer = playerIndex === 0 ? gameData.player1 : gameData.player2;
      const opponent = playerIndex === 0 ? gameData.player2 : gameData.player1;
      if (opponent.connected === true) {
        opponentWasConnected.current = true;
      }
      if (opponentWasConnected.current && opponent.connected === false && !gameData.winner) {
        opponentWasConnected.current = false;
        console.log('[gameListener] Opponent disconnected! Processing disconnect...', {
          roomId,
          hasWager: !!gameData.wager,
          isWageredMatchState: isWageredMatch
        });
        const isWagered = !!(gameData.wager && gameData.wager.escrowId);
        if (isWagered && roomId && functions) {
          console.log('[gameListener] Opponent disconnected in wagered match - claiming forfeit win');
          const forfeitGameFn = functions.httpsCallable('forfeitGame');
          forfeitGameFn({
            gameId: roomId,
            reason: 'disconnect',
            claimWin: true
          }).then(result => {
            console.log('[forfeitGame] Result:', result.data);
            if (result.data.success) {
              const payout = typeof result.data.winnerPayout === 'number' ? result.data.winnerPayout : 0;
              alert(`${sanitizeName(opponent.name)} has disconnected. You win ${payout} coins!`);
              if (payout > 0) {
                setCoinBalance(prev => prev + payout);
              }
            } else {
              alert(`${sanitizeName(opponent.name)} has disconnected. Returning to menu.`);
            }
            setCurrentEscrowId(null);
            setIsWageredMatch(false);
            setEscrowData(null);
          }).catch(err => {
            console.error('[forfeitGame] Error:', err);
            alert(`${sanitizeName(opponent.name)} has disconnected. Returning to menu.`);
          });
        } else {
          alert(`${sanitizeName(opponent.name)} has disconnected. Returning to menu.`);
        }
        cancelMatchmaking();
        return;
      }
      const validatedGameMode = gameData.gameMode === 301 || gameData.gameMode === 501 ? gameData.gameMode : 501;
      setPlayers([{
        uid: gameData.player1.id,
        name: sanitizeName(gameData.player1.name),
        flag: sanitizeFlag(gameData.player1.flag),
        score: validateScore(gameData.player1.score, validatedGameMode),
        level: sanitizeLevel(gameData.player1.level) || 1,
        avatarUrl: sanitizeAvatarUrl(gameData.player1.avatarUrl) || null,
        isAI: false
      }, {
        uid: gameData.player2.id,
        name: sanitizeName(gameData.player2.name),
        flag: sanitizeFlag(gameData.player2.flag),
        score: validateScore(gameData.player2.score, validatedGameMode),
        level: sanitizeLevel(gameData.player2.level) || 1,
        avatarUrl: sanitizeAvatarUrl(gameData.player2.avatarUrl) || null,
        isAI: false
      }]);
      if (gameData.wager?.escrowId && !escrowData) {
        database.ref(`escrow/${gameData.wager.escrowId}`).once('value', snap => {
          if (snap.exists()) {
            setEscrowData(snap.val());
          }
        });
      }
      setCurrentPlayerIndex(validatePlayerIndex(gameData.currentPlayer));
      setDartsThrown(validateDartsThrown(gameData.dartsThrown));
      setCurrentTurnScore(validateTurnScore(gameData.currentTurnScore));
      const throwsArray = gameData.throwHistory ? Object.values(gameData.throwHistory).map(validateThrowItem).filter(Boolean) : [];
      setThrowHistory(throwsArray);
      const dartsArray = gameData.dartPositions ? Object.values(gameData.dartPositions).map(validateDartPosition).filter(Boolean) : [];
      setDartPositions(dartsArray);
      setLegScores(validateScoreArray(gameData.legScores, 0));
      setSetScores(validateScoreArray(gameData.setScores, 0));
      if (gameData.winner !== undefined && gameData.status === 'finished') {
        const winnerIndex = validatePlayerIndex(gameData.winner);
        const isWinner = winnerIndex === playerIndex;
        const winnerPlayer = isWinner ? myPlayer : opponent;
        console.log('[gameListener] Game finished! Winner:', winnerIndex, 'isWinner:', isWinner);
        setWinner(winnerPlayer);
        setMatchWinner(winnerPlayer);
        if (isWinner) {
          playSound('win');
        }
        const hasWager = !!(gameData.wager && gameData.wager.escrowId);
        if (hasWager && roomId && functions) {
          console.log('[settleGame] Settling wagered match from listener:', roomId, 'escrowId:', gameData.wager.escrowId);
          const settleGameFn = functions.httpsCallable('settleGame');
          settleGameFn({
            gameId: roomId
          }).then(result => {
            console.log('[settleGame] Result:', result.data);
            const payout = typeof result.data.payout === 'number' ? result.data.payout : 0;
            if (result.data.success && payout > 0 && isWinner) {
              alert(`Congratulations! You won ${payout} coins!`);
              setCoinBalance(prev => prev + payout);
            }
            setCurrentEscrowId(null);
            setIsWageredMatch(false);
            setEscrowData(null);
          }).catch(err => {
            console.error('[settleGame] Error:', err);
          });
        }
      }
    }, error => {
      console.error('Game listener error:', error);
      alert('Connection to game lost. Returning to menu.');
      cancelMatchmaking();
    });
  }, [database, isWageredMatch, currentEscrowId, functions, gameRoomId, playSound]);
  const generateThrowId = useCallback(() => {
    return `t_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }, []);
  const syncThrowToFirebase = useCallback(async throwData => {
    if (!onlineMode || !gameRoomId) return null;
    if (!functions) {
      console.error('Cloud Functions not available - online mode requires server validation');
      alert('Online play is temporarily unavailable. Please try again later.');
      return null;
    }
    const payload = {
      gameId: gameRoomId,
      dartPosition: throwData.position
    };
    if (isWageredMatch && throwData.aimPoint && throwData.powerValue !== undefined) {
      payload.aimPoint = throwData.aimPoint;
      payload.powerValue = throwData.powerValue;
      payload.throwId = throwData.throwId || generateThrowId();
    }
    const maxRetries = 3;
    let lastError = null;
    for (let attempt = 0; attempt < maxRetries; attempt++) {
      try {
        console.log(`[syncThrow] Attempt ${attempt + 1}: Sending dart at`, throwData.position);
        const submitThrow = functions.httpsCallable('submitThrow');
        const result = await submitThrow(payload);
        if (!result.data.success) {
          console.error('[syncThrow] Throw rejected by server:', result.data.error);
          return null;
        }
        console.log('[syncThrow] Throw accepted:', result.data.label, result.data.score, 'pts', 'rhythm:', result.data.rhythm);
        return result.data;
      } catch (error) {
        lastError = error;
        console.error(`[syncThrow] Attempt ${attempt + 1} failed:`, error.message || error);
        if (error.code === 'functions/failed-precondition') {
          console.warn('[syncThrow] Server rejected: not your turn or game ended');
          return null;
        } else if (error.code === 'functions/permission-denied') {
          console.warn('[syncThrow] Server rejected: not a player in this game');
          return null;
        }
        if (attempt < maxRetries - 1) {
          await new Promise(r => setTimeout(r, 200 * (attempt + 1)));
        }
      }
    }
    console.error('[syncThrow] All retries failed:', lastError);
    alert('Failed to register throw. Please check your connection and try again.');
    return null;
  }, [onlineMode, gameRoomId, isWageredMatch, generateThrowId, functions]);
  const cancelMatchmaking = useCallback(() => {
    const capturedGameRoomRef = gameRoomRef.current;
    const capturedPlayerId = playerId;
    const capturedGameRoomId = gameRoomId;
    console.log('[cancelMatchmaking] Starting cleanup:', {
      hasGameRoom: !!capturedGameRoomRef,
      playerId: capturedPlayerId,
      gameRoomId: capturedGameRoomId,
      isWageredMatch
    });
    if (capturedGameRoomRef && capturedPlayerId !== null) {
      const myPlayerKey = capturedPlayerId === 0 ? 'player1' : 'player2';
      console.log(`[cancelMatchmaking] Sending disconnect notification: ${myPlayerKey}/connected = false`);
      capturedGameRoomRef.child(`${myPlayerKey}/connected`).set(false).then(() => console.log('[cancelMatchmaking] Disconnect notification sent successfully')).catch(err => console.error('[cancelMatchmaking] Failed to set disconnected:', err));
    } else {
      console.log('[cancelMatchmaking] Skipping disconnect notification - no active game or playerId is null');
    }
    if (matchmakingIntervalRef.current) {
      clearInterval(matchmakingIntervalRef.current);
      matchmakingIntervalRef.current = null;
    }
    if (wageredListenerRef.current) {
      wageredListenerRef.current.ref.off('value', wageredListenerRef.current.callback);
      if (wageredListenerRef.current.timeoutId) {
        clearTimeout(wageredListenerRef.current.timeoutId);
      }
      wageredListenerRef.current = null;
    }
    if (myAuthId && database) {
      database.ref('matchmaking_queue').child(myAuthId).remove();
      [50, 100, 500, 2500].forEach(stake => {
        database.ref(`matchmaking_queue/wagered/${stake}`).child(myAuthId).remove();
      });
    }
    if (currentEscrowId && !capturedGameRoomId && functions) {
      console.log('[cancelMatchmaking] Refunding escrow:', currentEscrowId);
      const refundEscrowFn = functions.httpsCallable('refundEscrow');
      refundEscrowFn({
        escrowId: currentEscrowId,
        reason: 'cancelled'
      }).then(result => {
        console.log('[cancelMatchmaking] Escrow refund result:', result.data);
        if (result.data.success && result.data.refundedAmounts && result.data.refundedAmounts.length > 0) {
          const totalRefunded = result.data.refundedAmounts.reduce((sum, amt) => sum + amt, 0);
          const ourRefund = result.data.refundedAmounts[0];
          if (ourRefund > 0) {
            setCoinBalance(prev => prev + ourRefund);
            console.log('[cancelMatchmaking] Coins refunded to balance:', ourRefund);
          }
        }
      }).catch(err => {
        console.error('[cancelMatchmaking] Escrow refund failed:', err);
      });
    }
    if (gameRoomRef.current) {
      gameRoomRef.current.off();
      gameRoomRef.current = null;
    }
    earlyDisconnectListenerRef.current = null;
    stopHeartbeat();
    opponentWasConnected.current = false;
    setMatchmakingState(null);
    setOnlineMode(false);
    setGameRoomId(null);
    setPlayerId(null);
    setMyAuthId(null);
    setCurrentEscrowId(null);
    setIsWageredMatch(false);
    setEscrowData(null);
    setShowLeaveConfirmation(false);
    setGameState('menu');
  }, [myAuthId, database, playerId, currentEscrowId, gameRoomId, functions, isWageredMatch]);
  const leaveOnlineGame = useCallback(() => {
    cancelMatchmaking();
  }, [cancelMatchmaking]);
  const handleLeaveClick = useCallback(() => {
    if (isWageredMatch && winner === null) {
      setShowLeaveConfirmation(true);
    } else {
      leaveOnlineGame();
    }
  }, [isWageredMatch, winner, leaveOnlineGame]);
  const calculateScore = useCallback((x, y) => {
    const dx = x - CENTER;
    const dy = y - CENTER;
    const distance = Math.sqrt(dx * dx + dy * dy);
    if (distance > DOUBLE_OUTER) return {
      score: 0,
      label: 'MISS',
      multiplier: 0
    };
    if (distance <= INNER_BULL) return {
      score: 50,
      label: 'BULL',
      multiplier: 1
    };
    if (distance <= OUTER_BULL) return {
      score: 25,
      label: '25',
      multiplier: 1
    };
    let angle = Math.atan2(dy, dx) * (180 / Math.PI) + 90;
    if (angle < 0) angle += 360;
    const segmentIndex = Math.floor((angle + 9) / 18) % 20;
    const baseScore = SEGMENTS[segmentIndex];
    if (distance >= DOUBLE_INNER && distance <= DOUBLE_OUTER) {
      return {
        score: baseScore * 2,
        label: `D${baseScore}`,
        multiplier: 2,
        base: baseScore
      };
    }
    if (distance >= TRIPLE_INNER && distance <= TRIPLE_OUTER) {
      return {
        score: baseScore * 3,
        label: `T${baseScore}`,
        multiplier: 3,
        base: baseScore
      };
    }
    return {
      score: baseScore,
      label: `${baseScore}`,
      multiplier: 1,
      base: baseScore
    };
  }, []);
  const addRandomness = useCallback((targetX, targetY, power, isInPerfectZone) => {
    if (isInPerfectZone) {
      return {
        x: targetX,
        y: targetY
      };
    }
    const skillFactor = (100 - skillLevel) / 100;
    const powerFactor = Math.abs(power - 50) / 50;
    const skillRandomness = skillFactor * 25;
    const powerRandomness = powerFactor * 20;
    const distanceFromPerfect = Math.abs(power - 50);
    const perfectZonePenalty = 80 + distanceFromPerfect * 1.2;
    const randomness = skillRandomness + powerRandomness + perfectZonePenalty;
    const angle = Math.random() * Math.PI * 2;
    const offset = Math.random() * randomness;
    return {
      x: targetX + Math.cos(angle) * offset,
      y: targetY + Math.sin(angle) * offset
    };
  }, [skillLevel]);
  const getAITarget = useCallback((difficulty, currentScore) => {
    const getSegmentPosition = (segmentValue, multiplier = 1) => {
      const segmentIndex = SEGMENTS.indexOf(segmentValue);
      const angle = (segmentIndex * 18 - 90) * (Math.PI / 180);
      let distance;
      if (multiplier === 3) distance = (TRIPLE_INNER + TRIPLE_OUTER) / 2;else if (multiplier === 2) distance = (DOUBLE_INNER + DOUBLE_OUTER) / 2;else distance = (TRIPLE_OUTER + DOUBLE_INNER) / 2;
      return {
        x: CENTER + distance * Math.cos(angle),
        y: CENTER + distance * Math.sin(angle)
      };
    };
    const parseDartNotation = notation => {
      if (notation === 'Bull') {
        return {
          x: CENTER,
          y: CENTER
        };
      }
      const prefix = notation[0];
      const segment = parseInt(notation.slice(1));
      let multiplier = 1;
      if (prefix === 'T') multiplier = 3;else if (prefix === 'D') multiplier = 2;
      return getSegmentPosition(segment, multiplier);
    };
    if (CHECKOUT_SUGGESTIONS[currentScore] && (difficulty === AI_DIFFICULTIES.EXPERT.key || difficulty === AI_DIFFICULTIES.IMPOSSIBLE.key)) {
      const suggestion = CHECKOUT_SUGGESTIONS[currentScore];
      const firstTarget = suggestion.split(' ')[0];
      return parseDartNotation(firstTarget);
    }
    switch (difficulty) {
      case AI_DIFFICULTIES.BEGINNER.key:
        const randomSegment = SEGMENTS[Math.floor(Math.random() * SEGMENTS.length)];
        return getSegmentPosition(randomSegment, 1);
      case AI_DIFFICULTIES.INTERMEDIATE.key:
        const targetSegment = Math.random() > 0.5 ? 20 : 19;
        const useTriple = Math.random() > 0.6;
        return getSegmentPosition(targetSegment, useTriple ? 3 : 1);
      case AI_DIFFICULTIES.EXPERT.key:
        if (currentScore <= 40 && currentScore % 2 === 0) {
          return getSegmentPosition(currentScore / 2, 2);
        }
        return getSegmentPosition(20, 3);
      case AI_DIFFICULTIES.IMPOSSIBLE.key:
        return getSegmentPosition(20, 3);
      default:
        return {
          x: CENTER,
          y: CENTER
        };
    }
  }, []);
  const getAIAccuracy = difficulty => {
    const difficultyConfig = Object.values(AI_DIFFICULTIES).find(d => d.key === difficulty);
    return difficultyConfig ? difficultyConfig.accuracy : 50;
  };
  const unlockAchievement = useCallback(achievementId => {
    if (unlockedAchievements.includes(achievementId)) return;
    const achievement = ACHIEVEMENTS_DATA.find(a => a.id === achievementId);
    if (!achievement) return;
    const newUnlocked = [...unlockedAchievements, achievementId];
    setUnlockedAchievements(newUnlocked);
    try {
      localStorage.setItem('quikdarts_achievements', JSON.stringify(newUnlocked));
    } catch (error) {
      console.error('Failed to save achievements to localStorage:', error);
    }
    setAchievementPopup(achievement);
    setTimeout(() => setAchievementPopup(null), 4000);
  }, [unlockedAchievements]);
  const checkAchievements = useCallback(stats => {
    if (stats.totalGamesPlayed >= 1) {
      unlockAchievement('first_game');
    }
    if (stats.totalGamesWon >= 1) {
      unlockAchievement('first_win');
    }
    if (stats.total180s >= 1) {
      unlockAchievement('first_180');
    }
    if (stats.total180s >= 10) {
      unlockAchievement('ten_180s');
    }
    if (stats.total180s >= 50) {
      unlockAchievement('fifty_180s');
    }
    if (stats.totalBulls >= 1) {
      unlockAchievement('first_bull');
    }
    if (stats.totalBulls >= 50) {
      unlockAchievement('fifty_bulls');
    }
    if (stats.totalBulls >= 100) {
      unlockAchievement('hundred_bulls');
    }
    if (stats.totalGamesWon >= 5) {
      unlockAchievement('five_wins');
    }
    if (stats.totalGamesWon >= 20) {
      unlockAchievement('twenty_wins');
    }
    if (stats.totalGamesWon >= 50) {
      unlockAchievement('fifty_wins');
    }
    if (stats.totalOnlineGames >= 1) {
      unlockAchievement('first_online');
    }
    if (stats.totalOnlineWins >= 1) {
      unlockAchievement('first_online_win');
    }
    if (stats.totalOnlineWins >= 10) {
      unlockAchievement('ten_online_wins');
    }
    if (stats.totalOnlineWins >= 50) {
      unlockAchievement('fifty_online_wins');
    }
    if (stats.highestCheckout >= 100) {
      unlockAchievement('big_checkout');
    }
    if (stats.highestCheckout >= 150) {
      unlockAchievement('huge_checkout');
    }
    if (stats.totalTriples >= 50) {
      unlockAchievement('fifty_triples');
    }
    if (stats.totalTriples >= 200) {
      unlockAchievement('two_hundred_triples');
    }
    if (stats.totalNineDarters >= 1) {
      unlockAchievement('perfect9_first');
    }
    if (stats.totalNineDarters >= 10) {
      unlockAchievement('perfect9_ten');
    }
    if (stats.totalNineDarters >= 100) {
      unlockAchievement('perfect9_hundred');
    }
  }, [unlockAchievement]);
  const updateAchievementStats = useCallback(update => {
    setAchievementStats(prev => {
      const newStats = {
        ...prev,
        ...update
      };
      try {
        localStorage.setItem('quikdarts_stats', JSON.stringify(newStats));
      } catch (error) {
        console.error('Failed to save achievement stats to localStorage:', error);
      }
      checkAchievements(newStats);
      return newStats;
    });
  }, [checkAchievements]);
  const updateWeeklyChallengeStats = useCallback(update => {
    setWeeklyChallenge(prev => {
      const currentWeek = getCurrentWeekNumber();
      if (prev.weekNumber !== currentWeek) {
        const activeChallenge = getActiveTimeLimitedAchievement();
        const newData = {
          weekNumber: currentWeek,
          challengeId: activeChallenge?.id,
          stats: {
            ...update
          },
          completed: false,
          completedChallenges: prev.completedChallenges || []
        };
        try {
          localStorage.setItem('quikdarts_weekly_challenge', JSON.stringify(newData));
        } catch (error) {
          console.error('Failed to save weekly challenge:', error);
        }
        return newData;
      }
      const newStats = {
        ...prev.stats
      };
      Object.keys(update).forEach(key => {
        newStats[key] = (newStats[key] || 0) + (update[key] || 0);
      });
      const activeChallenge = getActiveTimeLimitedAchievement();
      let completed = prev.completed;
      let completedChallenges = [...(prev.completedChallenges || [])];
      if (activeChallenge && !completed) {
        const current = newStats[activeChallenge.statKey] || 0;
        if (current >= activeChallenge.target) {
          completed = true;
          if (!completedChallenges.includes(activeChallenge.id)) {
            completedChallenges.push(activeChallenge.id);
          }
        }
      }
      const newData = {
        ...prev,
        stats: newStats,
        completed,
        completedChallenges
      };
      try {
        localStorage.setItem('quikdarts_weekly_challenge', JSON.stringify(newData));
      } catch (error) {
        console.error('Failed to save weekly challenge:', error);
      }
      return newData;
    });
  }, []);
  const updateDailyChallengeStats = useCallback(update => {
    setDailyChallengeData(prev => {
      const today = getTodayString();
      if (prev.date !== today) {
        const newData = createDefaultDailyChallengeData(today);
        Object.keys(update).forEach(key => {
          newData.stats[key] = (newData.stats[key] || 0) + (update[key] || 0);
        });
        try {
          localStorage.setItem('quikdarts_daily_challenges', JSON.stringify(newData));
        } catch (error) {
          console.error('Failed to save daily challenges:', error);
        }
        return newData;
      }
      const newStats = {
        ...prev.stats
      };
      Object.keys(update).forEach(key => {
        newStats[key] = (newStats[key] || 0) + (update[key] || 0);
      });
      const newCompleted = [...prev.completedChallenges];
      prev.challenges.forEach(challenge => {
        if (!newCompleted.includes(challenge.id)) {
          const current = newStats[challenge.statKey] || 0;
          if (current >= challenge.target) {
            newCompleted.push(challenge.id);
          }
        }
      });
      const newData = {
        ...prev,
        stats: newStats,
        completedChallenges: newCompleted
      };
      try {
        localStorage.setItem('quikdarts_daily_challenges', JSON.stringify(newData));
      } catch (error) {
        console.error('Failed to save daily challenges:', error);
      }
      return newData;
    });
  }, []);
  const handleLegWin = useCallback((playerIndex, dartsInLeg = null) => {
    const playerDartsInLeg = dartsInLeg !== null ? dartsInLeg : legDartsThrown[playerIndex] || 0;
    if (playerSetup.gameMode === 501 && playerDartsInLeg === 9) {
      setShowNineDarter(true);
      playSound('ninedarter');
      setTimeout(() => setShowNineDarter(false), 6000);
      if (!players[playerIndex].isAI) {
        if (onlineMode) {
          unlockAchievement('nine_darter_online');
        } else if (!practiceMode && hasAIOpponent) {
          unlockAchievement('nine_darter_offline');
          updateAchievementStats({
            totalNineDarters: achievementStats.totalNineDarters + 1
          });
        }
      }
    }
    if (playerSetup.gameMode !== 501 || playerDartsInLeg !== 9) {
      playSound('win');
    }
    const newLegScores = [...legScores];
    newLegScores[playerIndex] = (newLegScores[playerIndex] || 0) + 1;
    setLegScores(newLegScores);
    if (newLegScores[playerIndex] >= playerSetup.legsPerSet) {
      const newSetScores = [...setScores];
      newSetScores[playerIndex] = (newSetScores[playerIndex] || 0) + 1;
      setSetScores(newSetScores);
      if (newSetScores[playerIndex] >= playerSetup.setsToWin) {
        setMatchWinner(players[playerIndex]);
        setWinner(players[playerIndex]);
        if (onlineMode && gameRoomRef.current) {
          if (isWageredMatch && currentEscrowId && functions && gameRoomId) {
            console.log('[settleGame] Settling wagered match:', gameRoomId);
            const settleGameFn = functions.httpsCallable('settleGame');
            settleGameFn({
              gameId: gameRoomId
            }).then(result => {
              console.log('[settleGame] Result:', result.data);
              const payout = typeof result.data.payout === 'number' ? result.data.payout : 0;
              if (result.data.success && payout > 0) {
                const isWinner = playerIndex === myPlayerIndex;
                if (isWinner) {
                  alert(`Congratulations! You won ${payout} coins!`);
                }
              }
              setCurrentEscrowId(null);
              setIsWageredMatch(false);
              setEscrowData(null);
            }).catch(err => {
              console.error('[settleGame] Error:', err);
            });
          }
        }
        if (!players[playerIndex].isAI && !practiceMode) {
          if (onlineMode) {
            updateAchievementStats({
              totalOnlineGames: achievementStats.totalOnlineGames + 1,
              totalOnlineWins: achievementStats.totalOnlineWins + 1
            });
          } else if (hasAIOpponent) {
            updateAchievementStats({
              totalGamesPlayed: achievementStats.totalGamesPlayed + 1,
              totalGamesWon: achievementStats.totalGamesWon + 1
            });
            updateWeeklyChallengeStats({
              weeklyWins: 1
            });
            updateDailyChallengeStats({
              dailyWins: 1,
              dailyGames: 1
            });
          }
        } else if (!practiceMode) {
          if (onlineMode) {
            updateAchievementStats({
              totalOnlineGames: achievementStats.totalOnlineGames + 1
            });
          } else if (hasAIOpponent) {
            updateAchievementStats({
              totalGamesPlayed: achievementStats.totalGamesPlayed + 1
            });
            updateDailyChallengeStats({
              dailyGames: 1
            });
          }
        }
        return;
      }
      setLegScores(new Array(players.length).fill(0));
    }
    setTimeout(() => {
      const newPlayers = players.map(p => ({
        ...p,
        score: playerSetup.gameMode
      }));
      setPlayers(newPlayers);
      setDartsThrown(0);
      setCurrentTurnScore(0);
      setDartPositions([]);
      setTriplesHit(0);
      setThrowHistory([]);
      setWinner(null);
      setLegDartsThrown(new Array(players.length).fill(0));
    }, 2000);
  }, [legScores, setScores, players, playerSetup, playSound, legDartsThrown, unlockAchievement, updateAchievementStats, achievementStats, onlineMode, practiceMode, updateWeeklyChallengeStats]);
  const updateStats = useCallback((playerIndex, result) => {
    setGameStats(prev => {
      const playerStats = prev[playerIndex] || {
        throws: 0,
        totalScore: 0,
        doubles: 0,
        triples: 0,
        bullseyes: 0,
        misses: 0,
        highestThrow: 0,
        averagePerSet: 0
      };
      const newThrows = playerStats.throws + 1;
      const newTotal = playerStats.totalScore + result.score;
      return {
        ...prev,
        [playerIndex]: {
          throws: newThrows,
          totalScore: newTotal,
          doubles: playerStats.doubles + (result.multiplier === 2 ? 1 : 0),
          triples: playerStats.triples + (result.multiplier === 3 ? 1 : 0),
          bullseyes: playerStats.bullseyes + (result.score === 50 ? 1 : 0),
          misses: playerStats.misses + (result.score === 0 ? 1 : 0),
          highestThrow: Math.max(playerStats.highestThrow, result.score),
          averagePerSet: (newTotal / newThrows * 3).toFixed(1)
        }
      };
    });
  }, []);
  const nextPlayer = useCallback(busted => {
    if (busted) {
      const newPlayers = [...players];
      newPlayers[currentPlayerIndex] = {
        ...players[currentPlayerIndex],
        score: players[currentPlayerIndex].score + currentTurnScore
      };
      setPlayers(newPlayers);
    }
    setDartsThrown(0);
    setCurrentTurnScore(0);
    setDartPositions([]);
    setTriplesHit(0);
    setCurrentTurnThrows([]);
    setAimWobble({
      x: 0,
      y: 0
    });
    setCurrentPlayerIndex((currentPlayerIndex + 1) % players.length);
  }, [currentPlayerIndex, players, currentTurnScore]);
  const throwDart = useCallback(() => {
    if (practiceMode === 'active') {
      playSound('throw');
      const effectiveAimX = aimPositionRef.current.x + aimWobble.x;
      const effectiveAimY = aimPositionRef.current.y + aimWobble.y;
      const currentSkill = practiceSkillLevel;
      let perfectZoneWidth;
      if (currentSkill <= 40) {
        perfectZoneWidth = 10;
      } else {
        const baseZoneWidth = 10;
        const shrinkRate = currentSkill >= 81 ? 3 : 2.5;
        perfectZoneWidth = Math.max(baseZoneWidth - triplesHit * shrinkRate, 4);
      }
      const perfectZoneLeft = 50 - perfectZoneWidth / 2;
      const perfectZoneRight = 50 + perfectZoneWidth / 2;
      const isInPerfectZone = power > perfectZoneLeft && power < perfectZoneRight;
      const finalPosition = addRandomness(effectiveAimX, effectiveAimY, power, isInPerfectZone);
      const result = calculateScore(finalPosition.x, finalPosition.y);
      if (isInPerfectZone) {
        setTriplesHit(prev => prev + 1);
      }
      setAnimatingDart({
        start: {
          x: CENTER,
          y: BOARD_SIZE + 50
        },
        end: finalPosition
      });
      setTimeout(() => {
        setAnimatingDart(null);
        setDartPositions(prev => [...prev, finalPosition]);
        setPracticeStats(prev => {
          const newStats = {
            ...prev
          };
          newStats.dartsThrown += 1;
          newStats.totalScore += result.score;
          if (result.score === 50) {
            newStats.bulls += 1;
            playSound('bullseye');
          } else if (result.score === 25) {
            newStats.singleBull += 1;
            playSound('hit');
          } else if (result.multiplier === 3) {
            newStats.triples += 1;
            if (result.label === 'T20') newStats.t20 += 1;
            if (result.label === 'T19') newStats.t19 += 1;
            if (result.label === 'T18') newStats.t18 += 1;
            playSound('hit');
          } else if (result.multiplier === 2) {
            newStats.doubles += 1;
            playSound('hit');
          } else if (result.score > 0) {
            playSound('hit');
          }
          return newStats;
        });
        setShowScorePopup({
          ...result,
          position: finalPosition
        });
        setTimeout(() => setShowScorePopup(null), 1000);
        if (dartPositions.length + 1 >= 3) {
          setTimeout(() => {
            setDartPositions([]);
            setTriplesHit(0);
            setCurrentTurnThrows([]);
            setAimWobble({
              x: 0,
              y: 0
            });
          }, 1000);
        }
      }, 300);
      return;
    }
    if (dartsThrown >= 3 || winner) return;
    if (onlineMode && currentPlayerIndex !== playerId) {
      return;
    }
    playSound('throw');
    const effectiveAimX = aimPositionRef.current.x + aimWobble.x;
    const effectiveAimY = aimPositionRef.current.y + aimWobble.y;
    const currentPlayer = players[currentPlayerIndex];
    const aimingAt = calculateScore(effectiveAimX, effectiveAimY);
    const isAimingAtWinningDouble = isCheckoutPosition && aimingAt.multiplier === 2 && aimingAt.score === currentPlayer.score;
    let perfectZoneWidth;
    if (skillLevel <= 40) {
      perfectZoneWidth = 10;
    } else {
      if (isAimingAtWinningDouble) {
        perfectZoneWidth = 2;
      } else {
        const baseZoneWidth = 10;
        const shrinkRate = onlineMode || skillLevel >= 81 ? 3 : 2.5;
        perfectZoneWidth = Math.max(baseZoneWidth - triplesHit * shrinkRate, 4);
      }
    }
    const perfectZoneLeft = 50 - perfectZoneWidth / 2;
    const perfectZoneRight = 50 + perfectZoneWidth / 2;
    const isInPerfectZone = power > perfectZoneLeft && power < perfectZoneRight;
    const finalPosition = addRandomness(effectiveAimX, effectiveAimY, power, isInPerfectZone);
    const result = calculateScore(finalPosition.x, finalPosition.y);
    if (isInPerfectZone) {
      setTriplesHit(prev => prev + 1);
    }
    setAnimatingDart({
      start: {
        x: CENTER,
        y: BOARD_SIZE + 50
      },
      end: finalPosition
    });
    setTimeout(() => {
      setAnimatingDart(null);
      setDartPositions(prev => [...prev, finalPosition]);
      const currentPlayer = players[currentPlayerIndex];
      const newScore = currentPlayer.score - result.score;
      setCurrentTurnThrows(prev => [...prev, {
        score: result.score,
        multiplier: result.multiplier
      }]);
      const newTurnScore = currentTurnScore + result.score;
      const is180 = newTurnScore === 180 && dartsThrown + 1 === 3;
      if (is180) {
        playSound('180');
        setShowScorePopup({
          score: 180,
          label: '180!!!',
          position: finalPosition
        });
        setTimeout(() => setShowScorePopup(null), 2000);
        if (!onlineMode && !practiceMode && hasAIOpponent) {
          updateAchievementStats({
            total180s: achievementStats.total180s + 1
          });
          updateWeeklyChallengeStats({
            weekly180s: 1
          });
          updateDailyChallengeStats({
            daily180s: 1
          });
        }
      } else {
        if (result.score === 50) {
          playSound('bullseye');
          if (!onlineMode && !practiceMode && hasAIOpponent) {
            updateAchievementStats({
              totalBulls: achievementStats.totalBulls + 1
            });
            updateWeeklyChallengeStats({
              weeklyBulls: 1
            });
            updateDailyChallengeStats({
              dailyBulls: 1
            });
          }
        } else if (result.score > 0) {
          playSound('hit');
        }
        if (result.multiplier === 3 && !onlineMode && !practiceMode && hasAIOpponent) {
          updateAchievementStats({
            totalTriples: achievementStats.totalTriples + 1
          });
          updateWeeklyChallengeStats({
            weeklyTriples: 1
          });
          updateDailyChallengeStats({
            dailyTriples: 1
          });
        }
        setShowScorePopup({
          ...result,
          position: finalPosition
        });
        setTimeout(() => setShowScorePopup(null), 1000);
      }
      if (!onlineMode && !practiceMode && hasAIOpponent && result.score > 0) {
        updateDailyChallengeStats({
          dailyScore: result.score
        });
      }
      if (newScore < 0 || newScore === 1 || newScore === 0 && result.multiplier !== 2) {
        playSound('bust');
        setShowScorePopup({
          score: 'BUST!',
          label: 'BUST!',
          position: finalPosition
        });
        setTimeout(() => {
          setShowScorePopup(null);
          nextPlayer(true);
        }, 1500);
        return;
      }
      if (newScore === 0 && result.multiplier === 2) {
        if (onlineMode) {
          console.log('[checkout] Online mode - syncing checkout throw to server');
          if (isWageredMatch) {
            setScoreConfirming(true);
          }
          const throwPayload = {
            player: currentPlayerIndex,
            score: result.score,
            multiplier: result.multiplier,
            label: result.label,
            newScore: 0,
            remaining: 0,
            dartsThrown: dartsThrown + 1,
            currentTurnScore: currentTurnScore + result.score,
            currentPlayer: currentPlayerIndex,
            position: finalPosition,
            aimPoint: isWageredMatch ? {
              x: effectiveAimX,
              y: effectiveAimY
            } : undefined,
            powerValue: isWageredMatch ? power : undefined
          };
          syncThrowToFirebase(throwPayload).then(serverResult => {
            setScoreConfirming(false);
            if (serverResult && serverResult.rhythm) {
              setRhythmState(serverResult.rhythm);
            }
          }).catch(() => {
            setScoreConfirming(false);
          });
          return;
        }
        const newPlayers = [...players];
        newPlayers[currentPlayerIndex] = {
          ...currentPlayer,
          score: 0
        };
        setPlayers(newPlayers);
        updateStats(currentPlayerIndex, result);
        const checkoutValue = currentPlayer.score;
        if (!players[currentPlayerIndex].isAI && !practiceMode && hasAIOpponent) {
          if (checkoutValue > (achievementStats.highestCheckout || 0)) {
            updateAchievementStats({
              highestCheckout: checkoutValue
            });
          }
        }
        const finalDartCount = (legDartsThrown[currentPlayerIndex] || 0) + 1;
        setLegDartsThrown(prev => {
          const newLegDarts = [...prev];
          newLegDarts[currentPlayerIndex] = finalDartCount;
          return newLegDarts;
        });
        setWinner(currentPlayer);
        handleLegWin(currentPlayerIndex, finalDartCount);
        return;
      }
      const newCurrentTurnScore = currentTurnScore + result.score;
      const newDartsThrown = dartsThrown + 1;
      const nextPlayerIndex = newDartsThrown >= 3 ? (currentPlayerIndex + 1) % players.length : currentPlayerIndex;
      if (onlineMode) {
        const throwPayload = {
          player: currentPlayerIndex,
          score: result.score,
          multiplier: result.multiplier,
          label: result.label,
          newScore: newScore,
          remaining: newScore,
          dartsThrown: newDartsThrown,
          currentTurnScore: newCurrentTurnScore,
          currentPlayer: nextPlayerIndex,
          position: finalPosition,
          aimPoint: isWageredMatch ? {
            x: effectiveAimX,
            y: effectiveAimY
          } : undefined,
          powerValue: isWageredMatch ? power : undefined
        };
        if (isWageredMatch) {
          setScoreConfirming(true);
          syncThrowToFirebase(throwPayload).then(serverResult => {
            setScoreConfirming(false);
            if (serverResult) {
              if (serverResult.rhythm) {
                setRhythmState(serverResult.rhythm);
              }
              if (serverResult.positionAdjusted && serverResult.adjustedPosition) {
                setPendingDartCorrection({
                  from: finalPosition,
                  to: serverResult.adjustedPosition
                });
                setTimeout(() => setPendingDartCorrection(null), 500);
              }
            }
          }).catch(() => {
            setScoreConfirming(false);
          });
        } else {
          syncThrowToFirebase(throwPayload);
        }
        if (newDartsThrown >= 3) {
          setTimeout(() => {
            setCurrentTurnThrows([]);
            setTriplesHit(0);
            setAimWobble({
              x: 0,
              y: 0
            });
            setRhythmState('neutral');
          }, 1000);
        }
      } else {
        const newPlayers = [...players];
        newPlayers[currentPlayerIndex] = {
          ...currentPlayer,
          score: newScore
        };
        setPlayers(newPlayers);
        setCurrentTurnScore(newCurrentTurnScore);
        setThrowHistory(prev => [...prev, {
          player: currentPlayerIndex,
          ...result,
          remaining: newScore
        }]);
        setDartsThrown(newDartsThrown);
        setLegDartsThrown(prev => {
          const newLegDarts = [...prev];
          newLegDarts[currentPlayerIndex] = (newLegDarts[currentPlayerIndex] || 0) + 1;
          return newLegDarts;
        });
        updateStats(currentPlayerIndex, result);
        if (newDartsThrown >= 3) {
          setTimeout(() => nextPlayer(false), 1000);
        }
      }
    }, 300);
  }, [aimWobble, power, dartsThrown, players, currentPlayerIndex, winner, calculateScore, addRandomness, playSound, isCheckoutPosition, triplesHit, handleLegWin, updateStats, nextPlayer, onlineMode, playerId, syncThrowToFirebase, currentTurnScore, practiceMode, practiceSkillLevel, dartPositions, updateAchievementStats, achievementStats, updateWeeklyChallengeStats, isWageredMatch]);
  const handleMouseMove = useCallback(e => {
    if (!boardRef.current || isPowerCharging) return;
    const rect = boardRef.current.getBoundingClientRect();
    const x = (e.clientX - rect.left) / rect.width * BOARD_SIZE;
    const y = (e.clientY - rect.top) / rect.height * BOARD_SIZE;
    aimPositionRef.current = {
      x,
      y
    };
    setAimPosition({
      x,
      y
    });
  }, [isPowerCharging]);
  const handleMouseDown = useCallback(e => {
    const currentPlayer = players[currentPlayerIndex];
    if (dartsThrown >= 3 || winner || animatingDart || currentPlayer && currentPlayer.isAI) return;
    e.preventDefault();
    if (powerIntervalRef.current) {
      clearInterval(powerIntervalRef.current);
      powerIntervalRef.current = null;
    }
    if (powerResetTimeoutRef.current) {
      clearTimeout(powerResetTimeoutRef.current);
      powerResetTimeoutRef.current = null;
    }
    setIsPowerCharging(true);
    setPower(0);
    let increasing = true;
    let currentPower = 0;
    powerIntervalRef.current = setInterval(() => {
      if (increasing) {
        currentPower += 2;
        if (currentPower >= 100) increasing = false;
      } else {
        currentPower -= 2;
        if (currentPower <= 0) increasing = true;
      }
      setPower(currentPower);
    }, 20);
  }, [dartsThrown, winner, animatingDart, players, currentPlayerIndex]);
  const handleMouseUp = useCallback(() => {
    if (powerIntervalRef.current) {
      clearInterval(powerIntervalRef.current);
      powerIntervalRef.current = null;
    }
    if (isPowerCharging) {
      setIsPowerCharging(false);
      throwDart();
      powerResetTimeoutRef.current = setTimeout(() => {
        setPower(0);
        powerResetTimeoutRef.current = null;
      }, 500);
    }
  }, [isPowerCharging, throwDart]);
  const handleTouchMove = useCallback(e => {
    if (!boardRef.current || isPowerCharging) return;
    e.preventDefault();
    const touch = e.touches[0];
    const rect = boardRef.current.getBoundingClientRect();
    const x = (touch.clientX - rect.left) / rect.width * BOARD_SIZE;
    const y = (touch.clientY - rect.top) / rect.height * BOARD_SIZE;
    aimPositionRef.current = {
      x,
      y
    };
    setAimPosition({
      x,
      y
    });
  }, [isPowerCharging]);
  const handleTouchStart = useCallback(e => {
    const currentPlayer = players[currentPlayerIndex];
    if (dartsThrown >= 3 || winner || animatingDart || currentPlayer && currentPlayer.isAI) return;
    e.preventDefault();
    if (powerIntervalRef.current) {
      clearInterval(powerIntervalRef.current);
      powerIntervalRef.current = null;
    }
    if (powerResetTimeoutRef.current) {
      clearTimeout(powerResetTimeoutRef.current);
      powerResetTimeoutRef.current = null;
    }
    const touch = e.touches[0];
    const rect = boardRef.current.getBoundingClientRect();
    const x = (touch.clientX - rect.left) / rect.width * BOARD_SIZE;
    const y = (touch.clientY - rect.top) / rect.height * BOARD_SIZE;
    aimPositionRef.current = {
      x,
      y
    };
    setAimPosition({
      x,
      y
    });
    setIsPowerCharging(true);
    setPower(0);
    let increasing = true;
    let currentPower = 0;
    powerIntervalRef.current = setInterval(() => {
      if (increasing) {
        currentPower += 2;
        if (currentPower >= 100) increasing = false;
      } else {
        currentPower -= 2;
        if (currentPower <= 0) increasing = true;
      }
      setPower(currentPower);
    }, 20);
  }, [dartsThrown, winner, animatingDart, players, currentPlayerIndex]);
  const handleTouchEnd = useCallback(e => {
    e.preventDefault();
    if (powerIntervalRef.current) {
      clearInterval(powerIntervalRef.current);
      powerIntervalRef.current = null;
    }
    if (isPowerCharging) {
      setIsPowerCharging(false);
      throwDart();
      powerResetTimeoutRef.current = setTimeout(() => {
        setPower(0);
        powerResetTimeoutRef.current = null;
      }, 500);
    }
  }, [isPowerCharging, throwDart]);
  const handleTouchCancel = useCallback(e => {
    e.preventDefault();
    if (powerIntervalRef.current) {
      clearInterval(powerIntervalRef.current);
      powerIntervalRef.current = null;
    }
    if (isPowerCharging) {
      setIsPowerCharging(false);
      setPower(0);
    }
  }, [isPowerCharging]);
  useEffect(() => {
    return () => {
      if (powerIntervalRef.current) clearInterval(powerIntervalRef.current);
      if (powerResetTimeoutRef.current) clearTimeout(powerResetTimeoutRef.current);
      if (matchmakingIntervalRef.current) clearInterval(matchmakingIntervalRef.current);
    };
  }, []);
  useEffect(() => {
    const currentPlayer = players[currentPlayerIndex];
    if (currentPlayer && CHECKOUT_SUGGESTIONS[currentPlayer.score]) {
      setCheckout(CHECKOUT_SUGGESTIONS[currentPlayer.score]);
      setIsCheckoutPosition(true);
    } else {
      setCheckout(null);
      if (currentPlayer && currentPlayer.score >= 2 && currentPlayer.score <= 40 && currentPlayer.score % 2 === 0) {
        setIsCheckoutPosition(true);
      } else {
        setIsCheckoutPosition(false);
      }
    }
  }, [players, currentPlayerIndex]);
  useEffect(() => {
    const currentPlayer = players[currentPlayerIndex];
    if (!currentPlayer || currentPlayer.isAI) return;
    const twoT20sHit = currentTurnThrows.length === 2 && currentTurnThrows[0].score === 20 && currentTurnThrows[0].multiplier === 3 && currentTurnThrows[1].score === 20 && currentTurnThrows[1].multiplier === 3;
    const wobbleFor180 = skillLevel >= 81 && twoT20sHit && dartsThrown === 2;
    const aimingAt = calculateScore(aimPosition.x, aimPosition.y);
    const isAimingAtWinningDouble = isCheckoutPosition && aimingAt.multiplier === 2 && aimingAt.score === currentPlayer.score;
    const wobbleForWinningDart = skillLevel >= 41 && isAimingAtWinningDouble && !isPowerCharging;
    if (wobbleFor180 || wobbleForWinningDart) {
      const wobbleInterval = setInterval(() => {
        const wobbleAmount = 8;
        setAimWobble({
          x: (Math.random() - 0.5) * wobbleAmount,
          y: (Math.random() - 0.5) * wobbleAmount
        });
      }, 50);
      return () => clearInterval(wobbleInterval);
    } else {
      setAimWobble({
        x: 0,
        y: 0
      });
    }
  }, [skillLevel, currentTurnThrows, dartsThrown, isPowerCharging, players, currentPlayerIndex, aimPosition, isCheckoutPosition, calculateScore]);
  useEffect(() => {
    return () => {
      if (gameRoomRef.current) {
        gameRoomRef.current.off();
      }
      if (myAuthId && database && onlineMode) {
        database.ref('matchmaking_queue').child(myAuthId).remove();
      }
    };
  }, [onlineMode, myAuthId, database]);
  useEffect(() => {
    const currentPlayer = players[currentPlayerIndex];
    if (currentPlayer && currentPlayer.isAI && gameState === 'playing' && !winner && !animatingDart && dartsThrown < 3) {
      const aiThrowDelay = setTimeout(() => {
        const target = getAITarget(currentPlayer.aiDifficulty, currentPlayer.score);
        const aiAccuracy = getAIAccuracy(currentPlayer.aiDifficulty);
        playSound('throw');
        let finalPosition;
        const hitChance = aiAccuracy / 100;
        const isAccurateThrow = Math.random() < hitChance;
        if (isAccurateThrow) {
          const minorDeviation = (100 - aiAccuracy) * 0.3;
          const angle = Math.random() * Math.PI * 2;
          const offset = Math.random() * minorDeviation;
          finalPosition = {
            x: target.x + Math.cos(angle) * offset,
            y: target.y + Math.sin(angle) * offset
          };
        } else {
          const skillFactor = (100 - aiAccuracy) / 100;
          const randomness = 30 + skillFactor * 50;
          const angle = Math.random() * Math.PI * 2;
          const offset = Math.random() * randomness;
          finalPosition = {
            x: target.x + Math.cos(angle) * offset,
            y: target.y + Math.sin(angle) * offset
          };
        }
        const result = calculateScore(finalPosition.x, finalPosition.y);
        setAnimatingDart({
          start: {
            x: CENTER,
            y: BOARD_SIZE + 50
          },
          end: finalPosition
        });
        setTimeout(() => {
          setAnimatingDart(null);
          setDartPositions(prev => [...prev, finalPosition]);
          const newScore = currentPlayer.score - result.score;
          const newTurnScore = currentTurnScore + result.score;
          const is180 = newTurnScore === 180 && dartsThrown + 1 === 3;
          if (is180) {
            playSound('180');
            setShowScorePopup({
              score: 180,
              label: '180!!!',
              position: finalPosition
            });
            setTimeout(() => setShowScorePopup(null), 2000);
          } else {
            if (result.score === 50) playSound('bullseye');else if (result.score > 0) playSound('hit');
            setShowScorePopup({
              ...result,
              position: finalPosition
            });
            setTimeout(() => setShowScorePopup(null), 1000);
          }
          if (newScore < 0 || newScore === 1 || newScore === 0 && result.multiplier !== 2) {
            playSound('bust');
            setShowScorePopup({
              score: 'BUST!',
              label: 'BUST!',
              position: finalPosition
            });
            setDartsThrown(3);
            setTimeout(() => {
              setShowScorePopup(null);
              nextPlayer(true);
            }, 1500);
            return;
          }
          if (newScore === 0 && result.multiplier === 2) {
            const newPlayers = [...players];
            newPlayers[currentPlayerIndex] = {
              ...currentPlayer,
              score: 0
            };
            setPlayers(newPlayers);
            updateStats(currentPlayerIndex, result);
            const finalDartCount = (legDartsThrown[currentPlayerIndex] || 0) + 1;
            setLegDartsThrown(prev => {
              const newLegDarts = [...prev];
              newLegDarts[currentPlayerIndex] = finalDartCount;
              return newLegDarts;
            });
            setWinner(currentPlayer);
            handleLegWin(currentPlayerIndex, finalDartCount);
            return;
          }
          const newPlayers = [...players];
          newPlayers[currentPlayerIndex] = {
            ...currentPlayer,
            score: newScore
          };
          setPlayers(newPlayers);
          setCurrentTurnScore(prev => prev + result.score);
          setThrowHistory(prev => [...prev, {
            player: currentPlayerIndex,
            ...result,
            remaining: newScore
          }]);
          setDartsThrown(prev => prev + 1);
          setLegDartsThrown(prev => {
            const newLegDarts = [...prev];
            newLegDarts[currentPlayerIndex] = (newLegDarts[currentPlayerIndex] || 0) + 1;
            return newLegDarts;
          });
          updateStats(currentPlayerIndex, result);
          if (dartsThrown + 1 >= 3) {
            setTimeout(() => nextPlayer(false), 1000);
          }
        }, 300);
      }, 800);
      return () => clearTimeout(aiThrowDelay);
    }
  }, [players, currentPlayerIndex, gameState, winner, animatingDart, dartsThrown, getAITarget, calculateScore, playSound, updateStats, nextPlayer, legDartsThrown, handleLegWin, currentTurnScore]);
  const startGame = useCallback(() => {
    const newPlayers = Array.from({
      length: playerSetup.count
    }, (_, i) => {
      let playerName = playerSetup.names[i] || `Player ${i + 1}`;
      let playerFlag = playerSetup.flags[i] || 'ðŸ´ó §ó ¢ó ¥ó ®ó §ó ¿';
      if (i === 0 && currentUser && !currentUser.isAnonymous) {
        if (userProfile?.displayName) {
          playerName = userProfile.displayName;
        }
        if (userProfile?.flag) {
          playerFlag = userProfile.flag;
        }
      }
      return {
        name: playerName,
        score: playerSetup.gameMode,
        isAI: playerSetup.aiPlayers[i] || false,
        aiDifficulty: playerSetup.aiDifficulty[i] || null,
        flag: playerFlag
      };
    });
    setPlayers(newPlayers);
    setCurrentPlayerIndex(0);
    setDartsThrown(0);
    setCurrentTurnScore(0);
    setThrowHistory([]);
    setDartPositions([]);
    setGameStats({});
    setWinner(null);
    setMatchWinner(null);
    setTriplesHit(0);
    setIsCheckoutPosition(false);
    setLegScores(new Array(playerSetup.count).fill(0));
    setSetScores(new Array(playerSetup.count).fill(0));
    setLegDartsThrown(new Array(playerSetup.count).fill(0));
    setGameState('playing');
  }, [playerSetup, currentUser, userProfile]);
  const resetGame = () => {
    if (onlineMode) {
      leaveOnlineGame();
      return;
    }
    setGameState('menu');
    setWinner(null);
  };
  const sanitizeOAuthDisplayName = name => {
    if (!name || typeof name !== 'string') return null;
    return name.slice(0, 50).replace(/[<>\"'&\\]/g, '').replace(/[\x00-\x1F\x7F]/g, '').replace(/\s+/g, ' ').trim() || null;
  };
  const validatePhotoURL = url => {
    if (!url || typeof url !== 'string') return null;
    try {
      const parsed = new URL(url);
      const trustedDomains = ['graph.facebook.com', 'platform-lookaside.fbsbx.com', 'lh3.googleusercontent.com', 'googleusercontent.com', 'fbcdn.net'];
      const isTrusted = parsed.protocol === 'https:' && trustedDomains.some(domain => parsed.hostname === domain || parsed.hostname.endsWith('.' + domain));
      return isTrusted ? url : null;
    } catch {
      return null;
    }
  };
  useEffect(() => {
    if (auth) {
      const unsubscribe = auth.onAuthStateChanged(user => {
        if (user) {
          let photoURL = user.photoURL;
          let displayName = user.displayName;
          let email = user.email;
          if (user.providerData && user.providerData.length > 0) {
            const provider = user.providerData[0];
            if (provider.providerId === 'facebook.com' && provider.uid) {
              const fbUid = String(provider.uid).replace(/[^0-9]/g, '');
              if (fbUid.length > 0 && fbUid.length <= 20) {
                photoURL = `https://graph.facebook.com/${fbUid}/picture?type=large`;
              }
            } else if (!photoURL) {
              photoURL = provider.photoURL;
            }
            if (!displayName) displayName = provider.displayName;
            if (!email) email = provider.email;
          }
          setCurrentUser({
            uid: user.uid,
            displayName: sanitizeOAuthDisplayName(displayName),
            email: email ? email.slice(0, 100) : null,
            photoURL: validatePhotoURL(photoURL),
            isAnonymous: user.isAnonymous
          });
        } else {
          setCurrentUser(null);
        }
      });
      return () => unsubscribe();
    }
  }, []);
  useEffect(() => {
    if (!database || !currentUser || currentUser.isAnonymous) {
      setCoinBalance(0);
      setDailyBonusAvailable(false);
      if (walletListenerRef.current) {
        walletListenerRef.current();
        walletListenerRef.current = null;
      }
      return;
    }
    const walletRef = database.ref(`users/${currentUser.uid}/wallet`);
    const walletListener = walletRef.on('value', async snapshot => {
      const wallet = snapshot.val();
      console.log('[walletListener] Wallet updated');
      if (!wallet) {
        console.log('[walletListener] No wallet found, initializing...');
        if (functions) {
          try {
            const initFn = functions.httpsCallable('initializeNewUser');
            const result = await initFn();
            console.log('[walletListener] Wallet initialized:', result.data?.success ? 'success' : 'failed');
          } catch (error) {
            console.error('[walletListener] Failed to initialize user wallet:', error);
            console.error('[walletListener] Error code:', error.code);
            console.error('[walletListener] Error message:', error.message);
            if (error.code === 'functions/permission-denied') {
              alert('Unable to create wallet. Please sign in with Google, Facebook, or Apple.');
            }
          }
        } else {
          console.error('[walletListener] Functions not available!');
        }
      } else {
        setCoinBalance(wallet.coins || 0);
        const lastBonus = wallet.lastDailyBonus || 0;
        const now = Date.now();
        const getLocalDateString = timestamp => {
          if (!timestamp) return '';
          return new Date(timestamp).toLocaleDateString('en-CA');
        };
        const lastClaimDate = getLocalDateString(lastBonus);
        const todayDate = getLocalDateString(now);
        const bonusAvailable = !lastBonus || lastClaimDate !== todayDate;
        console.log('[walletListener] Daily bonus available:', bonusAvailable);
        setDailyBonusAvailable(bonusAvailable);
        const lastAdReward = wallet.lastAdReward || 0;
        const twentyFourHours = 24 * 60 * 60 * 1000;
        const lastAdDay = Math.floor(lastAdReward / twentyFourHours);
        const currentDay = Math.floor(now / twentyFourHours);
        const adsUsedToday = currentDay > lastAdDay ? 0 : wallet.adRewardsToday || 0;
        setAdsRemainingToday(Math.max(0, 5 - adsUsedToday));
      }
    }, error => {
      console.error('Wallet listener error:', error);
    });
    walletListenerRef.current = () => walletRef.off('value', walletListener);
    return () => {
      if (walletListenerRef.current) {
        walletListenerRef.current();
        walletListenerRef.current = null;
      }
    };
  }, [currentUser]);
  useEffect(() => {
    if (!database || !currentUser || currentUser.isAnonymous) {
      setUserProfile(null);
      setUserProgression(null);
      setUserStreaks(null);
      if (profileListenerRef.current) {
        profileListenerRef.current();
        profileListenerRef.current = null;
      }
      return;
    }
    const profileRef = database.ref(`users/${currentUser.uid}/profile`);
    const progressionRef = database.ref(`users/${currentUser.uid}/progression`);
    const streaksRef = database.ref(`users/${currentUser.uid}/streaks`);
    const profileListener = profileRef.on('value', snapshot => {
      setUserProfile(snapshot.val() || null);
    }, error => {
      console.error('Profile listener error:', error);
    });
    const progressionListener = progressionRef.on('value', snapshot => {
      setUserProgression(snapshot.val() || null);
    }, error => {
      console.error('Progression listener error:', error);
    });
    const streaksListener = streaksRef.on('value', snapshot => {
      setUserStreaks(snapshot.val() || null);
    }, error => {
      console.error('Streaks listener error:', error);
    });
    profileListenerRef.current = () => {
      profileRef.off('value', profileListener);
      progressionRef.off('value', progressionListener);
      streaksRef.off('value', streaksListener);
    };
    return () => {
      if (profileListenerRef.current) {
        profileListenerRef.current();
        profileListenerRef.current = null;
      }
    };
  }, [currentUser]);
  const claimDailyBonus = async () => {
    if (!functions || !currentUser || currentUser.isAnonymous || isClaimingBonus) return;
    setIsClaimingBonus(true);
    try {
      const claimFn = functions.httpsCallable('claimDailyBonus');
      console.log('[claimDailyBonus] Calling function...');
      const result = await claimFn({
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
      });
      console.log('[claimDailyBonus] Response:', result.data);
      if (result.data.success) {
        setDailyBonusAvailable(false);
        console.log('[claimDailyBonus] Bonus claimed successfully! New balance:', result.data.newBalance);
        const coins = typeof result.data.coinsAwarded === 'number' ? result.data.coinsAwarded : 0;
        const balance = typeof result.data.newBalance === 'number' ? result.data.newBalance : 0;
        alert(`+${coins} coins claimed! New balance: ${balance}`);
      } else {
        const errorMsg = result.data.error || 'Failed to claim bonus';
        console.log('[claimDailyBonus] Claim failed:', errorMsg);
        if (result.data.nextClaimTime) {
          const nextTime = new Date(result.data.nextClaimTime);
          alert(`${errorMsg}. Next claim available: ${nextTime.toLocaleString()}`);
        } else {
          alert(errorMsg);
        }
      }
    } catch (error) {
      console.error('[claimDailyBonus] Error:', error);
      alert('Failed to claim daily bonus. Please try again.');
    } finally {
      setIsClaimingBonus(false);
    }
  };
  const watchAdForCoins = async () => {
    if (!functions || !currentUser || currentUser.isAnonymous || isWatchingAd) return;
    if (adsRemainingToday <= 0) {
      alert('Daily ad limit reached. Come back tomorrow for more!');
      return;
    }
    setIsWatchingAd(true);
    setAdError(null);
    try {
      const isCapacitor = typeof window !== 'undefined' && window.Capacitor && window.Capacitor.isNativePlatform();
      if (!isCapacitor) {
        alert('Watch rewarded ads in the mobile app to earn free coins!');
        setIsWatchingAd(false);
        return;
      }
      const {
        AdMob,
        RewardAdPluginEvents
      } = await import('@capacitor-community/admob');
      const ssvOptions = {
        customData: currentUser.uid
      };
      const rewardedAdOptions = {
        adId: 'ca-app-pub-XXXXXXXXXXXXXXXX/YYYYYYYYYY',
        isTesting: true,
        ssv: ssvOptions
      };
      let rewardReceived = false;
      const rewardListener = AdMob.addListener(RewardAdPluginEvents.Rewarded, () => {
        rewardReceived = true;
      });
      const dismissListener = AdMob.addListener(RewardAdPluginEvents.Dismissed, async () => {
        rewardListener.remove();
        dismissListener.remove();
        if (rewardReceived) {
          const maxAttempts = 10;
          const delayMs = 1500;
          for (let attempt = 0; attempt < maxAttempts; attempt++) {
            await new Promise(resolve => setTimeout(resolve, delayMs));
            try {
              const getUnclaimedFn = functions.httpsCallable('getUnclaimedAdReward');
              const unclaimedResult = await getUnclaimedFn();
              if (unclaimedResult.data.found && unclaimedResult.data.transactionId) {
                const claimFn = functions.httpsCallable('claimAdReward');
                const claimResult = await claimFn({
                  transactionId: unclaimedResult.data.transactionId
                });
                if (claimResult.data.success) {
                  setAdsRemainingToday(claimResult.data.adsRemainingToday || 0);
                } else {
                  setAdError(claimResult.data.error || 'Failed to claim reward');
                }
                break;
              }
            } catch (error) {
              console.error('[watchAdForCoins] Poll attempt failed:', error);
            }
          }
        }
        setIsWatchingAd(false);
      });
      await AdMob.prepareRewardVideoAd(rewardedAdOptions);
      await AdMob.showRewardVideoAd();
    } catch (error) {
      console.error('[watchAdForCoins] Ad error:', error);
      setAdError('Unable to load ad. Please try again later.');
      setIsWatchingAd(false);
    }
  };
  const COIN_PACKAGES = [{
    id: 'starter',
    coins: 500,
    price: '$0.99',
    popular: false
  }, {
    id: 'popular',
    coins: 1200,
    price: '$1.99',
    popular: true
  }, {
    id: 'best_value',
    coins: 3500,
    price: '$4.99',
    popular: false
  }, {
    id: 'pro',
    coins: 8000,
    price: '$9.99',
    popular: false
  }, {
    id: 'champion',
    coins: 20000,
    price: '$19.99',
    popular: false
  }];
  const purchaseCoins = async packageId => {
    if (!functions || !currentUser || currentUser.isAnonymous || isPurchasing) return;
    setIsPurchasing(true);
    try {
      const createCheckout = functions.httpsCallable('createStripeCheckout');
      const result = await createCheckout({
        packageId,
        successUrl: window.location.origin + '?purchase=success',
        cancelUrl: window.location.origin + '?purchase=cancelled'
      });
      if (result.data.success && result.data.url) {
        window.location.href = result.data.url;
      } else {
        alert('Failed to start checkout. Please try again.');
      }
    } catch (error) {
      console.error('Purchase error:', error);
      alert('Purchase failed. Please try again.');
    } finally {
      setIsPurchasing(false);
    }
  };
  const handlePlayOnlineClick = () => {
    if (currentUser && !currentUser.isAnonymous) {
      setShowStakeSelection(true);
    } else {
      startMatchmaking();
    }
  };
  const startWageredMatchmaking = async () => {
    if (coinBalance < selectedStake) {
      alert(`Not enough coins! You need ${selectedStake} coins to play this stake level.`);
      return;
    }
    if (!functions || !database) {
      alert('Online play is temporarily unavailable. Please try again later.');
      return;
    }
    const authUser = auth?.currentUser;
    if (!authUser || authUser.isAnonymous) {
      alert('Please sign in to play wagered matches.');
      return;
    }
    setShowStakeSelection(false);
    setIsCreatingEscrow(true);
    setMatchmakingState('searching');
    setOnlineMode(true);
    setIsWageredMatch(true);
    const myPlayerId = authUser.uid;
    setMyAuthId(myPlayerId);
    const wageredQueueRef = database.ref(`matchmaking_queue/wagered/${selectedStake}`);
    try {
      console.log('[wageredMatchmaking] Starting background cleanup of stale escrows...');
      const refundFn = functions.httpsCallable('refundEscrow');
      refundFn({
        escrowId: 'cleanup_pending',
        reason: 'cleanup_before_new_match'
      }).then(() => console.log('[wageredMatchmaking] Background cleanup completed')).catch(() => console.log('[wageredMatchmaking] Background cleanup failed (not critical)'));
      console.log('[wageredMatchmaking] Checking queue for opponents...');
      const snapshot = await wageredQueueRef.orderByChild('timestamp').limitToFirst(1).once('value');
      if (snapshot.exists()) {
        const opponents = snapshot.val();
        const opponentId = Object.keys(opponents)[0];
        const opponentData = opponents[opponentId];
        if (opponentData.playerId !== myPlayerId) {
          console.log('[wageredMatchmaking] Found opponent:', opponentData.playerId);
          console.log('[wageredMatchmaking] Joining opponent escrow:', opponentData.escrowId);
          try {
            const joinEscrowFn = functions.httpsCallable('createEscrow');
            const escrowResult = await joinEscrowFn({
              escrowId: opponentData.escrowId,
              stakeAmount: selectedStake
            });
            if (!escrowResult.data.success) {
              throw new Error(escrowResult.data.error || 'Failed to join escrow');
            }
            console.log('[wageredMatchmaking] Joined escrow:', escrowResult.data);
            setCurrentEscrowId(opponentData.escrowId);
            setCoinBalance(escrowResult.data.newBalance);
            const createGameFn = functions.httpsCallable('createGame');
            const result = await createGameFn({
              player1Id: opponentData.playerId,
              player1Name: sanitizeName(opponentData.name),
              player1Flag: sanitizeFlag(opponentData.flag),
              player2Id: myPlayerId,
              player2Name: sanitizeName(userProfile?.displayName || currentUser?.displayName) || 'Player',
              player2Flag: sanitizeFlag(userProfile?.flag) || 'ðŸŒ',
              gameMode: playerSetup.gameMode,
              isWagered: true,
              escrowId: opponentData.escrowId,
              stakeAmount: selectedStake
            });
            if (!result.data.success || !result.data.gameId) {
              throw new Error(result.data.error || 'Failed to create game');
            }
            const roomId = result.data.gameId;
            await wageredQueueRef.child(opponentData.playerId).update({
              matchedGameId: roomId,
              matchedByName: sanitizeName(userProfile?.displayName || currentUser?.displayName) || 'Player',
              matchedByFlag: sanitizeFlag(userProfile?.flag) || 'ðŸŒ'
            });
            setGameRoomId(roomId);
            gameRoomRef.current = database.ref(`games/${roomId}`);
            gameRoomRef.current.child('player2/connected').onDisconnect().set(false).then(() => {
              startHeartbeat(gameRoomRef.current, 'player2', 'player1', () => {
                stopHeartbeat();
                alert('Opponent disconnected. Returning to menu.');
                cancelMatchmaking();
              });
              setOpponentName(sanitizeName(opponentData.name));
              setOpponentFlag(sanitizeFlag(opponentData.flag));
              setOpponentLevel(sanitizeLevel(opponentData.level));
              setOpponentAvatar(sanitizeAvatarUrl(opponentData.avatarUrl));
              setPendingGameInfo({
                roomId,
                playerIndex: 1
              });
              setMatchmakingState('found');
            }).catch(err => {
              console.error('[wageredMatchmaking] Failed to register onDisconnect:', err);
              setOpponentName(sanitizeName(opponentData.name));
              setOpponentFlag(sanitizeFlag(opponentData.flag));
              setOpponentLevel(sanitizeLevel(opponentData.level));
              setOpponentAvatar(sanitizeAvatarUrl(opponentData.avatarUrl));
              setPendingGameInfo({
                roomId,
                playerIndex: 1
              });
              setMatchmakingState('found');
            });
            setIsCreatingEscrow(false);
            return;
          } catch (error) {
            console.error('[wageredMatchmaking] Error joining opponent:', error);
            console.log('[wageredMatchmaking] Falling back to creating own escrow...');
          }
        }
      }
      console.log('[wageredMatchmaking] No opponent found, creating escrow...');
      const createEscrowFn = functions.httpsCallable('createEscrow');
      const escrowResult = await createEscrowFn({
        stakeAmount: selectedStake
      });
      if (!escrowResult.data.success) {
        throw new Error(escrowResult.data.error || 'Failed to create escrow');
      }
      const escrowId = escrowResult.data.escrowId;
      console.log('[wageredMatchmaking] Escrow created:', escrowResult.data);
      setCurrentEscrowId(escrowId);
      setCoinBalance(escrowResult.data.newBalance);
      const myQueueEntry = {
        playerId: myPlayerId,
        name: sanitizeName(userProfile?.displayName || currentUser?.displayName) || 'Player',
        flag: sanitizeFlag(userProfile?.flag) || 'ðŸŒ',
        level: userProgression?.level || 1,
        avatarUrl: sanitizeAvatarUrl(userProfile?.avatar) || null,
        timestamp: firebase.database.ServerValue.TIMESTAMP,
        escrowId: escrowId,
        stakeAmount: selectedStake
      };
      wageredQueueRef.child(myPlayerId).set(myQueueEntry);
      wageredQueueRef.child(myPlayerId).onDisconnect().remove();
      listenForWageredMatch(myPlayerId, wageredQueueRef, escrowId);
    } catch (error) {
      console.error('[wageredMatchmaking] Error:', error);
      alert('Failed to start wagered match. Please try again.');
      setMatchmakingState('idle');
      setOnlineMode(false);
      setIsWageredMatch(false);
      setCurrentEscrowId(null);
      setEscrowData(null);
    } finally {
      setIsCreatingEscrow(false);
    }
  };
  const listenForWageredMatch = (myPlayerId, wageredQueueRef, escrowId) => {
    let isProcessingMatch = false;
    const myQueueEntryRef = wageredQueueRef.child(myPlayerId);
    wageredListenerRef.current = {
      ref: myQueueEntryRef,
      callback: null,
      timeoutId: null
    };
    const queueEntryListener = myQueueEntryRef.on('value', async snapshot => {
      if (isProcessingMatch) return;
      if (!snapshot.exists()) return;
      const myEntry = snapshot.val();
      if (myEntry.matchedGameId) {
        console.log('[wageredMatchmaking] Found matchedGameId in queue entry:', myEntry.matchedGameId);
        isProcessingMatch = true;
        const roomId = myEntry.matchedGameId;
        const matchedOpponentName = myEntry.matchedByName || 'Opponent';
        const matchedOpponentFlag = myEntry.matchedByFlag || 'ðŸŒ';
        const matchedOpponentLevel = myEntry.matchedByLevel || 1;
        const matchedOpponentAvatar = myEntry.matchedByAvatar || null;
        myQueueEntryRef.off('value', queueEntryListener);
        clearInterval(matchmakingIntervalRef.current);
        if (wageredListenerRef.current && wageredListenerRef.current.timeoutId) {
          clearTimeout(wageredListenerRef.current.timeoutId);
        }
        wageredListenerRef.current = null;
        await myQueueEntryRef.remove();
        setGameRoomId(roomId);
        gameRoomRef.current = database.ref(`games/${roomId}`);
        let gameData;
        try {
          const gameSnap = await gameRoomRef.current.once('value');
          gameData = gameSnap.val();
        } catch (readErr) {
          console.error('[wageredMatchmaking] Failed to read game - possible spoofed matchedGameId:', readErr);
          isProcessingMatch = false;
          return;
        }
        if (!gameData || gameData.player1?.id !== myPlayerId) {
          console.error('[wageredMatchmaking] Invalid game data or not player1 - ignoring matchedGameId');
          isProcessingMatch = false;
          return;
        }
        if (gameData.wager) {
          setCurrentEscrowId(gameData.wager.escrowId);
        }
        gameRoomRef.current.child('player1/connected').onDisconnect().set(false).then(() => {
          gameRoomRef.current.child('player1/connected').set(true);
          opponentWasConnected.current = true;
          startHeartbeat(gameRoomRef.current, 'player1', 'player2', () => {
            stopHeartbeat();
            alert('Opponent disconnected. Returning to menu.');
            cancelMatchmaking();
          });
          setOpponentName(sanitizeName(matchedOpponentName));
          setOpponentFlag(sanitizeFlag(matchedOpponentFlag));
          setOpponentLevel(sanitizeLevel(matchedOpponentLevel));
          setOpponentAvatar(sanitizeAvatarUrl(matchedOpponentAvatar));
          setPendingGameInfo({
            roomId,
            playerIndex: 0
          });
          setMatchmakingState('found');
        }).catch(err => {
          console.error('[wageredMatchmaking] Failed to register onDisconnect:', err);
          setOpponentName(sanitizeName(matchedOpponentName));
          setOpponentFlag(sanitizeFlag(matchedOpponentFlag));
          setOpponentLevel(sanitizeLevel(matchedOpponentLevel));
          setOpponentAvatar(sanitizeAvatarUrl(matchedOpponentAvatar));
          setPendingGameInfo({
            roomId,
            playerIndex: 0
          });
          setMatchmakingState('found');
        });
        return;
      }
    });
    if (wageredListenerRef.current) {
      wageredListenerRef.current.callback = queueEntryListener;
    }
    matchmakingIntervalRef.current = setInterval(async () => {
      if (isProcessingMatch) return;
      wageredQueueRef.once('value', async queueSnapshot => {
        if (isProcessingMatch) return;
        if (!queueSnapshot.exists()) return;
        const queueEntries = queueSnapshot.val();
        const opponents = Object.entries(queueEntries).filter(([id]) => id !== myPlayerId).filter(([, data]) => !data.matchedGameId).map(([id, data]) => ({
          id,
          ...data
        }));
        if (opponents.length === 0) return;
        const opponent = opponents.reduce((oldest, current) => (current.timestamp || 0) < (oldest.timestamp || 0) ? current : oldest);
        if (myPlayerId < opponent.playerId) {
          console.log('[wageredMatchmaking] I have lower UID, I will initiate match with', opponent.playerId);
          const ourEscrowRef = database.ref(`escrow/${escrowId}`);
          const ourEscrowSnap = await ourEscrowRef.once('value');
          const ourEscrow = ourEscrowSnap.val();
          if (ourEscrow && ourEscrow.status === 'locked') {
            console.log('[wageredMatchmaking] Our escrow is already locked - someone joined us. Waiting for matchedGameId...');
            return;
          }
          isProcessingMatch = true;
          try {
            console.log('[wageredMatchmaking] Refunding our escrow before joining opponent');
            const refundFn = functions.httpsCallable('refundEscrow');
            await refundFn({
              escrowId,
              reason: 'switching_to_opponent'
            });
            console.log('[wageredMatchmaking] Refunded, now joining opponent escrow:', opponent.escrowId);
            let escrowResult;
            let retries = 3;
            while (retries > 0) {
              try {
                const joinEscrowFn = functions.httpsCallable('createEscrow');
                escrowResult = await joinEscrowFn({
                  escrowId: opponent.escrowId,
                  stakeAmount: opponent.stakeAmount
                });
                if (escrowResult.data.success) break;
                throw new Error(escrowResult.data.error || 'Failed to join escrow');
              } catch (joinErr) {
                retries--;
                console.log('[wageredMatchmaking] Join attempt failed, retries left:', retries);
                if (retries === 0) throw joinErr;
                await new Promise(r => setTimeout(r, 500));
              }
            }
            console.log('[wageredMatchmaking] Joined escrow successfully:', escrowResult.data);
            setCurrentEscrowId(opponent.escrowId);
            setCoinBalance(escrowResult.data.newBalance);
            console.log('[wageredMatchmaking] Creating game with opponent:', opponent.playerId);
            const createGameFn = functions.httpsCallable('createGame');
            const result = await createGameFn({
              player1Id: opponent.playerId,
              player1Name: sanitizeName(opponent.name),
              player1Flag: sanitizeFlag(opponent.flag),
              player2Id: myPlayerId,
              player2Name: sanitizeName(userProfile?.displayName || currentUser?.displayName) || 'Player',
              player2Flag: sanitizeFlag(userProfile?.flag) || 'ðŸŒ',
              gameMode: playerSetup.gameMode,
              isWagered: true,
              escrowId: opponent.escrowId,
              stakeAmount: opponent.stakeAmount
            });
            if (!result.data.success || !result.data.gameId) {
              throw new Error(result.data.error || 'Failed to create game');
            }
            console.log('[wageredMatchmaking] Game created successfully:', result.data.gameId);
            const roomId = result.data.gameId;
            await wageredQueueRef.child(opponent.playerId).update({
              matchedGameId: roomId,
              matchedByName: sanitizeName(userProfile?.displayName || currentUser?.displayName) || 'Player',
              matchedByFlag: sanitizeFlag(userProfile?.flag) || 'ðŸŒ',
              matchedByLevel: userProgression?.level || 1,
              matchedByAvatar: sanitizeAvatarUrl(userProfile?.avatar) || null
            });
            myQueueEntryRef.off('value', queueEntryListener);
            clearInterval(matchmakingIntervalRef.current);
            if (wageredListenerRef.current && wageredListenerRef.current.timeoutId) {
              clearTimeout(wageredListenerRef.current.timeoutId);
            }
            wageredListenerRef.current = null;
            await myQueueEntryRef.remove();
            setGameRoomId(roomId);
            gameRoomRef.current = database.ref(`games/${roomId}`);
            gameRoomRef.current.child('player2/connected').onDisconnect().set(false).then(() => {
              startHeartbeat(gameRoomRef.current, 'player2', 'player1', () => {
                stopHeartbeat();
                alert('Opponent disconnected. Returning to menu.');
                cancelMatchmaking();
              });
              setOpponentName(sanitizeName(opponent.name));
              setOpponentFlag(sanitizeFlag(opponent.flag));
              setOpponentLevel(sanitizeLevel(opponent.level));
              setOpponentAvatar(sanitizeAvatarUrl(opponent.avatarUrl));
              setPendingGameInfo({
                roomId,
                playerIndex: 1
              });
              setMatchmakingState('found');
            }).catch(err => {
              console.error('[wageredMatchmaking] Failed to register onDisconnect:', err);
              setOpponentName(sanitizeName(opponent.name));
              setOpponentFlag(sanitizeFlag(opponent.flag));
              setOpponentLevel(sanitizeLevel(opponent.level));
              setOpponentAvatar(sanitizeAvatarUrl(opponent.avatarUrl));
              setPendingGameInfo({
                roomId,
                playerIndex: 1
              });
              setMatchmakingState('found');
            });
          } catch (error) {
            console.error('[wageredMatchmaking] Error matching from queue:', error);
            const errorMsg = error.message || error.toString();
            if (errorMsg.includes('locked escrow') || errorMsg.includes('Cannot refund')) {
              console.log('[wageredMatchmaking] Our escrow is locked - opponent joined us. Waiting for matchedGameId...');
              isProcessingMatch = false;
              return;
            }
            try {
              console.log('[wageredMatchmaking] Match failed, creating new escrow to stay in queue');
              const createEscrowFn = functions.httpsCallable('createEscrow');
              const newEscrowResult = await createEscrowFn({
                stakeAmount: opponent.stakeAmount
              });
              if (newEscrowResult.data.success) {
                const newEscrowId = newEscrowResult.data.escrowId;
                setCurrentEscrowId(newEscrowId);
                setCoinBalance(newEscrowResult.data.newBalance);
                await myQueueEntryRef.update({
                  escrowId: newEscrowId
                });
                console.log('[wageredMatchmaking] Created new escrow, staying in queue');
              }
            } catch (escrowErr) {
              console.error('[wageredMatchmaking] Failed to create new escrow:', escrowErr);
            }
            isProcessingMatch = false;
          }
        }
      });
    }, 2000);
    const timeoutId = setTimeout(() => {
      console.log('[wageredMatchmaking] Timeout - no opponent found');
      myQueueEntryRef.off('value', queueEntryListener);
      if (matchmakingIntervalRef.current) {
        clearInterval(matchmakingIntervalRef.current);
        matchmakingIntervalRef.current = null;
      }
      myQueueEntryRef.remove();
      wageredListenerRef.current = null;
      if (functions && escrowId) {
        const refundFn = functions.httpsCallable('refundEscrow');
        refundFn({
          escrowId,
          reason: 'cancelled'
        }).then(result => {
          console.log('[wageredMatchmaking] Escrow refunded on timeout:', result.data);
          if (result.data.refundedAmounts && result.data.refundedAmounts[0]) {
            setCoinBalance(prev => prev + result.data.refundedAmounts[0]);
          }
        }).catch(err => console.error('[wageredMatchmaking] Refund failed:', err));
      }
      setMatchmakingState('idle');
      setOnlineMode(false);
      setIsWageredMatch(false);
      setCurrentEscrowId(null);
      setEscrowData(null);
      alert('No opponent found. Your coins have been refunded. Please try again.');
    }, 60000);
    if (wageredListenerRef.current) {
      wageredListenerRef.current.timeoutId = timeoutId;
    }
  };
  const signInWithGoogle = async () => {
    try {
      const provider = new firebase.auth.GoogleAuthProvider();
      await auth.signInWithPopup(provider);
      setShowLoginModal(false);
    } catch (error) {
      alert('Unable to sign in. Please try again or use a different method.');
    }
  };
  const signInWithFacebook = async () => {
    try {
      const provider = new firebase.auth.FacebookAuthProvider();
      await auth.signInWithPopup(provider);
      setShowLoginModal(false);
    } catch (error) {
      alert('Unable to sign in. Please try again or use a different method.');
    }
  };
  const handleSignOut = async () => {
    try {
      await auth.signOut();
      await auth.signInAnonymously();
    } catch (error) {}
  };
  const enterPracticeMode = () => {
    setPracticeMode('selecting');
  };
  const startPracticeSession = skill => {
    setPracticeSkillLevel(skill);
    setPracticeMode('active');
    setGameState('playing');
    setPracticeStats({
      dartsThrown: 0,
      t20: 0,
      t19: 0,
      t18: 0,
      bulls: 0,
      singleBull: 0,
      triples: 0,
      doubles: 0,
      totalScore: 0
    });
    setDartPositions([]);
    setTriplesHit(0);
    setCurrentTurnThrows([]);
    setAimWobble({
      x: 0,
      y: 0
    });
  };
  const exitPracticeMode = () => {
    setPracticeMode(false);
    setPracticeSkillLevel(null);
    setGameState('menu');
    setDartPositions([]);
  };
  useEffect(() => {
    const interval = setInterval(() => {
      setTimeUntilReset(getTimeUntilWeeklyReset());
    }, 60000);
    return () => clearInterval(interval);
  }, []);
  useEffect(() => {
    if (achievementPopup) {
      const timeoutId = setTimeout(() => {
        setAchievementPopup(null);
      }, 4000);
      return () => clearTimeout(timeoutId);
    }
  }, [achievementPopup]);
  const getRarityColor = rarity => {
    switch (rarity) {
      case 'common':
        return '#95a5a6';
      case 'uncommon':
        return '#27ae60';
      case 'rare':
        return '#3498db';
      case 'epic':
        return '#9b59b6';
      case 'legendary':
        return '#f39c12';
      case 'mythic':
        return '#e74c3c';
      default:
        return '#95a5a6';
    }
  };
  const getRarityCardStyle = (rarity, isUnlocked) => {
    if (!isUnlocked) return {};
    const color = getRarityColor(rarity);
    switch (rarity) {
      case 'common':
        return {
          border: `1px solid ${color}30`,
          boxShadow: 'none'
        };
      case 'uncommon':
        return {
          border: `1px solid ${color}50`,
          boxShadow: `0 0 10px ${color}20`
        };
      case 'rare':
        return {
          border: `2px solid ${color}60`,
          boxShadow: `0 0 15px ${color}30`,
          animation: 'rareShimmer 3s ease-in-out infinite'
        };
      case 'epic':
        return {
          border: `2px solid ${color}70`,
          boxShadow: `0 0 20px ${color}40, inset 0 0 30px ${color}10`,
          animation: 'epicGlow 2s ease-in-out infinite'
        };
      case 'legendary':
        return {
          border: `2px solid ${color}`,
          boxShadow: `0 0 25px ${color}50, 0 0 50px ${color}20`,
          animation: 'legendaryPulse 2s ease-in-out infinite',
          background: `linear-gradient(135deg, ${COLORS.backgroundCard}, ${color}15)`
        };
      case 'mythic':
        return {
          border: `3px solid ${color}`,
          boxShadow: `0 0 30px ${color}60, 0 0 60px ${color}30, inset 0 0 40px ${color}10`,
          animation: 'mythicGlow 1.5s ease-in-out infinite',
          background: `linear-gradient(135deg, ${COLORS.backgroundCard}, ${color}20)`
        };
      default:
        return {};
    }
  };
  const getAchievementProgress = (achievement, stats) => {
    if (!achievement.statKey || !achievement.target) {
      return null;
    }
    const current = stats[achievement.statKey] || 0;
    const target = achievement.target;
    if (achievement.isThreshold) {
      const progress = Math.min(current / target, 1);
      return {
        current,
        target,
        progress,
        isThreshold: true
      };
    }
    const progress = Math.min(current / target, 1);
    return {
      current,
      target,
      progress,
      isThreshold: false
    };
  };
  const renderDartboard = () => {
    const segments = [];
    const theme = currentTheme;
    const colors = currentThemeColors;
    const effects = theme.effects;
    const glowIntensity = effects.pulseAnimation ? 0.6 + 0.4 * Math.sin(neonPulsePhase) : 1;
    segments.push(React.createElement("defs", {
      key: "gradients"
    }, effects.useBoardLighting && React.createElement("radialGradient", {
      id: "boardLighting",
      cx: "50%",
      cy: "45%"
    }, React.createElement("stop", {
      offset: "0%",
      stopColor: "rgba(255,255,255,0.15)"
    }), React.createElement("stop", {
      offset: "60%",
      stopColor: "rgba(255,255,255,0.05)"
    }), React.createElement("stop", {
      offset: "100%",
      stopColor: "rgba(0,0,0,0.1)"
    })), React.createElement("radialGradient", {
      id: "bullGradient",
      cx: "40%",
      cy: "40%"
    }, React.createElement("stop", {
      offset: "0%",
      stopColor: "rgba(255,255,255,0.3)"
    }), React.createElement("stop", {
      offset: "70%",
      stopColor: "rgba(0,0,0,0)"
    }), React.createElement("stop", {
      offset: "100%",
      stopColor: "rgba(0,0,0,0.3)"
    })), effects.useChromeGradient && React.createElement("linearGradient", {
      id: "chromeGradient",
      x1: "0%",
      y1: "0%",
      x2: "0%",
      y2: "100%"
    }, React.createElement("stop", {
      offset: "0%",
      stopColor: "#f0f0f0"
    }), React.createElement("stop", {
      offset: "15%",
      stopColor: "#ffffff"
    }), React.createElement("stop", {
      offset: "30%",
      stopColor: colors.chromeRing
    }), React.createElement("stop", {
      offset: "50%",
      stopColor: "#e8e8e8"
    }), React.createElement("stop", {
      offset: "70%",
      stopColor: "#a0a0a0"
    }), React.createElement("stop", {
      offset: "85%",
      stopColor: "#d0d0d0"
    }), React.createElement("stop", {
      offset: "100%",
      stopColor: "#b0b0b0"
    })), effects.glowEffect && React.createElement("filter", {
      id: "neonGlow",
      x: "-50%",
      y: "-50%",
      width: "200%",
      height: "200%"
    }, React.createElement("feGaussianBlur", {
      stdDeviation: 3 * glowIntensity,
      result: "coloredBlur"
    }), React.createElement("feMerge", null, React.createElement("feMergeNode", {
      in: "coloredBlur"
    }), React.createElement("feMergeNode", {
      in: "SourceGraphic"
    }))), effects.useMetallicSheen && React.createElement("linearGradient", {
      id: "goldGradient",
      x1: "0%",
      y1: "0%",
      x2: "100%",
      y2: "100%"
    }, React.createElement("stop", {
      offset: "0%",
      stopColor: "#ffd700"
    }), React.createElement("stop", {
      offset: "25%",
      stopColor: "#ffed4a"
    }), React.createElement("stop", {
      offset: "50%",
      stopColor: "#ffd700"
    }), React.createElement("stop", {
      offset: "75%",
      stopColor: "#b8860b"
    }), React.createElement("stop", {
      offset: "100%",
      stopColor: "#ffd700"
    })), effects.useSisalTexture && React.createElement("pattern", {
      id: "sisalTexture",
      x: "0",
      y: "0",
      width: "4",
      height: "4",
      patternUnits: "userSpaceOnUse"
    }, React.createElement("rect", {
      width: "4",
      height: "4",
      fill: "rgba(0,0,0,0)"
    }), React.createElement("circle", {
      cx: "1",
      cy: "1",
      r: "0.3",
      fill: "rgba(0,0,0,0.08)"
    }), React.createElement("circle", {
      cx: "3",
      cy: "2",
      r: "0.3",
      fill: "rgba(0,0,0,0.06)"
    }), React.createElement("circle", {
      cx: "2",
      cy: "3",
      r: "0.3",
      fill: "rgba(0,0,0,0.07)"
    }), React.createElement("circle", {
      cx: "0.5",
      cy: "3.5",
      r: "0.2",
      fill: "rgba(255,255,255,0.03)"
    }), React.createElement("circle", {
      cx: "3.5",
      cy: "0.5",
      r: "0.2",
      fill: "rgba(255,255,255,0.03)"
    })), effects.useWoodGrain && React.createElement("pattern", {
      id: "woodGrain",
      x: "0",
      y: "0",
      width: "20",
      height: "100",
      patternUnits: "userSpaceOnUse",
      patternTransform: "rotate(90)"
    }, React.createElement("rect", {
      width: "20",
      height: "100",
      fill: "rgba(80,60,40,0.1)"
    }), React.createElement("path", {
      d: "M 0 10 Q 5 15, 10 10 T 20 10",
      stroke: "rgba(60,40,20,0.15)",
      strokeWidth: "0.5",
      fill: "none"
    }), React.createElement("path", {
      d: "M 0 30 Q 5 28, 10 30 T 20 30",
      stroke: "rgba(60,40,20,0.1)",
      strokeWidth: "0.3",
      fill: "none"
    }), React.createElement("path", {
      d: "M 0 50 Q 5 55, 10 50 T 20 50",
      stroke: "rgba(60,40,20,0.12)",
      strokeWidth: "0.4",
      fill: "none"
    }), React.createElement("path", {
      d: "M 0 70 Q 5 68, 10 70 T 20 70",
      stroke: "rgba(60,40,20,0.1)",
      strokeWidth: "0.3",
      fill: "none"
    }), React.createElement("path", {
      d: "M 0 90 Q 5 92, 10 90 T 20 90",
      stroke: "rgba(60,40,20,0.08)",
      strokeWidth: "0.3",
      fill: "none"
    }))));
    segments.push(React.createElement("circle", {
      key: "number-ring-bg",
      cx: CENTER,
      cy: CENTER,
      r: DOUBLE_OUTER + 24,
      fill: colors.numberRing
    }));
    if (effects.useChromeGradient) {
      segments.push(React.createElement("circle", {
        key: "chrome-ring",
        cx: CENTER,
        cy: CENTER,
        r: DOUBLE_OUTER + 8,
        fill: "url(#chromeGradient)"
      }), effects.useWoodGrain && React.createElement("circle", {
        key: "chrome-wood",
        cx: CENTER,
        cy: CENTER,
        r: DOUBLE_OUTER + 8,
        fill: "url(#woodGrain)",
        opacity: "0.3"
      }), React.createElement("circle", {
        key: "chrome-ring-inner",
        cx: CENTER,
        cy: CENTER,
        r: DOUBLE_OUTER + 2,
        fill: colors.boardBackground
      }));
    } else {
      segments.push(React.createElement("circle", {
        key: "chrome-ring",
        cx: CENTER,
        cy: CENTER,
        r: DOUBLE_OUTER + 8,
        fill: colors.chromeRing
      }), React.createElement("circle", {
        key: "chrome-ring-inner",
        cx: CENTER,
        cy: CENTER,
        r: DOUBLE_OUTER + 2,
        fill: colors.boardBackground
      }));
    }
    for (let i = 0; i < 20; i++) {
      const startAngle = (i * 18 - 99) * (Math.PI / 180);
      const endAngle = ((i + 1) * 18 - 99) * (Math.PI / 180);
      const createArc = (innerR, outerR) => {
        const x1 = CENTER + innerR * Math.cos(startAngle);
        const y1 = CENTER + innerR * Math.sin(startAngle);
        const x2 = CENTER + outerR * Math.cos(startAngle);
        const y2 = CENTER + outerR * Math.sin(startAngle);
        const x3 = CENTER + outerR * Math.cos(endAngle);
        const y3 = CENTER + outerR * Math.sin(endAngle);
        const x4 = CENTER + innerR * Math.cos(endAngle);
        const y4 = CENTER + innerR * Math.sin(endAngle);
        return `M ${x1} ${y1} L ${x2} ${y2} A ${outerR} ${outerR} 0 0 1 ${x3} ${y3} L ${x4} ${y4} A ${innerR} ${innerR} 0 0 0 ${x1} ${y1}`;
      };
      const baseColor = i % 2 === 0 ? colors.segmentPrimary : colors.segmentSecondary;
      const doubleColor = i % 2 === 0 ? colors.doubleTripleEven : colors.doubleTripleOdd;
      const tripleColor = i % 2 === 0 ? colors.doubleTripleEven : colors.doubleTripleOdd;
      const shadowOffset = effects.shadowIntensity > 0 ? 0.5 : 0;
      const shadowOpacity = effects.shadowIntensity;
      if (shadowOpacity > 0) {
        segments.push(React.createElement("path", {
          key: `shadow-outer-${i}`,
          d: createArc(TRIPLE_OUTER, DOUBLE_INNER),
          fill: `rgba(0,0,0,${shadowOpacity})`,
          transform: `translate(${shadowOffset}, ${shadowOffset})`
        }), React.createElement("path", {
          key: `shadow-double-${i}`,
          d: createArc(DOUBLE_INNER, DOUBLE_OUTER),
          fill: `rgba(0,0,0,${shadowOpacity})`,
          transform: `translate(${shadowOffset}, ${shadowOffset})`
        }), React.createElement("path", {
          key: `shadow-inner-${i}`,
          d: createArc(OUTER_BULL, TRIPLE_INNER),
          fill: `rgba(0,0,0,${shadowOpacity})`,
          transform: `translate(${shadowOffset}, ${shadowOffset})`
        }), React.createElement("path", {
          key: `shadow-triple-${i}`,
          d: createArc(TRIPLE_INNER, TRIPLE_OUTER),
          fill: `rgba(0,0,0,${shadowOpacity})`,
          transform: `translate(${shadowOffset}, ${shadowOffset})`
        }));
      }
      segments.push(React.createElement("path", {
        key: `outer-${i}`,
        d: createArc(TRIPLE_OUTER, DOUBLE_INNER),
        fill: baseColor
      }), React.createElement("path", {
        key: `double-${i}`,
        d: createArc(DOUBLE_INNER, DOUBLE_OUTER),
        fill: doubleColor
      }), React.createElement("path", {
        key: `inner-${i}`,
        d: createArc(OUTER_BULL, TRIPLE_INNER),
        fill: baseColor
      }), React.createElement("path", {
        key: `triple-${i}`,
        d: createArc(TRIPLE_INNER, TRIPLE_OUTER),
        fill: tripleColor
      }));
      if (effects.useSisalTexture) {
        segments.push(React.createElement("path", {
          key: `texture-outer-${i}`,
          d: createArc(TRIPLE_OUTER, DOUBLE_INNER),
          fill: "url(#sisalTexture)",
          stroke: "none"
        }), React.createElement("path", {
          key: `texture-double-${i}`,
          d: createArc(DOUBLE_INNER, DOUBLE_OUTER),
          fill: "url(#sisalTexture)",
          stroke: "none"
        }), React.createElement("path", {
          key: `texture-inner-${i}`,
          d: createArc(OUTER_BULL, TRIPLE_INNER),
          fill: "url(#sisalTexture)",
          stroke: "none"
        }), React.createElement("path", {
          key: `texture-triple-${i}`,
          d: createArc(TRIPLE_INNER, TRIPLE_OUTER),
          fill: "url(#sisalTexture)",
          stroke: "none"
        }));
      }
      if (!effects.glowEffect && effects.shadowIntensity > 0.1) {
        const wireHighlightOffset = -0.3;
        segments.push(React.createElement("path", {
          key: `wire-highlight-${i}`,
          d: createArc(TRIPLE_OUTER, DOUBLE_INNER),
          fill: "none",
          stroke: colors.wireHighlight,
          strokeWidth: "0.5",
          transform: `translate(0, ${wireHighlightOffset})`
        }), React.createElement("path", {
          key: `wire-highlight-double-${i}`,
          d: createArc(DOUBLE_INNER, DOUBLE_OUTER),
          fill: "none",
          stroke: colors.wireHighlight,
          strokeWidth: "0.5",
          transform: `translate(0, ${wireHighlightOffset})`
        }), React.createElement("path", {
          key: `wire-highlight-inner-${i}`,
          d: createArc(OUTER_BULL, TRIPLE_INNER),
          fill: "none",
          stroke: colors.wireHighlight,
          strokeWidth: "0.5",
          transform: `translate(0, ${wireHighlightOffset})`
        }), React.createElement("path", {
          key: `wire-highlight-triple-${i}`,
          d: createArc(TRIPLE_INNER, TRIPLE_OUTER),
          fill: "none",
          stroke: colors.wireHighlight,
          strokeWidth: "0.5",
          transform: `translate(0, ${wireHighlightOffset})`
        }));
      }
    }
    const bullShadowOpacity = effects.shadowIntensity > 0 ? effects.shadowIntensity : 0;
    segments.push(bullShadowOpacity > 0 && React.createElement("circle", {
      key: "outer-bull-shadow",
      cx: CENTER + 1,
      cy: CENTER + 1,
      r: OUTER_BULL,
      fill: `rgba(0,0,0,${bullShadowOpacity})`
    }), React.createElement("circle", {
      key: "outer-bull",
      cx: CENTER,
      cy: CENTER,
      r: OUTER_BULL,
      fill: colors.outerBull,
      style: effects.glowEffect ? {
        filter: 'url(#neonGlow)'
      } : {}
    }), effects.useSisalTexture && React.createElement("circle", {
      key: "outer-bull-texture",
      cx: CENTER,
      cy: CENTER,
      r: OUTER_BULL,
      fill: "url(#sisalTexture)",
      stroke: "none"
    }), !effects.glowEffect && effects.shadowIntensity > 0.1 && React.createElement("circle", {
      key: "outer-bull-highlight",
      cx: CENTER,
      cy: CENTER,
      r: OUTER_BULL,
      fill: "url(#bullGradient)"
    }), bullShadowOpacity > 0 && React.createElement("circle", {
      key: "inner-bull-shadow",
      cx: CENTER + 1,
      cy: CENTER + 1,
      r: INNER_BULL,
      fill: `rgba(0,0,0,${bullShadowOpacity + 0.1})`
    }), React.createElement("circle", {
      key: "inner-bull",
      cx: CENTER,
      cy: CENTER,
      r: INNER_BULL,
      fill: colors.innerBull,
      style: effects.glowEffect ? {
        filter: 'url(#neonGlow)'
      } : {}
    }), effects.useSisalTexture && React.createElement("circle", {
      key: "inner-bull-texture",
      cx: CENTER,
      cy: CENTER,
      r: INNER_BULL,
      fill: "url(#sisalTexture)",
      stroke: "none"
    }), !effects.glowEffect && effects.shadowIntensity > 0.1 && React.createElement("ellipse", {
      key: "inner-bull-shine",
      cx: CENTER - 2,
      cy: CENTER - 2,
      rx: INNER_BULL * 0.4,
      ry: INNER_BULL * 0.3,
      fill: "rgba(255,255,255,0.4)"
    }));
    for (let i = 0; i < 20; i++) {
      const angle = (i * 18 - 99) * (Math.PI / 180);
      const x1 = CENTER + OUTER_BULL * Math.cos(angle);
      const y1 = CENTER + OUTER_BULL * Math.sin(angle);
      const x2 = CENTER + DOUBLE_OUTER * Math.cos(angle);
      const y2 = CENTER + DOUBLE_OUTER * Math.sin(angle);
      segments.push(React.createElement("line", {
        key: `spider-wire-${i}`,
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2,
        stroke: colors.wireColor,
        strokeWidth: effects.wireWidth
      }));
    }
    [INNER_BULL, OUTER_BULL, TRIPLE_INNER, TRIPLE_OUTER, DOUBLE_INNER, DOUBLE_OUTER].forEach((radius, idx) => {
      segments.push(React.createElement("circle", {
        key: `ring-wire-${idx}`,
        cx: CENTER,
        cy: CENTER,
        r: radius,
        fill: "none",
        stroke: colors.wireColor,
        strokeWidth: effects.wireWidth
      }));
    });
    if (effects.glowEffect && colors.neonPrimary) {
      for (let i = 0; i < 20; i++) {
        const startAngle = (i * 18 - 99) * (Math.PI / 180);
        const midAngle = (i * 18 + 9 - 99) * (Math.PI / 180);
        const x1 = CENTER + OUTER_BULL * Math.cos(startAngle);
        const y1 = CENTER + OUTER_BULL * Math.sin(startAngle);
        const x2 = CENTER + DOUBLE_OUTER * Math.cos(startAngle);
        const y2 = CENTER + DOUBLE_OUTER * Math.sin(startAngle);
        segments.push(React.createElement("line", {
          key: `neon-wire-${i}`,
          x1: x1,
          y1: y1,
          x2: x2,
          y2: y2,
          stroke: colors.neonPrimary,
          strokeWidth: effects.wireWidth,
          style: {
            filter: 'url(#neonGlow)',
            opacity: glowIntensity
          }
        }));
      }
      [OUTER_BULL, TRIPLE_INNER, TRIPLE_OUTER, DOUBLE_INNER, DOUBLE_OUTER].forEach((radius, idx) => {
        segments.push(React.createElement("circle", {
          key: `neon-ring-${idx}`,
          cx: CENTER,
          cy: CENTER,
          r: radius,
          fill: "none",
          stroke: colors.neonPrimary,
          strokeWidth: effects.wireWidth * 0.8,
          style: {
            filter: 'url(#neonGlow)',
            opacity: glowIntensity
          }
        }));
      });
    }
    if (effects.useBoardLighting) {
      segments.push(React.createElement("circle", {
        key: "board-lighting",
        cx: CENTER,
        cy: CENTER,
        r: DOUBLE_OUTER + 2,
        fill: "url(#boardLighting)",
        pointerEvents: "none"
      }));
    }
    if (effects.useMetallicSheen && colors.metallicSheen) {
      segments.push(React.createElement("circle", {
        key: "metallic-sheen",
        cx: CENTER,
        cy: CENTER,
        r: DOUBLE_OUTER + 2,
        fill: colors.metallicSheen,
        pointerEvents: "none"
      }));
    }
    const textStyle = effects.glowEffect ? {
      fontFamily: "'Oswald', sans-serif",
      filter: 'url(#neonGlow)'
    } : {
      fontFamily: "'Oswald', sans-serif"
    };
    const numberRadius = DOUBLE_OUTER + 16;
    for (let i = 0; i < 20; i++) {
      const textAngle = (i * 18 - 90) * (Math.PI / 180);
      const textX = CENTER + numberRadius * Math.cos(textAngle);
      const textY = CENTER + numberRadius * Math.sin(textAngle);
      if (effects.shadowIntensity > 0) {
        segments.push(React.createElement("text", {
          key: `text-shadow-${i}`,
          x: textX + 0.5,
          y: textY + 0.5,
          fill: "rgba(0,0,0,0.5)",
          fontSize: "16",
          fontWeight: "bold",
          textAnchor: "middle",
          dominantBaseline: "middle",
          style: {
            fontFamily: "'Oswald', sans-serif"
          }
        }, SEGMENTS[i]));
      }
      segments.push(React.createElement("text", {
        key: `text-${i}`,
        x: textX,
        y: textY,
        fill: colors.numberText,
        fontSize: "16",
        fontWeight: "bold",
        textAnchor: "middle",
        dominantBaseline: "middle",
        style: textStyle
      }, SEGMENTS[i]));
    }
    return segments.filter(Boolean);
  };
  const renderDart = (position, index) => React.createElement("g", {
    key: index,
    transform: `translate(${position.x}, ${position.y})`
  }, React.createElement("ellipse", {
    cx: "0",
    cy: "2",
    rx: "4",
    ry: "2",
    fill: "rgba(0,0,0,0.3)"
  }), React.createElement("line", {
    x1: "0",
    y1: "-15",
    x2: "0",
    y2: "5",
    stroke: "#c0c0c0",
    strokeWidth: "2"
  }), React.createElement("polygon", {
    points: "-4,-15 4,-15 0,-25",
    fill: "#c41e3a"
  }), React.createElement("circle", {
    cx: "0",
    cy: "0",
    r: "3",
    fill: "#ffd700"
  }), React.createElement("polygon", {
    points: "-6,5 6,5 0,-2",
    fill: "#1a1a2e"
  }));
  if (practiceMode === 'selecting') {
    return React.createElement("div", {
      style: {
        minHeight: '100vh',
        background: COLORS.background,
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        padding: '20px'
      }
    }, React.createElement("div", {
      style: {
        position: 'fixed',
        inset: 0,
        background: `radial-gradient(ellipse at 30% 20%, ${COLORS.primary}40 0%, transparent 50%), radial-gradient(ellipse at 70% 80%, ${COLORS.accent}20 0%, transparent 40%), linear-gradient(180deg, ${COLORS.background} 0%, ${COLORS.backgroundLight} 100%)`,
        zIndex: 0
      }
    }), React.createElement("div", {
      style: {
        background: COLORS.backgroundCard,
        borderRadius: '16px',
        padding: '48px 40px',
        border: '1px solid rgba(255, 255, 255, 0.05)',
        boxShadow: '0 25px 60px rgba(0, 0, 0, 0.5)',
        maxWidth: '420px',
        textAlign: 'center',
        width: '100%',
        position: 'relative',
        zIndex: 1
      }
    }, React.createElement("div", {
      style: {
        marginBottom: '24px'
      }
    }, React.createElement(TargetIcon, {
      size: 48,
      color: COLORS.accent
    })), React.createElement("h2", {
      style: {
        color: COLORS.text,
        fontSize: '1.75rem',
        marginBottom: '8px',
        fontWeight: '700'
      }
    }, "Practice Mode"), React.createElement("p", {
      style: {
        color: COLORS.textMuted,
        fontSize: '1rem',
        marginBottom: '32px'
      }
    }, "Select your skill level to begin"), React.createElement("div", {
      style: {
        display: 'flex',
        flexDirection: 'column',
        gap: '12px',
        marginBottom: '24px'
      }
    }, React.createElement("button", {
      className: "btn",
      onClick: () => startPracticeSession(30),
      style: {
        width: '100%',
        padding: '16px 24px',
        background: 'linear-gradient(135deg, #2D8A2D, #1f6b1f)',
        color: '#fff',
        border: 'none',
        borderRadius: '10px',
        cursor: 'pointer',
        fontSize: '1rem',
        fontWeight: '600',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '12px',
        transition: 'all 0.2s ease'
      }
    }, React.createElement("div", {
      style: {
        width: '10px',
        height: '10px',
        borderRadius: '50%',
        background: '#4ade80'
      }
    }), "Beginner"), React.createElement("button", {
      className: "btn",
      onClick: () => startPracticeSession(60),
      style: {
        width: '100%',
        padding: '16px 24px',
        background: 'linear-gradient(135deg, #D4A03A, #B8862E)',
        color: COLORS.textDark,
        border: 'none',
        borderRadius: '10px',
        cursor: 'pointer',
        fontSize: '1rem',
        fontWeight: '600',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '12px',
        transition: 'all 0.2s ease'
      }
    }, React.createElement("div", {
      style: {
        width: '10px',
        height: '10px',
        borderRadius: '50%',
        background: '#fcd34d'
      }
    }), "Intermediate"), React.createElement("button", {
      className: "btn",
      onClick: () => startPracticeSession(90),
      style: {
        width: '100%',
        padding: '16px 24px',
        background: 'linear-gradient(135deg, #C92A2A, #a82222)',
        color: '#fff',
        border: 'none',
        borderRadius: '10px',
        cursor: 'pointer',
        fontSize: '1rem',
        fontWeight: '600',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '12px',
        transition: 'all 0.2s ease'
      }
    }, React.createElement("div", {
      style: {
        width: '10px',
        height: '10px',
        borderRadius: '50%',
        background: '#f87171'
      }
    }), "Expert")), React.createElement("button", {
      className: "btn btn-ghost",
      onClick: exitPracticeMode,
      style: {
        width: '100%',
        padding: '14px 24px',
        fontSize: '0.9rem'
      }
    }, "Back to Menu")));
  }
  if (matchmakingState === 'searching' || matchmakingState === 'found' || matchmakingState === 'intro') {
    return React.createElement(MatchmakingOverlay, {
      visible: true,
      stage: matchmakingState,
      isWagered: isWageredMatch,
      stakeAmount: selectedStake * 2,
      you: {
        name: sanitizeName(userProfile?.displayName) || 'You',
        level: sanitizeLevel(userProgression?.level) || 1,
        avatarUrl: sanitizeAvatarUrl(userProfile?.avatar)
      },
      opponent: opponentName ? {
        name: opponentName,
        level: opponentLevel,
        avatarUrl: opponentAvatar
      } : null,
      onCancel: cancelMatchmaking
    });
  }
  if (showLoginModal) {
    return React.createElement("div", {
      style: {
        position: 'fixed',
        inset: 0,
        background: 'rgba(0, 0, 0, 0.8)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1000,
        padding: '20px'
      },
      onClick: () => setShowLoginModal(false)
    }, React.createElement("div", {
      style: {
        background: COLORS.backgroundCard,
        borderRadius: '16px',
        padding: '32px',
        maxWidth: '400px',
        width: '100%',
        position: 'relative',
        border: '1px solid rgba(255, 255, 255, 0.1)'
      },
      onClick: e => e.stopPropagation()
    }, React.createElement("button", {
      onClick: () => setShowLoginModal(false),
      style: {
        position: 'absolute',
        top: '16px',
        right: '16px',
        background: 'none',
        border: 'none',
        color: COLORS.textMuted,
        cursor: 'pointer',
        padding: '4px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      },
      "aria-label": "Close"
    }, React.createElement("svg", {
      width: "20",
      height: "20",
      viewBox: "0 0 24 24",
      fill: "none",
      stroke: "currentColor",
      strokeWidth: "2"
    }, React.createElement("line", {
      x1: "18",
      y1: "6",
      x2: "6",
      y2: "18"
    }), React.createElement("line", {
      x1: "6",
      y1: "6",
      x2: "18",
      y2: "18"
    }))), React.createElement("h2", {
      style: {
        color: COLORS.text,
        fontSize: '1.5rem',
        fontWeight: '700',
        textAlign: 'center',
        marginBottom: '24px',
        textTransform: 'uppercase',
        letterSpacing: '2px'
      }
    }, "Login"), React.createElement("div", {
      style: {
        display: 'flex',
        flexDirection: 'column',
        gap: '12px'
      }
    }, React.createElement("button", {
      onClick: signInWithFacebook,
      style: {
        width: '100%',
        padding: '14px 20px',
        borderRadius: '8px',
        border: 'none',
        background: '#1877F2',
        color: 'white',
        fontSize: '1rem',
        fontWeight: '600',
        cursor: 'pointer',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '12px',
        fontFamily: 'var(--font-primary)'
      }
    }, React.createElement("svg", {
      width: "20",
      height: "20",
      viewBox: "0 0 24 24",
      fill: "currentColor"
    }, React.createElement("path", {
      d: "M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"
    })), "Sign in with Facebook"), React.createElement("button", {
      onClick: signInWithGoogle,
      style: {
        width: '100%',
        padding: '14px 20px',
        borderRadius: '8px',
        border: '1px solid rgba(255, 255, 255, 0.2)',
        background: 'white',
        color: '#333',
        fontSize: '1rem',
        fontWeight: '600',
        cursor: 'pointer',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '12px',
        fontFamily: 'var(--font-primary)'
      }
    }, React.createElement("svg", {
      width: "20",
      height: "20",
      viewBox: "0 0 24 24"
    }, React.createElement("path", {
      fill: "#4285F4",
      d: "M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
    }), React.createElement("path", {
      fill: "#34A853",
      d: "M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
    }), React.createElement("path", {
      fill: "#FBBC05",
      d: "M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
    }), React.createElement("path", {
      fill: "#EA4335",
      d: "M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
    })), "Sign in with Google")), React.createElement("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        margin: '24px 0',
        gap: '12px'
      }
    }, React.createElement("div", {
      style: {
        flex: 1,
        height: '1px',
        background: 'rgba(255, 255, 255, 0.1)'
      }
    }), React.createElement("span", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.85rem'
      }
    }, "OR"), React.createElement("div", {
      style: {
        flex: 1,
        height: '1px',
        background: 'rgba(255, 255, 255, 0.1)'
      }
    })), React.createElement("button", {
      onClick: () => setShowLoginModal(false),
      style: {
        width: '100%',
        padding: '14px 20px',
        borderRadius: '8px',
        border: '1px solid rgba(255, 255, 255, 0.1)',
        background: 'transparent',
        color: COLORS.textMuted,
        fontSize: '0.95rem',
        cursor: 'pointer',
        fontFamily: 'var(--font-primary)'
      }
    }, "Continue as Guest"), React.createElement("p", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.8rem',
        textAlign: 'center',
        marginTop: '16px',
        lineHeight: '1.5'
      }
    }, "Sign in to save your progress, track stats, and compete on leaderboards.")));
  }
  if (showStakeSelection) {
    const stakeOptions = [{
      amount: 50,
      label: 'Casual',
      description: 'Low stakes, perfect for warming up'
    }, {
      amount: 100,
      label: 'Standard',
      description: 'The most popular stake level'
    }, {
      amount: 500,
      label: 'High Roller',
      description: 'For confident players'
    }, {
      amount: 2500,
      label: 'Champion',
      description: 'Maximum risk, maximum reward'
    }];
    return React.createElement("div", {
      style: {
        position: 'fixed',
        inset: 0,
        background: 'rgba(0, 0, 0, 0.85)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1000,
        padding: '20px'
      },
      onClick: () => setShowStakeSelection(false)
    }, React.createElement("div", {
      style: {
        background: COLORS.backgroundCard,
        borderRadius: '16px',
        padding: '32px',
        maxWidth: '450px',
        width: '100%',
        position: 'relative',
        border: '1px solid rgba(255, 255, 255, 0.1)'
      },
      onClick: e => e.stopPropagation()
    }, React.createElement("button", {
      onClick: () => setShowStakeSelection(false),
      style: {
        position: 'absolute',
        top: '16px',
        right: '16px',
        background: 'none',
        border: 'none',
        color: COLORS.textMuted,
        cursor: 'pointer',
        padding: '4px'
      }
    }, React.createElement(CloseIcon, {
      size: 24
    })), React.createElement("div", {
      style: {
        textAlign: 'center',
        marginBottom: '24px'
      }
    }, React.createElement("h2", {
      style: {
        color: COLORS.text,
        fontSize: '1.5rem',
        fontWeight: '700',
        marginBottom: '8px'
      }
    }, "Choose Your Stake"), React.createElement("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '8px',
        marginBottom: '8px'
      }
    }, React.createElement(CoinIcon, {
      size: 20
    }), React.createElement("span", {
      style: {
        color: '#D4A03A',
        fontWeight: '600',
        fontSize: '1.1rem'
      }
    }, "Your Balance: ", formatCoins(coinBalance))), React.createElement("p", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.9rem'
      }
    }, "Winner takes the entire pot!")), React.createElement("div", {
      style: {
        display: 'flex',
        flexDirection: 'column',
        gap: '12px',
        marginBottom: '24px'
      }
    }, stakeOptions.map(option => {
      const isSelected = selectedStake === option.amount;
      const canAfford = coinBalance >= option.amount;
      const potAmount = option.amount * 2;
      return React.createElement("button", {
        key: option.amount,
        onClick: () => canAfford && setSelectedStake(option.amount),
        disabled: !canAfford,
        style: {
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'space-between',
          padding: '16px 20px',
          borderRadius: '12px',
          border: isSelected ? '2px solid #D4A03A' : '1px solid rgba(255, 255, 255, 0.1)',
          background: isSelected ? 'rgba(212, 160, 58, 0.15)' : canAfford ? 'rgba(255, 255, 255, 0.03)' : 'rgba(255, 255, 255, 0.02)',
          cursor: canAfford ? 'pointer' : 'not-allowed',
          opacity: canAfford ? 1 : 0.5,
          transition: 'all 0.2s ease'
        }
      }, React.createElement("div", {
        style: {
          textAlign: 'left'
        }
      }, React.createElement("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          gap: '8px'
        }
      }, React.createElement("span", {
        style: {
          color: COLORS.text,
          fontWeight: '600',
          fontSize: '1rem'
        }
      }, option.label), !canAfford && React.createElement("span", {
        style: {
          color: COLORS.error,
          fontSize: '0.7rem',
          fontWeight: '600',
          padding: '2px 6px',
          background: 'rgba(201, 42, 42, 0.2)',
          borderRadius: '4px'
        }
      }, "Need ", option.amount - coinBalance, " more")), React.createElement("p", {
        style: {
          color: COLORS.textMuted,
          fontSize: '0.8rem',
          margin: '4px 0 0 0'
        }
      }, option.description)), React.createElement("div", {
        style: {
          textAlign: 'right'
        }
      }, React.createElement("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          gap: '4px',
          color: '#D4A03A',
          fontWeight: '700'
        }
      }, React.createElement(CoinIcon, {
        size: 14
      }), React.createElement("span", null, formatCoins(option.amount))), React.createElement("p", {
        style: {
          color: COLORS.success,
          fontSize: '0.75rem',
          margin: '4px 0 0 0'
        }
      }, "Win ", formatCoins(potAmount))));
    })), React.createElement("button", {
      onClick: startWageredMatchmaking,
      disabled: coinBalance < selectedStake,
      style: {
        width: '100%',
        padding: '16px 24px',
        borderRadius: '10px',
        border: 'none',
        background: coinBalance >= selectedStake ? 'linear-gradient(135deg, #D4A03A, #B8862E)' : 'rgba(255, 255, 255, 0.1)',
        color: coinBalance >= selectedStake ? COLORS.textDark : COLORS.textMuted,
        fontSize: '1rem',
        fontWeight: '700',
        cursor: coinBalance >= selectedStake ? 'pointer' : 'not-allowed',
        fontFamily: 'var(--font-primary)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '8px'
      }
    }, React.createElement(GlobeIcon, {
      size: 20,
      color: coinBalance >= selectedStake ? COLORS.textDark : COLORS.textMuted
    }), "Play for ", formatCoins(selectedStake), " Coins"), React.createElement("button", {
      onClick: () => {
        setShowStakeSelection(false);
        startMatchmaking();
      },
      style: {
        width: '100%',
        marginTop: '12px',
        padding: '12px',
        borderRadius: '8px',
        border: '1px solid rgba(255, 255, 255, 0.1)',
        background: 'transparent',
        color: COLORS.textMuted,
        fontSize: '0.9rem',
        cursor: 'pointer',
        fontFamily: 'var(--font-primary)'
      }
    }, "Play Free (No Stakes)")));
  }
  if (showLeaveConfirmation) {
    return React.createElement("div", {
      style: {
        position: 'fixed',
        inset: 0,
        background: 'rgba(0, 0, 0, 0.85)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1001,
        padding: '20px'
      }
    }, React.createElement("div", {
      style: {
        background: COLORS.backgroundCard,
        borderRadius: '16px',
        padding: '32px',
        maxWidth: '400px',
        width: '100%',
        position: 'relative',
        border: '1px solid rgba(255, 255, 255, 0.1)',
        textAlign: 'center'
      }
    }, React.createElement("div", {
      style: {
        width: '64px',
        height: '64px',
        borderRadius: '50%',
        background: `${COLORS.error}20`,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        margin: '0 auto 20px'
      }
    }, React.createElement("span", {
      style: {
        fontSize: '32px'
      }
    }, "\u26A0\uFE0F")), React.createElement("h2", {
      style: {
        color: COLORS.text,
        fontSize: '1.3rem',
        fontWeight: '700',
        marginBottom: '12px'
      }
    }, "Leave Match?"), React.createElement("p", {
      style: {
        color: COLORS.textMuted,
        fontSize: '1rem',
        marginBottom: '24px',
        lineHeight: '1.5'
      }
    }, "Are you sure you want to leave? You will forfeit your coins."), escrowData && React.createElement("div", {
      style: {
        background: 'rgba(255, 255, 255, 0.05)',
        borderRadius: '8px',
        padding: '12px',
        marginBottom: '24px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '8px'
      }
    }, React.createElement(CoinIcon, {
      size: 18
    }), React.createElement("span", {
      style: {
        color: '#D4A03A',
        fontWeight: '600'
      }
    }, formatCoins(escrowData.stakeLevel || 0), " at stake")), React.createElement("div", {
      style: {
        display: 'flex',
        gap: '12px'
      }
    }, React.createElement("button", {
      onClick: () => setShowLeaveConfirmation(false),
      style: {
        flex: 1,
        padding: '14px 20px',
        borderRadius: '10px',
        border: '1px solid rgba(255, 255, 255, 0.2)',
        background: 'transparent',
        color: COLORS.text,
        fontSize: '1rem',
        fontWeight: '600',
        cursor: 'pointer',
        fontFamily: 'var(--font-primary)'
      }
    }, "No, Stay"), React.createElement("button", {
      onClick: () => {
        setShowLeaveConfirmation(false);
        leaveOnlineGame();
      },
      style: {
        flex: 1,
        padding: '14px 20px',
        borderRadius: '10px',
        border: 'none',
        background: COLORS.error,
        color: 'white',
        fontSize: '1rem',
        fontWeight: '600',
        cursor: 'pointer',
        fontFamily: 'var(--font-primary)'
      }
    }, "Yes, Leave"))));
  }
  if (showCoinShop) {
    return React.createElement("div", {
      style: {
        position: 'fixed',
        inset: 0,
        background: 'rgba(0, 0, 0, 0.85)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1000,
        padding: '20px'
      },
      onClick: () => setShowCoinShop(false)
    }, React.createElement("div", {
      style: {
        background: COLORS.backgroundCard,
        borderRadius: '16px',
        padding: '32px',
        maxWidth: '500px',
        width: '100%',
        position: 'relative',
        border: '1px solid rgba(255, 255, 255, 0.1)',
        maxHeight: '90vh',
        overflowY: 'auto'
      },
      onClick: e => e.stopPropagation()
    }, React.createElement("button", {
      onClick: () => setShowCoinShop(false),
      style: {
        position: 'absolute',
        top: '16px',
        right: '16px',
        background: 'none',
        border: 'none',
        color: COLORS.textMuted,
        cursor: 'pointer',
        padding: '4px'
      }
    }, React.createElement(CloseIcon, {
      size: 24
    })), React.createElement("div", {
      style: {
        textAlign: 'center',
        marginBottom: '24px'
      }
    }, React.createElement("h2", {
      style: {
        color: COLORS.text,
        fontSize: '1.5rem',
        fontWeight: '700',
        marginBottom: '8px'
      }
    }, "Coin Shop"), React.createElement("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '8px',
        marginBottom: '8px'
      }
    }, React.createElement(CoinIcon, {
      size: 20
    }), React.createElement("span", {
      style: {
        color: '#D4A03A',
        fontWeight: '600',
        fontSize: '1.1rem'
      }
    }, "Your Balance: ", formatCoins(coinBalance))), React.createElement("p", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.9rem'
      }
    }, "Purchase coins to play wagered matches!")), React.createElement("div", {
      style: {
        display: 'flex',
        flexDirection: 'column',
        gap: '12px'
      }
    }, COIN_PACKAGES.map(pkg => React.createElement("button", {
      key: pkg.id,
      onClick: () => purchaseCoins(pkg.id),
      disabled: isPurchasing,
      style: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        padding: '16px 20px',
        borderRadius: '12px',
        border: pkg.popular ? '2px solid #D4A03A' : '1px solid rgba(255, 255, 255, 0.1)',
        background: pkg.popular ? 'rgba(212, 160, 58, 0.15)' : 'rgba(255, 255, 255, 0.03)',
        cursor: isPurchasing ? 'wait' : 'pointer',
        opacity: isPurchasing ? 0.7 : 1,
        transition: 'all 0.2s ease',
        position: 'relative'
      }
    }, pkg.popular && React.createElement("span", {
      style: {
        position: 'absolute',
        top: '-10px',
        left: '20px',
        background: 'linear-gradient(135deg, #D4A03A, #B8862E)',
        color: '#0D1117',
        padding: '2px 10px',
        borderRadius: '10px',
        fontSize: '0.7rem',
        fontWeight: '700'
      }
    }, "POPULAR"), React.createElement("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        gap: '12px'
      }
    }, React.createElement(CoinIcon, {
      size: 24
    }), React.createElement("span", {
      style: {
        color: COLORS.text,
        fontWeight: '600',
        fontSize: '1.1rem'
      }
    }, formatCoins(pkg.coins))), React.createElement("span", {
      style: {
        color: '#D4A03A',
        fontWeight: '700',
        fontSize: '1rem',
        background: 'rgba(212, 160, 58, 0.2)',
        padding: '6px 14px',
        borderRadius: '8px'
      }
    }, pkg.price)))), React.createElement("p", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.75rem',
        textAlign: 'center',
        marginTop: '20px'
      }
    }, "Secure payment via Stripe. Coins are non-refundable.")));
  }
  if (showProfileScreen && currentUser && !currentUser.isAnonymous) {
    const getXPForLevel = level => {
      if (level <= 1) return 0;
      return Math.floor(50 * level * Math.pow(1.08, level - 1));
    };
    const level = userProgression?.level || 1;
    const xp = userProgression?.xp || 0;
    const currentLevelXP = getXPForLevel(level);
    const nextLevelXP = getXPForLevel(level + 1);
    const xpProgress = nextLevelXP > currentLevelXP ? (xp - currentLevelXP) / (nextLevelXP - currentLevelXP) : 1;
    const gamesPlayed = userProgression?.gamesPlayed || 0;
    const gamesWon = userProgression?.gamesWon || 0;
    const winPercentage = gamesPlayed > 0 ? (gamesWon / gamesPlayed * 100).toFixed(1) : '0.0';
    const bestStreak = userStreaks?.bestWinStreak || 0;
    const currentStreak = userStreaks?.currentWinStreak || 0;
    const getRankTitle = lvl => {
      if (lvl >= 80) return 'Legend';
      if (lvl >= 60) return 'Master';
      if (lvl >= 40) return 'Expert';
      if (lvl >= 25) return 'Veteran';
      if (lvl >= 15) return 'Skilled';
      if (lvl >= 8) return 'Amateur';
      if (lvl >= 3) return 'Novice';
      return 'Rookie';
    };
    const rankTitle = getRankTitle(level);
    const copyUniqueId = () => {
      const uniqueId = userProfile?.uniqueId || 'N/A';
      navigator.clipboard.writeText(uniqueId).then(() => {
        alert('Player ID copied to clipboard!');
      }).catch(() => {
        alert('Failed to copy ID');
      });
    };
    return React.createElement("div", {
      style: {
        minHeight: '100vh',
        background: COLORS.background,
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        padding: '80px 20px 40px'
      }
    }, React.createElement("div", {
      style: {
        position: 'fixed',
        inset: 0,
        background: `radial-gradient(ellipse at 30% 20%, ${COLORS.primary}40 0%, transparent 50%), radial-gradient(ellipse at 70% 80%, ${COLORS.accent}20 0%, transparent 40%), linear-gradient(180deg, ${COLORS.background} 0%, ${COLORS.backgroundLight} 100%)`,
        zIndex: 0
      }
    }), React.createElement("div", {
      style: {
        maxWidth: '900px',
        width: '100%',
        position: 'relative',
        zIndex: 1
      }
    }, React.createElement("div", {
      style: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: '32px'
      }
    }, React.createElement("h1", {
      style: {
        fontSize: 'clamp(1.75rem, 4vw, 2.5rem)',
        fontWeight: '700',
        color: COLORS.text,
        margin: 0
      }
    }, "Profile"), React.createElement("button", {
      className: "btn btn-ghost",
      onClick: () => setShowProfileScreen(false),
      style: {
        padding: '12px 24px'
      }
    }, "Back")), React.createElement("div", {
      style: {
        display: 'grid',
        gridTemplateColumns: 'minmax(280px, 1fr) 2fr',
        gap: '24px'
      }
    }, React.createElement("div", {
      style: {
        background: COLORS.backgroundCard,
        borderRadius: '16px',
        padding: '32px 24px',
        border: '1px solid rgba(255, 255, 255, 0.05)',
        textAlign: 'center'
      }
    }, React.createElement("div", {
      style: {
        position: 'relative',
        width: '120px',
        height: '120px',
        margin: '0 auto 20px',
        borderRadius: '50%',
        background: `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})`,
        padding: '4px',
        boxShadow: `0 0 20px ${COLORS.accent}40`
      }
    }, currentUser.photoURL ? React.createElement("img", {
      src: currentUser.photoURL,
      alt: "Profile",
      style: {
        width: '100%',
        height: '100%',
        borderRadius: '50%',
        objectFit: 'cover'
      },
      referrerPolicy: "no-referrer"
    }) : React.createElement("div", {
      style: {
        width: '100%',
        height: '100%',
        borderRadius: '50%',
        background: COLORS.backgroundLight,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        fontSize: '48px',
        fontWeight: '700',
        color: COLORS.accent
      }
    }, (userProfile?.displayName || currentUser.displayName || 'P')[0].toUpperCase()), React.createElement("div", {
      style: {
        position: 'absolute',
        bottom: '-5px',
        right: '-5px',
        background: `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})`,
        borderRadius: '50%',
        width: '36px',
        height: '36px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        fontWeight: '700',
        fontSize: '14px',
        color: COLORS.textDark,
        border: `3px solid ${COLORS.background}`
      }
    }, level)), isEditingNickname ? React.createElement("div", {
      style: {
        marginBottom: '16px'
      }
    }, React.createElement("input", {
      type: "text",
      value: nicknameInput,
      onChange: e => setNicknameInput(e.target.value.slice(0, 20)),
      placeholder: "Enter nickname...",
      maxLength: 20,
      autoFocus: true,
      style: {
        width: '100%',
        padding: '10px 12px',
        background: 'rgba(255, 255, 255, 0.1)',
        border: `1px solid ${COLORS.accent}`,
        borderRadius: '8px',
        color: COLORS.text,
        fontSize: '1rem',
        textAlign: 'center',
        marginBottom: '10px',
        outline: 'none',
        fontFamily: "'Inter', sans-serif"
      },
      onKeyDown: e => {
        if (e.key === 'Enter') saveNickname();
        if (e.key === 'Escape') {
          setIsEditingNickname(false);
          setNicknameInput('');
        }
      }
    }), React.createElement("div", {
      style: {
        display: 'flex',
        gap: '8px',
        justifyContent: 'center'
      }
    }, React.createElement("button", {
      onClick: saveNickname,
      style: {
        padding: '8px 16px',
        background: COLORS.success,
        color: COLORS.text,
        border: 'none',
        borderRadius: '6px',
        fontSize: '0.85rem',
        fontWeight: '600',
        cursor: 'pointer'
      }
    }, "Save"), React.createElement("button", {
      onClick: () => {
        setIsEditingNickname(false);
        setNicknameInput('');
      },
      style: {
        padding: '8px 16px',
        background: 'rgba(255, 255, 255, 0.1)',
        color: COLORS.textMuted,
        border: '1px solid rgba(255, 255, 255, 0.2)',
        borderRadius: '6px',
        fontSize: '0.85rem',
        fontWeight: '600',
        cursor: 'pointer'
      }
    }, "Cancel"))) : React.createElement("div", {
      style: {
        marginBottom: '8px'
      }
    }, React.createElement("h2", {
      style: {
        color: COLORS.text,
        fontSize: '1.5rem',
        fontWeight: '600',
        margin: '0 0 4px 0',
        display: 'inline'
      }
    }, userProfile?.displayName || currentUser.displayName || 'Player'), React.createElement("button", {
      onClick: () => {
        setNicknameInput(userProfile?.displayName || currentUser.displayName || '');
        setIsEditingNickname(true);
      },
      style: {
        background: 'none',
        border: 'none',
        color: COLORS.accent,
        cursor: 'pointer',
        padding: '4px 8px',
        fontSize: '14px',
        verticalAlign: 'middle',
        marginLeft: '4px'
      },
      title: "Edit display name"
    }, "\u270F\uFE0F")), React.createElement("div", {
      style: {
        color: COLORS.textMuted,
        fontSize: '1rem',
        marginBottom: '16px'
      }
    }, userProfile?.flag || 'ðŸŒ', " ", rankTitle), React.createElement("div", {
      style: {
        background: 'rgba(255, 255, 255, 0.05)',
        borderRadius: '8px',
        padding: '12px',
        marginBottom: '20px'
      }
    }, React.createElement("div", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.75rem',
        marginBottom: '4px'
      }
    }, "Player ID"), React.createElement("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '8px'
      }
    }, React.createElement("span", {
      style: {
        color: COLORS.accent,
        fontWeight: '600',
        fontFamily: 'monospace',
        fontSize: '1rem'
      }
    }, userProfile?.uniqueId || 'N/A'), React.createElement("button", {
      onClick: copyUniqueId,
      style: {
        background: 'none',
        border: 'none',
        color: COLORS.textMuted,
        cursor: 'pointer',
        padding: '4px',
        fontSize: '16px'
      },
      title: "Copy ID"
    }, "\uD83D\uDCCB"))), React.createElement("div", {
      style: {
        background: 'rgba(212, 160, 58, 0.1)',
        borderRadius: '8px',
        padding: '12px',
        border: '1px solid rgba(212, 160, 58, 0.2)'
      }
    }, React.createElement("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '8px'
      }
    }, React.createElement(CoinIcon, {
      size: 20
    }), React.createElement("span", {
      style: {
        color: COLORS.accent,
        fontWeight: '700',
        fontSize: '1.25rem'
      }
    }, formatCoins(coinBalance))))), React.createElement("div", {
      style: {
        display: 'flex',
        flexDirection: 'column',
        gap: '16px'
      }
    }, React.createElement("div", {
      style: {
        background: COLORS.backgroundCard,
        borderRadius: '12px',
        padding: '20px',
        border: '1px solid rgba(255, 255, 255, 0.05)'
      }
    }, React.createElement("div", {
      style: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: '12px'
      }
    }, React.createElement("span", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.85rem'
      }
    }, "Level Progress"), React.createElement("span", {
      style: {
        color: COLORS.accent,
        fontWeight: '600'
      }
    }, "Level ", level)), React.createElement("div", {
      style: {
        background: 'rgba(255, 255, 255, 0.1)',
        borderRadius: '8px',
        height: '12px',
        overflow: 'hidden',
        marginBottom: '8px'
      }
    }, React.createElement("div", {
      style: {
        background: `linear-gradient(90deg, ${COLORS.accent}, ${COLORS.accentLight})`,
        height: '100%',
        width: `${xpProgress * 100}%`,
        borderRadius: '8px',
        transition: 'width 0.5s'
      }
    })), React.createElement("div", {
      style: {
        display: 'flex',
        justifyContent: 'space-between',
        color: COLORS.textMuted,
        fontSize: '0.8rem'
      }
    }, React.createElement("span", null, formatCoins(xp), " XP"), React.createElement("span", null, formatCoins(nextLevelXP), " XP"))), React.createElement("div", {
      style: {
        background: COLORS.backgroundCard,
        borderRadius: '12px',
        padding: '20px',
        border: '1px solid rgba(255, 255, 255, 0.05)'
      }
    }, React.createElement("h3", {
      style: {
        color: COLORS.text,
        fontSize: '1rem',
        fontWeight: '600',
        margin: '0 0 16px 0'
      }
    }, "Player Stats"), React.createElement("div", {
      style: {
        display: 'grid',
        gridTemplateColumns: 'repeat(2, 1fr)',
        gap: '16px'
      }
    }, React.createElement("div", {
      style: {
        background: 'rgba(255, 255, 255, 0.03)',
        borderRadius: '8px',
        padding: '12px'
      }
    }, React.createElement("div", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.75rem',
        marginBottom: '4px'
      }
    }, "Games Played"), React.createElement("div", {
      style: {
        color: COLORS.text,
        fontSize: '1.25rem',
        fontWeight: '600'
      }
    }, gamesPlayed)), React.createElement("div", {
      style: {
        background: 'rgba(255, 255, 255, 0.03)',
        borderRadius: '8px',
        padding: '12px'
      }
    }, React.createElement("div", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.75rem',
        marginBottom: '4px'
      }
    }, "Games Won"), React.createElement("div", {
      style: {
        color: '#27ae60',
        fontSize: '1.25rem',
        fontWeight: '600'
      }
    }, gamesWon)), React.createElement("div", {
      style: {
        background: 'rgba(255, 255, 255, 0.03)',
        borderRadius: '8px',
        padding: '12px'
      }
    }, React.createElement("div", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.75rem',
        marginBottom: '4px'
      }
    }, "Win Rate"), React.createElement("div", {
      style: {
        color: COLORS.accent,
        fontSize: '1.25rem',
        fontWeight: '600'
      }
    }, winPercentage, "%")), React.createElement("div", {
      style: {
        background: 'rgba(255, 255, 255, 0.03)',
        borderRadius: '8px',
        padding: '12px'
      }
    }, React.createElement("div", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.75rem',
        marginBottom: '4px'
      }
    }, "Total Earnings"), React.createElement("div", {
      style: {
        color: COLORS.accent,
        fontSize: '1.25rem',
        fontWeight: '600'
      }
    }, formatCoins(coinBalance))))), React.createElement("div", {
      style: {
        background: COLORS.backgroundCard,
        borderRadius: '12px',
        padding: '20px',
        border: '1px solid rgba(255, 255, 255, 0.05)'
      }
    }, React.createElement("h3", {
      style: {
        color: COLORS.text,
        fontSize: '1rem',
        fontWeight: '600',
        margin: '0 0 16px 0'
      }
    }, "Win Streaks"), React.createElement("div", {
      style: {
        display: 'grid',
        gridTemplateColumns: 'repeat(2, 1fr)',
        gap: '16px'
      }
    }, React.createElement("div", {
      style: {
        background: 'rgba(255, 255, 255, 0.03)',
        borderRadius: '8px',
        padding: '12px'
      }
    }, React.createElement("div", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.75rem',
        marginBottom: '4px'
      }
    }, "Current Streak"), React.createElement("div", {
      style: {
        color: currentStreak > 0 ? '#27ae60' : COLORS.text,
        fontSize: '1.25rem',
        fontWeight: '600'
      }
    }, currentStreak, " ", currentStreak > 0 && 'ðŸ”¥')), React.createElement("div", {
      style: {
        background: 'rgba(255, 255, 255, 0.03)',
        borderRadius: '8px',
        padding: '12px'
      }
    }, React.createElement("div", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.75rem',
        marginBottom: '4px'
      }
    }, "Best Streak"), React.createElement("div", {
      style: {
        color: COLORS.accent,
        fontSize: '1.25rem',
        fontWeight: '600'
      }
    }, bestStreak, " \uD83C\uDFC6")))), React.createElement("div", {
      style: {
        background: COLORS.backgroundCard,
        borderRadius: '12px',
        padding: '20px',
        border: '1px solid rgba(255, 255, 255, 0.05)'
      }
    }, React.createElement("div", {
      style: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: '12px'
      }
    }, React.createElement("h3", {
      style: {
        color: COLORS.text,
        fontSize: '1rem',
        fontWeight: '600',
        margin: 0
      }
    }, "Achievements"), React.createElement("button", {
      onClick: () => {
        setShowProfileScreen(false);
        setShowAchievements(true);
      },
      style: {
        background: 'none',
        border: 'none',
        color: COLORS.accent,
        cursor: 'pointer',
        fontSize: '0.85rem',
        fontWeight: '500'
      }
    }, "View All \u2192")), React.createElement("div", {
      style: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: '8px'
      }
    }, React.createElement("span", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.85rem'
      }
    }, "Progress"), React.createElement("span", {
      style: {
        color: COLORS.accent,
        fontWeight: '600'
      }
    }, unlockedAchievements.length, " / ", ACHIEVEMENTS_DATA.length)), React.createElement("div", {
      style: {
        background: 'rgba(255, 255, 255, 0.1)',
        borderRadius: '8px',
        height: '8px',
        overflow: 'hidden'
      }
    }, React.createElement("div", {
      style: {
        background: `linear-gradient(90deg, ${COLORS.accent}, ${COLORS.accentLight})`,
        height: '100%',
        width: `${unlockedAchievements.length / ACHIEVEMENTS_DATA.length * 100}%`,
        borderRadius: '8px'
      }
    })))))));
  }
  if (showAchievements) {
    return React.createElement("div", {
      style: {
        minHeight: '100vh',
        background: COLORS.background,
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        padding: '80px 20px 40px'
      }
    }, React.createElement("div", {
      style: {
        position: 'fixed',
        inset: 0,
        background: `radial-gradient(ellipse at 30% 20%, ${COLORS.primary}40 0%, transparent 50%), radial-gradient(ellipse at 70% 80%, ${COLORS.accent}20 0%, transparent 40%), linear-gradient(180deg, ${COLORS.background} 0%, ${COLORS.backgroundLight} 100%)`,
        zIndex: 0
      }
    }), React.createElement("div", {
      style: {
        maxWidth: '1000px',
        width: '100%',
        position: 'relative',
        zIndex: 1
      }
    }, React.createElement("div", {
      style: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: '32px'
      }
    }, React.createElement("div", null, React.createElement("h1", {
      style: {
        fontSize: 'clamp(1.75rem, 4vw, 2.5rem)',
        fontWeight: '700',
        color: COLORS.text,
        margin: 0
      }
    }, "Achievements"), React.createElement("p", {
      style: {
        color: COLORS.textMuted,
        fontSize: '1rem',
        marginTop: '4px'
      }
    }, "Track your progress and unlock rewards")), React.createElement("button", {
      className: "btn btn-ghost",
      onClick: () => setShowAchievements(false),
      style: {
        padding: '12px 24px'
      }
    }, "Back")), React.createElement("div", {
      style: {
        display: 'flex',
        gap: '8px',
        marginBottom: '24px',
        background: COLORS.backgroundCard,
        borderRadius: '12px',
        padding: '6px',
        border: '1px solid rgba(255, 255, 255, 0.05)'
      }
    }, ['offline', 'online'].map(tab => {
      const isActive = achievementTab === tab;
      const tabAchievements = ACHIEVEMENTS_DATA.filter(a => a.mode === tab);
      const tabUnlocked = unlockedAchievements.filter(id => ACHIEVEMENTS_DATA.find(a => a.id === id)?.mode === tab);
      return React.createElement("button", {
        key: tab,
        onClick: () => setAchievementTab(tab),
        style: {
          flex: 1,
          padding: '14px 20px',
          borderRadius: '8px',
          border: 'none',
          cursor: 'pointer',
          fontWeight: '600',
          fontSize: '0.95rem',
          fontFamily: "'Inter', sans-serif",
          transition: 'all 0.2s ease',
          background: isActive ? tab === 'offline' ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})` : 'linear-gradient(135deg, #60a5fa, #3b82f6)' : 'transparent',
          color: isActive ? tab === 'offline' ? COLORS.textDark : '#fff' : COLORS.textMuted
        }
      }, React.createElement("span", {
        style: {
          marginRight: '8px'
        }
      }, tab === 'offline' ? 'ðŸŽ®' : 'ðŸŒ'), tab === 'offline' ? 'Offline' : 'Online', React.createElement("span", {
        style: {
          marginLeft: '8px',
          fontSize: '0.8rem',
          opacity: 0.9
        }
      }, tabUnlocked.length, "/", tabAchievements.length));
    })), (() => {
      const tabAchievements = ACHIEVEMENTS_DATA.filter(a => a.mode === achievementTab);
      const tabUnlocked = unlockedAchievements.filter(id => ACHIEVEMENTS_DATA.find(a => a.id === id)?.mode === achievementTab);
      const progress = tabAchievements.length > 0 ? tabUnlocked.length / tabAchievements.length * 100 : 0;
      return React.createElement("div", {
        style: {
          background: COLORS.backgroundCard,
          borderRadius: '12px',
          padding: '24px',
          marginBottom: '32px',
          border: '1px solid rgba(255, 255, 255, 0.05)'
        }
      }, React.createElement("div", {
        style: {
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: '12px'
        }
      }, React.createElement("span", {
        style: {
          color: COLORS.textMuted,
          fontSize: '0.9rem'
        }
      }, achievementTab === 'offline' ? 'Offline Progress' : 'Online Progress'), React.createElement("span", {
        style: {
          color: achievementTab === 'offline' ? COLORS.accent : '#60a5fa',
          fontSize: '1rem',
          fontWeight: '600'
        }
      }, tabUnlocked.length, " / ", tabAchievements.length)), React.createElement("div", {
        style: {
          background: 'rgba(255, 255, 255, 0.1)',
          borderRadius: '8px',
          height: '8px',
          overflow: 'hidden'
        }
      }, React.createElement("div", {
        style: {
          background: achievementTab === 'offline' ? `linear-gradient(90deg, ${COLORS.accent}, ${COLORS.accentLight})` : 'linear-gradient(90deg, #60a5fa, #93c5fd)',
          height: '100%',
          width: `${progress}%`,
          transition: 'width 0.5s',
          borderRadius: '8px'
        }
      })), React.createElement("div", {
        style: {
          marginTop: '8px',
          fontSize: '0.75rem',
          color: COLORS.textMuted,
          textAlign: 'right'
        }
      }, "Total: ", unlockedAchievements.length, " / ", ACHIEVEMENTS_DATA.length));
    })(), (() => {
      const activeChallenge = getActiveTimeLimitedAchievement();
      if (!activeChallenge) return null;
      const current = weeklyChallenge.stats[activeChallenge.statKey] || 0;
      const progress = Math.min(current / activeChallenge.target, 1);
      const isCompleted = weeklyChallenge.completed;
      return React.createElement("div", {
        style: {
          background: `linear-gradient(135deg, ${COLORS.backgroundCard}, rgba(155, 89, 182, 0.1))`,
          borderRadius: '12px',
          padding: '24px',
          marginBottom: '32px',
          border: `1px solid ${isCompleted ? '#27ae60' : '#9b59b6'}40`,
          position: 'relative',
          overflow: 'hidden'
        }
      }, React.createElement("div", {
        style: {
          position: 'absolute',
          top: '16px',
          right: '16px',
          background: 'rgba(155, 89, 182, 0.2)',
          borderRadius: '20px',
          padding: '6px 12px',
          display: 'flex',
          alignItems: 'center',
          gap: '6px'
        }
      }, React.createElement("span", {
        style: {
          fontSize: '0.75rem',
          color: '#9b59b6'
        }
      }, "Ends in"), React.createElement("span", {
        style: {
          fontSize: '0.85rem',
          fontWeight: '600',
          color: COLORS.text
        }
      }, formatTimeRemaining(timeUntilReset))), React.createElement("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          gap: '8px',
          marginBottom: '8px'
        }
      }, React.createElement("span", {
        style: {
          fontSize: '0.7rem',
          fontWeight: '600',
          textTransform: 'uppercase',
          letterSpacing: '1px',
          color: '#9b59b6'
        }
      }, "Weekly Challenge"), isCompleted && React.createElement("span", {
        style: {
          fontSize: '0.7rem',
          fontWeight: '600',
          color: '#27ae60',
          background: 'rgba(39, 174, 96, 0.2)',
          padding: '2px 8px',
          borderRadius: '4px'
        }
      }, "Completed!")), React.createElement("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          gap: '16px',
          marginBottom: '16px'
        }
      }, React.createElement("div", {
        style: {
          fontSize: '40px',
          background: isCompleted ? 'rgba(39, 174, 96, 0.2)' : 'rgba(155, 89, 182, 0.2)',
          borderRadius: '12px',
          padding: '12px',
          filter: isCompleted ? 'none' : 'none'
        }
      }, isCompleted ? 'âœ…' : activeChallenge.icon), React.createElement("div", null, React.createElement("h3", {
        style: {
          color: COLORS.text,
          fontSize: '1.25rem',
          fontWeight: '600',
          margin: 0
        }
      }, activeChallenge.name), React.createElement("p", {
        style: {
          color: COLORS.textMuted,
          fontSize: '0.9rem',
          margin: '4px 0 0 0'
        }
      }, activeChallenge.description))), React.createElement("div", {
        style: {
          marginBottom: '12px'
        }
      }, React.createElement("div", {
        style: {
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: '8px'
        }
      }, React.createElement("span", {
        style: {
          color: COLORS.textMuted,
          fontSize: '0.85rem'
        }
      }, current, " / ", activeChallenge.target), React.createElement("span", {
        style: {
          color: isCompleted ? '#27ae60' : '#9b59b6',
          fontSize: '0.85rem',
          fontWeight: '600'
        }
      }, Math.round(progress * 100), "%")), React.createElement("div", {
        style: {
          background: 'rgba(255, 255, 255, 0.1)',
          borderRadius: '6px',
          height: '10px',
          overflow: 'hidden'
        }
      }, React.createElement("div", {
        style: {
          background: isCompleted ? 'linear-gradient(90deg, #27ae60, #2ecc71)' : 'linear-gradient(90deg, #9b59b6, #8e44ad)',
          height: '100%',
          width: `${progress * 100}%`,
          borderRadius: '6px',
          transition: 'width 0.5s ease'
        }
      }))), React.createElement("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          gap: '8px'
        }
      }, React.createElement("span", {
        style: {
          color: COLORS.textMuted,
          fontSize: '0.8rem'
        }
      }, "Reward:"), React.createElement("span", {
        style: {
          color: '#f39c12',
          fontSize: '0.8rem',
          fontWeight: '600'
        }
      }, activeChallenge.reward)));
    })(), React.createElement("div", {
      style: {
        background: COLORS.backgroundCard,
        borderRadius: '12px',
        padding: '24px',
        marginBottom: '32px',
        border: `1px solid ${COLORS.accent}30`
      }
    }, React.createElement("div", {
      style: {
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: '16px'
      }
    }, React.createElement("div", null, React.createElement("h2", {
      style: {
        color: COLORS.text,
        fontSize: '1.25rem',
        fontWeight: '600',
        margin: 0
      }
    }, "Daily Challenges"), React.createElement("p", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.85rem',
        margin: '4px 0 0 0'
      }
    }, "Complete challenges to earn rewards. Resets at midnight.")), React.createElement("div", {
      style: {
        background: `${COLORS.accent}20`,
        borderRadius: '8px',
        padding: '8px 12px',
        color: COLORS.accent,
        fontSize: '0.85rem',
        fontWeight: '600'
      }
    }, dailyChallengeData.completedChallenges.length, " / ", dailyChallengeData.challenges.length, " Complete")), React.createElement("div", {
      style: {
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))',
        gap: '12px'
      }
    }, dailyChallengeData.challenges.map(challenge => {
      const isCompleted = dailyChallengeData.completedChallenges.includes(challenge.id);
      const current = dailyChallengeData.stats[challenge.statKey] || 0;
      const progress = Math.min(current / challenge.target, 1);
      return React.createElement("div", {
        key: challenge.id,
        style: {
          background: isCompleted ? `${COLORS.success}15` : 'rgba(255, 255, 255, 0.03)',
          borderRadius: '10px',
          padding: '16px',
          border: isCompleted ? `1px solid ${COLORS.success}40` : '1px solid rgba(255, 255, 255, 0.05)'
        }
      }, React.createElement("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          gap: '12px',
          marginBottom: '12px'
        }
      }, React.createElement("div", {
        style: {
          fontSize: '24px',
          background: isCompleted ? `${COLORS.success}20` : 'rgba(255, 255, 255, 0.05)',
          borderRadius: '8px',
          padding: '8px'
        }
      }, isCompleted ? 'âœ…' : challenge.icon), React.createElement("div", {
        style: {
          flex: 1
        }
      }, React.createElement("div", {
        style: {
          color: COLORS.text,
          fontSize: '0.95rem',
          fontWeight: '600'
        }
      }, challenge.name), React.createElement("div", {
        style: {
          color: COLORS.textMuted,
          fontSize: '0.8rem'
        }
      }, challenge.description)), React.createElement("span", {
        style: {
          fontSize: '0.65rem',
          fontWeight: '600',
          textTransform: 'uppercase',
          color: DIFFICULTY_COLORS[challenge.difficulty],
          background: `${DIFFICULTY_COLORS[challenge.difficulty]}20`,
          padding: '4px 8px',
          borderRadius: '4px'
        }
      }, challenge.difficulty)), React.createElement("div", {
        style: {
          marginBottom: '8px'
        }
      }, React.createElement("div", {
        style: {
          background: 'rgba(255, 255, 255, 0.1)',
          borderRadius: '4px',
          height: '6px',
          overflow: 'hidden'
        }
      }, React.createElement("div", {
        style: {
          background: isCompleted ? COLORS.success : `linear-gradient(90deg, ${DIFFICULTY_COLORS[challenge.difficulty]}, ${DIFFICULTY_COLORS[challenge.difficulty]}aa)`,
          height: '100%',
          width: `${progress * 100}%`,
          borderRadius: '4px'
        }
      }))), React.createElement("div", {
        style: {
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center'
        }
      }, React.createElement("span", {
        style: {
          color: COLORS.textMuted,
          fontSize: '0.75rem'
        }
      }, current, " / ", challenge.target), isCompleted && React.createElement("span", {
        style: {
          color: COLORS.success,
          fontSize: '0.75rem',
          fontWeight: '600'
        }
      }, "Complete!")));
    }))), (() => {
      const almostThereAchievements = ACHIEVEMENTS_DATA.filter(a => a.mode === achievementTab).filter(achievement => {
        if (unlockedAchievements.includes(achievement.id)) return false;
        const progress = getAchievementProgress(achievement, achievementStats);
        return progress && progress.progress >= 0.7 && progress.progress < 1;
      });
      if (almostThereAchievements.length === 0) return null;
      return React.createElement("div", {
        style: {
          marginBottom: '32px'
        }
      }, React.createElement("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          gap: '10px',
          marginBottom: '16px'
        }
      }, React.createElement("span", {
        style: {
          fontSize: '1.25rem'
        }
      }, "\uD83D\uDD25"), React.createElement("h2", {
        style: {
          color: COLORS.accent,
          fontSize: '1.1rem',
          fontWeight: '600',
          margin: 0
        }
      }, "Almost There!")), React.createElement("div", {
        style: {
          display: 'grid',
          gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))',
          gap: '12px'
        }
      }, almostThereAchievements.map(achievement => {
        const progressData = getAchievementProgress(achievement, achievementStats);
        const remaining = progressData.target - progressData.current;
        return React.createElement("div", {
          key: `almost-${achievement.id}`,
          style: {
            background: `linear-gradient(135deg, ${COLORS.backgroundCard}, ${COLORS.accent}10)`,
            border: `1px solid ${COLORS.accent}40`,
            borderRadius: '12px',
            padding: '16px',
            animation: 'almostTherePulse 2s ease-in-out infinite'
          }
        }, React.createElement("div", {
          style: {
            display: 'flex',
            alignItems: 'center',
            gap: '12px'
          }
        }, React.createElement("div", {
          style: {
            fontSize: '28px'
          }
        }, achievement.icon), React.createElement("div", {
          style: {
            flex: 1
          }
        }, React.createElement("div", {
          style: {
            color: COLORS.text,
            fontSize: '0.95rem',
            fontWeight: '600',
            marginBottom: '4px'
          }
        }, achievement.name), React.createElement("div", {
          style: {
            color: COLORS.accent,
            fontSize: '0.8rem',
            fontWeight: '500'
          }
        }, progressData.isThreshold ? `Need ${progressData.target}+ (Current best: ${progressData.current})` : `Only ${remaining} more to go!`), React.createElement("div", {
          style: {
            background: 'rgba(255, 255, 255, 0.1)',
            borderRadius: '3px',
            height: '4px',
            marginTop: '8px',
            overflow: 'hidden'
          }
        }, React.createElement("div", {
          style: {
            background: `linear-gradient(90deg, ${COLORS.accent}, ${COLORS.accentLight})`,
            height: '100%',
            width: `${progressData.progress * 100}%`,
            borderRadius: '3px'
          }
        }))), React.createElement("div", {
          style: {
            color: COLORS.accent,
            fontSize: '1.1rem',
            fontWeight: '700'
          }
        }, Math.round(progressData.progress * 100), "%")));
      })));
    })(), React.createElement("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        gap: '10px',
        marginBottom: '16px'
      }
    }, React.createElement("span", {
      style: {
        fontSize: '1.25rem'
      }
    }, achievementTab === 'offline' ? 'ðŸŽ®' : 'ðŸŒ'), React.createElement("h2", {
      style: {
        color: COLORS.text,
        fontSize: '1.1rem',
        fontWeight: '600',
        margin: 0
      }
    }, achievementTab === 'offline' ? 'Offline Achievements' : 'Online Achievements')), React.createElement("div", {
      style: {
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))',
        gap: '16px'
      }
    }, ACHIEVEMENTS_DATA.filter(a => a.mode === achievementTab).map(achievement => {
      const isUnlocked = unlockedAchievements.includes(achievement.id);
      const progressData = !isUnlocked ? getAchievementProgress(achievement, achievementStats) : null;
      const rarityStyle = getRarityCardStyle(achievement.rarity, isUnlocked);
      return React.createElement("div", {
        key: achievement.id,
        style: {
          background: COLORS.backgroundCard,
          border: '1px solid rgba(255, 255, 255, 0.05)',
          borderRadius: '12px',
          padding: '20px',
          opacity: isUnlocked ? 1 : progressData && progressData.progress > 0 ? 0.8 : 0.6,
          transition: 'all 0.3s ease',
          position: 'relative',
          overflow: 'hidden',
          ...rarityStyle
        }
      }, React.createElement("div", {
        style: {
          display: 'flex',
          alignItems: 'flex-start',
          gap: '16px'
        }
      }, React.createElement("div", {
        style: {
          fontSize: '32px',
          filter: isUnlocked ? 'none' : 'grayscale(100%)',
          background: isUnlocked ? `${getRarityColor(achievement.rarity)}20` : 'rgba(255, 255, 255, 0.05)',
          borderRadius: '10px',
          padding: '10px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }
      }, achievement.icon), React.createElement("div", {
        style: {
          flex: 1
        }
      }, React.createElement("div", {
        style: {
          color: isUnlocked ? COLORS.text : COLORS.textMuted,
          fontSize: '1rem',
          fontWeight: '600',
          marginBottom: '4px'
        }
      }, achievement.name), React.createElement("div", {
        style: {
          color: isUnlocked ? COLORS.textMuted : 'rgba(139, 148, 158, 0.6)',
          fontSize: '0.85rem',
          marginBottom: '12px',
          lineHeight: '1.4'
        }
      }, achievement.description), !isUnlocked && progressData && React.createElement("div", {
        style: {
          marginBottom: '12px'
        }
      }, React.createElement("div", {
        style: {
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: '6px'
        }
      }, React.createElement("span", {
        style: {
          color: progressData.progress >= 0.7 ? COLORS.accent : COLORS.textMuted,
          fontSize: '0.75rem',
          fontWeight: '600'
        }
      }, progressData.isThreshold ? `Best: ${progressData.current}` : `${progressData.current} / ${progressData.target}`), React.createElement("span", {
        style: {
          color: progressData.progress >= 0.7 ? COLORS.accent : COLORS.textMuted,
          fontSize: '0.75rem'
        }
      }, Math.round(progressData.progress * 100), "%")), React.createElement("div", {
        style: {
          background: 'rgba(255, 255, 255, 0.1)',
          borderRadius: '4px',
          height: '6px',
          overflow: 'hidden'
        }
      }, React.createElement("div", {
        style: {
          background: progressData.progress >= 0.7 ? `linear-gradient(90deg, ${COLORS.accent}, ${COLORS.accentLight})` : 'linear-gradient(90deg, #4a5568, #718096)',
          height: '100%',
          width: `${progressData.progress * 100}%`,
          borderRadius: '4px',
          transition: 'width 0.5s ease'
        }
      }))), React.createElement("div", {
        style: {
          display: 'flex',
          gap: '8px',
          alignItems: 'center',
          flexWrap: 'wrap'
        }
      }, React.createElement("span", {
        style: {
          color: isUnlocked ? getRarityColor(achievement.rarity) : COLORS.textMuted,
          fontSize: '0.7rem',
          fontWeight: '600',
          textTransform: 'uppercase',
          letterSpacing: '0.5px',
          background: isUnlocked ? `${getRarityColor(achievement.rarity)}20` : 'rgba(255, 255, 255, 0.05)',
          borderRadius: '4px',
          padding: '4px 8px'
        }
      }, achievement.rarity), React.createElement("span", {
        style: {
          color: achievement.mode === 'online' ? '#60a5fa' : COLORS.accent,
          fontSize: '0.7rem',
          fontWeight: '600',
          textTransform: 'uppercase',
          letterSpacing: '0.5px',
          background: achievement.mode === 'online' ? 'rgba(96, 165, 250, 0.15)' : `${COLORS.accent}20`,
          borderRadius: '4px',
          padding: '4px 8px'
        }
      }, achievement.mode === 'online' ? 'Online' : 'Offline'), isUnlocked ? React.createElement("span", {
        style: {
          color: COLORS.success,
          fontSize: '0.7rem',
          fontWeight: '600',
          background: 'rgba(45, 138, 45, 0.15)',
          borderRadius: '4px',
          padding: '4px 8px',
          marginLeft: 'auto'
        }
      }, "Unlocked") : React.createElement("span", {
        style: {
          color: COLORS.textMuted,
          fontSize: '0.7rem',
          fontWeight: '600',
          background: 'rgba(255, 255, 255, 0.05)',
          borderRadius: '4px',
          padding: '4px 8px',
          marginLeft: 'auto'
        }
      }, "Locked")))));
    }))));
  }
  const Navigation = ({
    onNavigate,
    currentPage
  }) => React.createElement("nav", {
    className: "nav",
    role: "navigation",
    "aria-label": "Main navigation"
  }, React.createElement("div", {
    className: "nav-container"
  }, React.createElement("a", {
    href: "#",
    className: "nav-logo",
    onClick: e => {
      e.preventDefault();
      onNavigate('landing');
    }
  }, "QUIK DARTS"), React.createElement("ul", {
    className: "nav-links"
  }, React.createElement("li", null, React.createElement("a", {
    href: "#",
    className: "nav-link",
    onClick: e => {
      e.preventDefault();
      onNavigate('landing');
    }
  }, "Home")), React.createElement("li", null, React.createElement("a", {
    href: "#",
    className: "nav-link",
    onClick: e => {
      e.preventDefault();
      onNavigate('menu');
    }
  }, "Play")), React.createElement("li", null, React.createElement("a", {
    href: "#",
    className: "nav-link",
    onClick: e => {
      e.preventDefault();
      enterPracticeMode();
    }
  }, "Practice")), React.createElement("li", null, React.createElement("a", {
    href: "#",
    className: "nav-link",
    onClick: e => {
      e.preventDefault();
      setShowAchievements(true);
    }
  }, "Achievements")), React.createElement("li", null, React.createElement("a", {
    href: "#",
    className: "nav-link",
    onClick: e => {
      e.preventDefault();
      onNavigate('howToPlay');
    }
  }, "How to Play")), React.createElement("li", null, React.createElement("button", {
    className: "nav-cta",
    onClick: () => onNavigate('menu')
  }, "Play Now")), currentUser && !currentUser.isAnonymous && React.createElement("li", {
    style: {
      display: 'flex',
      alignItems: 'center',
      gap: '8px'
    }
  }, React.createElement("div", {
    style: {
      display: 'flex',
      alignItems: 'center',
      gap: '6px',
      background: 'rgba(212, 160, 58, 0.15)',
      padding: '6px 12px',
      borderRadius: '20px',
      border: '1px solid rgba(212, 160, 58, 0.3)'
    }
  }, React.createElement(CoinIcon, {
    size: 16
  }), React.createElement("span", {
    style: {
      color: '#D4A03A',
      fontWeight: '600',
      fontSize: '14px'
    }
  }, formatCoins(coinBalance))), dailyBonusAvailable && React.createElement("button", {
    onClick: claimDailyBonus,
    disabled: isClaimingBonus,
    style: {
      background: 'linear-gradient(135deg, #2D8A2D, #1B6B1B)',
      border: 'none',
      color: 'white',
      padding: '6px 12px',
      borderRadius: '20px',
      cursor: isClaimingBonus ? 'wait' : 'pointer',
      fontSize: '12px',
      fontWeight: '600',
      opacity: isClaimingBonus ? 0.7 : 1,
      transition: 'all 0.2s ease'
    }
  }, isClaimingBonus ? '...' : '+50 Free!'), adsRemainingToday > 0 && React.createElement("button", {
    onClick: watchAdForCoins,
    disabled: isWatchingAd,
    title: `Watch ad for +25 coins (${adsRemainingToday}/5 remaining)`,
    style: {
      background: 'linear-gradient(135deg, #D4A03A, #B8862E)',
      border: 'none',
      color: '#0D1117',
      padding: '6px 10px',
      borderRadius: '20px',
      cursor: isWatchingAd ? 'wait' : 'pointer',
      fontSize: '12px',
      fontWeight: '600',
      opacity: isWatchingAd ? 0.7 : 1,
      transition: 'all 0.2s ease',
      display: 'flex',
      alignItems: 'center',
      gap: '4px'
    }
  }, React.createElement("span", {
    style: {
      fontSize: '14px'
    }
  }, "\u25B6"), isWatchingAd ? '...' : '+25'), React.createElement("button", {
    onClick: () => setShowCoinShop(true),
    title: "Buy coins",
    style: {
      background: 'linear-gradient(135deg, #D4A03A, #B8862E)',
      border: 'none',
      color: '#0D1117',
      width: '28px',
      height: '28px',
      borderRadius: '50%',
      cursor: 'pointer',
      fontSize: '16px',
      fontWeight: '700',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      transition: 'all 0.2s ease'
    }
  }, "+")), React.createElement("li", null, currentUser && !currentUser.isAnonymous ? React.createElement("div", {
    style: {
      display: 'flex',
      alignItems: 'center',
      gap: '12px'
    }
  }, React.createElement("button", {
    onClick: () => setShowProfileScreen(true),
    style: {
      background: 'none',
      border: 'none',
      padding: 0,
      cursor: 'pointer'
    },
    title: "View Profile"
  }, currentUser.photoURL ? React.createElement("img", {
    src: currentUser.photoURL,
    alt: currentUser.displayName || 'Profile',
    style: {
      width: '36px',
      height: '36px',
      borderRadius: '50%',
      border: `2px solid ${COLORS.accent}`
    },
    referrerPolicy: "no-referrer",
    onError: e => {
      e.target.style.display = 'none';
      e.target.nextSibling.style.display = 'flex';
    }
  }) : null, React.createElement("div", {
    style: {
      width: '36px',
      height: '36px',
      borderRadius: '50%',
      background: `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})`,
      display: currentUser.photoURL ? 'none' : 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      color: COLORS.textDark,
      fontWeight: '700',
      fontSize: '16px',
      border: `2px solid ${COLORS.accentLight}`
    }
  }, (currentUser.displayName || currentUser.email || 'U')[0].toUpperCase())), React.createElement("button", {
    onClick: handleSignOut,
    style: {
      background: 'none',
      border: '1px solid rgba(255,255,255,0.2)',
      color: COLORS.textMuted,
      padding: '6px 12px',
      borderRadius: '6px',
      cursor: 'pointer',
      fontSize: '0.8rem',
      fontFamily: 'var(--font-primary)'
    }
  }, "Sign Out")) : React.createElement("button", {
    onClick: () => setShowLoginModal(true),
    style: {
      background: 'none',
      border: '1px solid rgba(255,255,255,0.3)',
      color: COLORS.text,
      padding: '8px 16px',
      borderRadius: '6px',
      cursor: 'pointer',
      fontSize: '0.9rem',
      fontWeight: '500',
      fontFamily: 'var(--font-primary)'
    }
  }, "Login"))), React.createElement("button", {
    className: "nav-hamburger",
    onClick: () => setMobileMenuOpen(!mobileMenuOpen),
    "aria-label": "Toggle menu",
    "aria-expanded": mobileMenuOpen
  }, mobileMenuOpen ? React.createElement(CloseIcon, null) : React.createElement(MenuIcon, null))), React.createElement("div", {
    className: `nav-mobile ${mobileMenuOpen ? 'open' : ''}`
  }, React.createElement("ul", {
    className: "nav-mobile-links"
  }, React.createElement("li", null, React.createElement("a", {
    href: "#",
    className: "nav-link",
    onClick: e => {
      e.preventDefault();
      onNavigate('landing');
      setMobileMenuOpen(false);
    }
  }, "Home")), React.createElement("li", null, React.createElement("a", {
    href: "#",
    className: "nav-link",
    onClick: e => {
      e.preventDefault();
      onNavigate('menu');
      setMobileMenuOpen(false);
    }
  }, "Play")), React.createElement("li", null, React.createElement("a", {
    href: "#",
    className: "nav-link",
    onClick: e => {
      e.preventDefault();
      onNavigate('howToPlay');
      setMobileMenuOpen(false);
    }
  }, "How to Play")), React.createElement("li", null, React.createElement("a", {
    href: "#",
    className: "nav-link",
    onClick: e => {
      e.preventDefault();
      setShowAchievements(true);
      setMobileMenuOpen(false);
    }
  }, "Achievements")), React.createElement("li", null, React.createElement("button", {
    className: "btn btn-primary",
    style: {
      width: '100%',
      marginTop: '8px'
    },
    onClick: () => {
      onNavigate('menu');
      setMobileMenuOpen(false);
    }
  }, "Play Now")), React.createElement("li", null, currentUser && !currentUser.isAnonymous ? React.createElement("div", {
    style: {
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'space-between',
      marginTop: '12px',
      padding: '12px',
      background: 'rgba(255,255,255,0.05)',
      borderRadius: '8px'
    }
  }, React.createElement("div", {
    style: {
      display: 'flex',
      alignItems: 'center',
      gap: '10px'
    }
  }, currentUser.photoURL ? React.createElement("img", {
    src: currentUser.photoURL,
    alt: "",
    style: {
      width: '36px',
      height: '36px',
      borderRadius: '50%'
    }
  }) : React.createElement("div", {
    style: {
      width: '36px',
      height: '36px',
      borderRadius: '50%',
      background: COLORS.accent,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      color: COLORS.textDark,
      fontWeight: '600'
    }
  }, (currentUser.displayName || currentUser.email || 'U')[0].toUpperCase()), React.createElement("span", {
    style: {
      color: COLORS.text,
      fontSize: '0.9rem'
    }
  }, currentUser.displayName || currentUser.email || 'User')), React.createElement("button", {
    onClick: () => {
      handleSignOut();
      setMobileMenuOpen(false);
    },
    style: {
      background: 'none',
      border: '1px solid rgba(255,255,255,0.2)',
      color: COLORS.textMuted,
      padding: '6px 12px',
      borderRadius: '6px',
      cursor: 'pointer',
      fontSize: '0.8rem',
      fontFamily: 'var(--font-primary)'
    }
  }, "Sign Out")) : React.createElement("button", {
    onClick: () => {
      setShowLoginModal(true);
      setMobileMenuOpen(false);
    },
    className: "btn btn-secondary",
    style: {
      width: '100%',
      marginTop: '8px'
    }
  }, "Login")))));
  const WageredMatchHeader = ({
    pot,
    player1,
    player2,
    phase,
    winnerUid,
    isWagered,
    currentUserId
  }) => {
    if (!isWagered) return null;
    const [showWinAnimation, setShowWinAnimation] = useState(false);
    const [animationDirection, setAnimationDirection] = useState(0);
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const userWon = winnerUid && winnerUid === currentUserId;
    useEffect(() => {
      if (phase === 'end' && winnerUid) {
        const winnerIsPlayer1 = winnerUid === player1?.uid;
        setAnimationDirection(winnerIsPlayer1 ? -150 : 150);
        setShowWinAnimation(true);
      }
    }, [phase, winnerUid, player1]);
    const getInitials = name => {
      if (!name) return '?';
      return name.slice(0, 2).toUpperCase();
    };
    const truncateName = name => {
      if (!name) return 'Player';
      return name.length > 14 ? name.slice(0, 14) + 'â€¦' : name;
    };
    const PlayerCard = ({
      player,
      isLeft
    }) => {
      const isLoading = !player?.name;
      const isMobile = window.innerWidth < 768;
      if (isLoading) {
        return React.createElement("div", {
          style: {
            display: 'flex',
            alignItems: 'center',
            gap: isMobile ? '8px' : '12px',
            flexDirection: isLeft ? 'row' : 'row-reverse',
            maxWidth: isMobile ? '140px' : '200px'
          }
        }, React.createElement("div", {
          style: {
            width: isMobile ? '36px' : '44px',
            height: isMobile ? '36px' : '44px',
            borderRadius: '50%',
            background: 'rgba(255,255,255,0.1)',
            animation: 'skeletonPulse 1.5s ease-in-out infinite',
            flexShrink: 0
          }
        }), React.createElement("div", {
          style: {
            overflow: 'hidden'
          }
        }, React.createElement("div", {
          style: {
            width: '70px',
            height: '14px',
            background: 'rgba(255,255,255,0.1)',
            borderRadius: '4px',
            marginBottom: '4px'
          }
        }), React.createElement("div", {
          style: {
            width: '50px',
            height: '10px',
            background: 'rgba(255,255,255,0.05)',
            borderRadius: '4px'
          }
        })));
      }
      return React.createElement("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          gap: isMobile ? '8px' : '12px',
          flexDirection: isLeft ? 'row' : 'row-reverse',
          maxWidth: isMobile ? '140px' : '200px'
        }
      }, React.createElement("div", {
        style: {
          width: isMobile ? '36px' : '44px',
          height: isMobile ? '36px' : '44px',
          borderRadius: '50%',
          background: player.avatarUrl ? `url(${player.avatarUrl}) center/cover` : `linear-gradient(135deg, ${COLORS.primary}, ${COLORS.primaryLight})`,
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          color: COLORS.text,
          fontWeight: '700',
          fontSize: isMobile ? '12px' : '14px',
          border: `2px solid ${COLORS.accent}40`,
          flexShrink: 0
        }
      }, !player.avatarUrl && getInitials(player.name)), React.createElement("div", {
        style: {
          textAlign: isLeft ? 'left' : 'right',
          overflow: 'hidden',
          minWidth: 0
        }
      }, React.createElement("div", {
        style: {
          display: 'flex',
          alignItems: 'center',
          gap: '6px',
          flexDirection: isLeft ? 'row' : 'row-reverse'
        }
      }, React.createElement("span", {
        style: {
          color: COLORS.text,
          fontSize: isMobile ? '13px' : '15px',
          fontWeight: '600',
          whiteSpace: 'nowrap',
          overflow: 'hidden',
          textOverflow: 'ellipsis',
          maxWidth: isMobile ? '80px' : '100px'
        }
      }, truncateName(player.name)), React.createElement("span", {
        style: {
          background: 'linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 180, 0, 0.15))',
          color: '#FFD700',
          fontSize: isMobile ? '9px' : '10px',
          fontWeight: '700',
          padding: '2px 6px',
          borderRadius: '8px',
          border: '1px solid rgba(255, 215, 0, 0.2)',
          flexShrink: 0
        }
      }, "Lv.", player.level || '?')), React.createElement("div", {
        style: {
          color: COLORS.textMuted,
          fontSize: isMobile ? '10px' : '11px',
          marginTop: '3px',
          display: 'flex',
          alignItems: 'center',
          gap: '4px',
          justifyContent: isLeft ? 'flex-start' : 'flex-end'
        }
      }, React.createElement(CoinIcon, {
        size: isMobile ? 10 : 11
      }), React.createElement("span", {
        style: {
          fontWeight: '600'
        }
      }, formatCompactNumber(player.stake || 0)))));
    };
    return React.createElement("div", {
      style: {
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        height: window.innerWidth < 768 ? '70px' : '76px',
        background: `linear-gradient(180deg, ${COLORS.background} 0%, ${COLORS.backgroundLight} 100%)`,
        borderBottom: `1px solid ${COLORS.accent}30`,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        padding: '0 24px',
        paddingTop: 'env(safe-area-inset-top)',
        zIndex: 1000,
        boxSizing: 'border-box'
      }
    }, React.createElement(PlayerCard, {
      player: player1,
      isLeft: true
    }), React.createElement("div", {
      style: {
        position: 'absolute',
        left: '50%',
        top: '50%',
        transform: `translate(-50%, -50%) ${showWinAnimation && !prefersReducedMotion ? `translateX(${animationDirection}px)` : ''}`,
        transition: showWinAnimation ? 'transform 900ms cubic-bezier(0.4, 0, 0.2, 1)' : 'none',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        animation: phase === 'prematch' ? 'potPulse 650ms cubic-bezier(0.34, 1.56, 0.64, 1), potGlow 650ms ease-out' : 'none',
        zIndex: 10
      }
    }, React.createElement("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        gap: '10px',
        background: 'linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 180, 0, 0.15) 100%)',
        padding: '10px 20px',
        borderRadius: '24px',
        border: '1px solid rgba(255, 215, 0, 0.3)',
        boxShadow: phase === 'inmatch' ? '0 0 20px rgba(255, 215, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.1)' : '0 0 30px rgba(255, 215, 0, 0.6), 0 4px 20px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1)'
      }
    }, React.createElement(CoinIcon, {
      size: 28
    }), React.createElement("span", {
      style: {
        color: '#FFD700',
        fontSize: '24px',
        fontWeight: '700',
        fontFamily: "'Roboto Mono', monospace",
        textShadow: '0 0 15px rgba(255, 215, 0, 0.6), 0 2px 4px rgba(0, 0, 0, 0.3)'
      }
    }, formatCompactNumber(pot || 0))), React.createElement("span", {
      style: {
        color: '#FFD700',
        fontSize: '9px',
        fontWeight: '700',
        letterSpacing: '2px',
        marginTop: '4px',
        textShadow: '0 0 8px rgba(255, 215, 0, 0.4)'
      }
    }, "PRIZE POT"), showWinAnimation && userWon && React.createElement("div", {
      style: {
        position: 'absolute',
        top: '100%',
        marginTop: '8px',
        color: COLORS.success,
        fontSize: '16px',
        fontWeight: '700',
        animation: prefersReducedMotion ? 'none' : 'wagerFadeInUp 400ms ease-out',
        opacity: 1
      }
    }, "+", formatCompactNumber(pot))), React.createElement(PlayerCard, {
      player: player2,
      isLeft: false
    }));
  };
  const Footer = ({
    onNavigate
  }) => React.createElement("footer", {
    className: "footer",
    role: "contentinfo"
  }, React.createElement("div", {
    className: "footer-container"
  }, React.createElement("div", {
    className: "footer-content"
  }, React.createElement("div", {
    className: "footer-brand"
  }, React.createElement("h3", null, "Quik Darts"), React.createElement("p", null, "Championship-style online darts.", React.createElement("br", null), "Play anywhere, anytime.")), React.createElement("div", {
    className: "footer-links"
  }, React.createElement("div", {
    className: "footer-links-group"
  }, React.createElement("h4", null, "Play"), React.createElement("ul", null, React.createElement("li", null, React.createElement("a", {
    href: "#",
    onClick: e => {
      e.preventDefault();
      onNavigate('menu');
    }
  }, "Start Game")), React.createElement("li", null, React.createElement("a", {
    href: "#",
    onClick: e => {
      e.preventDefault();
      onNavigate('menu');
    }
  }, "Practice Mode")), React.createElement("li", null, React.createElement("a", {
    href: "#",
    onClick: e => {
      e.preventDefault();
      onNavigate('menu');
    }
  }, "Online Match")))), React.createElement("div", {
    className: "footer-links-group"
  }, React.createElement("h4", null, "Learn"), React.createElement("ul", null, React.createElement("li", null, React.createElement("a", {
    href: "#",
    onClick: e => {
      e.preventDefault();
      onNavigate('howToPlay');
    }
  }, "How to Play")), React.createElement("li", null, React.createElement("a", {
    href: "#",
    onClick: e => {
      e.preventDefault();
      onNavigate('howToPlay');
    }
  }, "Scoring Rules")), React.createElement("li", null, React.createElement("a", {
    href: "#",
    onClick: e => {
      e.preventDefault();
      onNavigate('howToPlay');
    }
  }, "Tips & Strategy")))))), React.createElement("div", {
    className: "footer-bottom"
  }, React.createElement("p", null, "Made with ", React.createElement("span", {
    role: "img",
    "aria-label": "dart"
  }, "\uD83C\uDFAF"), " | v1.0 Championship Edition"))));
  if (gameState === 'landing') {
    return React.createElement("div", {
      style: {
        minHeight: '100vh',
        background: COLORS.background
      }
    }, React.createElement(Navigation, {
      onNavigate: setGameState,
      currentPage: "landing"
    }), React.createElement("section", {
      style: {
        minHeight: '100vh',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        padding: '100px 24px 60px',
        position: 'relative',
        overflow: 'hidden'
      }
    }, React.createElement("div", {
      style: {
        position: 'absolute',
        inset: 0,
        background: `radial-gradient(ellipse at 30% 20%, ${COLORS.primary}40 0%, transparent 50%), radial-gradient(ellipse at 70% 80%, ${COLORS.accent}20 0%, transparent 40%), linear-gradient(180deg, ${COLORS.background} 0%, ${COLORS.backgroundLight} 100%)`,
        zIndex: 0
      }
    }), React.createElement("div", {
      style: {
        maxWidth: '1200px',
        width: '100%',
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))',
        gap: '60px',
        alignItems: 'center',
        zIndex: 2,
        position: 'relative'
      }
    }, React.createElement("div", {
      className: "animate-fade-in"
    }, React.createElement("div", {
      style: {
        display: 'inline-block',
        background: `${COLORS.accent}20`,
        color: COLORS.accent,
        padding: '8px 16px',
        borderRadius: '20px',
        fontSize: '0.85rem',
        fontWeight: '600',
        marginBottom: '24px'
      }
    }, "No Download Required"), React.createElement("h1", {
      style: {
        color: COLORS.text,
        marginBottom: '16px',
        fontWeight: '800'
      }
    }, "Quik Darts", React.createElement("span", {
      style: {
        display: 'block',
        color: COLORS.accent,
        fontSize: '0.5em',
        fontWeight: '600',
        letterSpacing: '3px',
        marginTop: '8px'
      }
    }, "CHAMPIONSHIP EDITION")), React.createElement("p", {
      style: {
        color: COLORS.textMuted,
        fontSize: '1.25rem',
        marginBottom: '32px',
        maxWidth: '500px',
        lineHeight: '1.7'
      }
    }, "Championship-style online darts. Play solo, challenge friends, or compete online. Experience realistic 501 gameplay right in your browser.")), React.createElement("div", {
      className: "animate-fade-in animate-delay-2",
      style: {
        background: COLORS.backgroundCard,
        borderRadius: '16px',
        padding: '32px',
        border: '1px solid rgba(255, 255, 255, 0.05)',
        boxShadow: '0 25px 60px rgba(0, 0, 0, 0.5)',
        width: '100%',
        maxWidth: '420px'
      }
    }, React.createElement("div", {
      style: {
        display: 'grid',
        gridTemplateColumns: 'repeat(2, 1fr)',
        gap: '12px',
        marginBottom: '24px'
      }
    }, React.createElement("button", {
      className: "btn btn-primary",
      onClick: startGame,
      style: {
        padding: '20px 16px',
        fontSize: '0.95rem',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '8px',
        borderRadius: '12px',
        minHeight: '90px'
      }
    }, React.createElement(DartIcon, {
      size: 24,
      color: COLORS.textDark
    }), "Start Game"), React.createElement("button", {
      className: "btn btn-secondary",
      onClick: handlePlayOnlineClick,
      style: {
        padding: '20px 16px',
        fontSize: '0.95rem',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '8px',
        borderRadius: '12px',
        minHeight: '90px'
      }
    }, React.createElement(GlobeIcon, {
      size: 24,
      color: COLORS.text
    }), "Play Online"), React.createElement("button", {
      className: "btn btn-ghost",
      onClick: enterPracticeMode,
      style: {
        padding: '20px 16px',
        fontSize: '0.95rem',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '8px',
        borderRadius: '12px',
        minHeight: '90px'
      }
    }, React.createElement(TargetIcon, {
      size: 24,
      color: COLORS.text
    }), "Practice Mode"), React.createElement("button", {
      className: "btn btn-ghost",
      onClick: () => setShowAchievements(true),
      style: {
        padding: '20px 16px',
        fontSize: '0.95rem',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '8px',
        borderRadius: '12px',
        minHeight: '90px',
        color: COLORS.accent,
        borderColor: `${COLORS.accent}40`
      }
    }, React.createElement(TrophyIcon, {
      size: 24,
      color: COLORS.accent
    }), "Achievements")), React.createElement("div", {
      style: {
        height: '1px',
        background: `linear-gradient(90deg, transparent, ${COLORS.accent}30, transparent)`,
        marginBottom: '24px'
      }
    }), React.createElement("div", {
      style: {
        marginBottom: '20px'
      }
    }, React.createElement("label", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.75rem',
        letterSpacing: '2px',
        display: 'block',
        marginBottom: '10px',
        fontWeight: '600',
        textTransform: 'uppercase'
      }
    }, "Game Mode"), React.createElement("div", {
      style: {
        display: 'flex',
        gap: '8px'
      }
    }, [301, 501].map(mode => React.createElement("button", {
      key: mode,
      onClick: () => setPlayerSetup(prev => ({
        ...prev,
        gameMode: mode
      })),
      style: {
        flex: 1,
        padding: '12px',
        fontSize: '1rem',
        fontWeight: '600',
        background: playerSetup.gameMode === mode ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})` : 'rgba(255, 255, 255, 0.03)',
        color: playerSetup.gameMode === mode ? COLORS.textDark : COLORS.textMuted,
        border: playerSetup.gameMode === mode ? 'none' : '1px solid rgba(255, 255, 255, 0.08)',
        borderRadius: '6px',
        cursor: 'pointer'
      }
    }, mode)))), React.createElement("div", {
      style: {
        marginBottom: '20px'
      }
    }, React.createElement("label", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.75rem',
        letterSpacing: '2px',
        display: 'block',
        marginBottom: '10px',
        fontWeight: '600',
        textTransform: 'uppercase'
      }
    }, "Legs Per Set"), React.createElement("div", {
      style: {
        display: 'flex',
        gap: '8px'
      }
    }, [1, 3, 5, 7].map(legs => React.createElement("button", {
      key: legs,
      onClick: () => setPlayerSetup(prev => ({
        ...prev,
        legsPerSet: legs
      })),
      style: {
        flex: 1,
        padding: '12px',
        fontSize: '1rem',
        fontWeight: '600',
        background: playerSetup.legsPerSet === legs ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})` : 'rgba(255, 255, 255, 0.03)',
        color: playerSetup.legsPerSet === legs ? COLORS.textDark : COLORS.textMuted,
        border: playerSetup.legsPerSet === legs ? 'none' : '1px solid rgba(255, 255, 255, 0.08)',
        borderRadius: '6px',
        cursor: 'pointer'
      }
    }, legs)))), React.createElement("div", {
      style: {
        marginBottom: '20px'
      }
    }, React.createElement("label", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.75rem',
        letterSpacing: '2px',
        display: 'block',
        marginBottom: '10px',
        fontWeight: '600',
        textTransform: 'uppercase'
      }
    }, "Sets To Win"), React.createElement("div", {
      style: {
        display: 'flex',
        gap: '8px'
      }
    }, [1, 3, 5, 7].map(sets => React.createElement("button", {
      key: sets,
      onClick: () => setPlayerSetup(prev => ({
        ...prev,
        setsToWin: sets
      })),
      style: {
        flex: 1,
        padding: '12px',
        fontSize: '1rem',
        fontWeight: '600',
        background: playerSetup.setsToWin === sets ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})` : 'rgba(255, 255, 255, 0.03)',
        color: playerSetup.setsToWin === sets ? COLORS.textDark : COLORS.textMuted,
        border: playerSetup.setsToWin === sets ? 'none' : '1px solid rgba(255, 255, 255, 0.08)',
        borderRadius: '6px',
        cursor: 'pointer'
      }
    }, sets)))), React.createElement("div", {
      style: {
        marginBottom: '20px'
      }
    }, React.createElement("label", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.75rem',
        letterSpacing: '2px',
        display: 'block',
        marginBottom: '10px',
        fontWeight: '600',
        textTransform: 'uppercase'
      }
    }, "Players"), React.createElement("div", {
      style: {
        display: 'flex',
        gap: '8px'
      }
    }, [1, 2, 3, 4].map(num => React.createElement("button", {
      key: num,
      onClick: () => setPlayerSetup(prev => ({
        ...prev,
        count: num
      })),
      style: {
        flex: 1,
        padding: '12px',
        fontSize: '1rem',
        fontWeight: '600',
        background: playerSetup.count === num ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})` : 'rgba(255, 255, 255, 0.03)',
        color: playerSetup.count === num ? COLORS.textDark : COLORS.textMuted,
        border: playerSetup.count === num ? 'none' : '1px solid rgba(255, 255, 255, 0.08)',
        borderRadius: '6px',
        cursor: 'pointer'
      }
    }, num)))), Array.from({
      length: playerSetup.count
    }).map((_, i) => React.createElement("div", {
      key: i,
      style: {
        marginBottom: '12px',
        background: 'rgba(0, 0, 0, 0.3)',
        padding: '14px',
        borderRadius: '8px',
        border: '1px solid rgba(255, 255, 255, 0.05)'
      }
    }, React.createElement("input", {
      type: "text",
      id: `local-player-name-${i}`,
      name: `local-player-name-${i}`,
      "aria-label": `Player ${i + 1} name`,
      value: playerSetup.names[i],
      onChange: e => {
        const newNames = [...playerSetup.names];
        newNames[i] = sanitizeName(e.target.value);
        setPlayerSetup(prev => ({
          ...prev,
          names: newNames
        }));
      },
      placeholder: `Player ${i + 1}`,
      maxLength: 20,
      style: {
        width: '100%',
        padding: '11px 14px',
        fontSize: '14px',
        background: 'rgba(255, 255, 255, 0.05)',
        border: '1px solid rgba(255, 255, 255, 0.1)',
        borderRadius: '6px',
        color: 'rgba(255, 255, 255, 0.9)',
        outline: 'none',
        boxSizing: 'border-box',
        marginBottom: '10px'
      }
    }), React.createElement("div", null, React.createElement("label", {
      htmlFor: `local-player-flag-${i}`,
      style: {
        color: 'rgba(255, 255, 255, 0.4)',
        fontSize: '10px',
        letterSpacing: '2px',
        display: 'block',
        marginBottom: '6px'
      }
    }, "NATIONALITY"), React.createElement("select", {
      id: `local-player-flag-${i}`,
      name: `local-player-flag-${i}`,
      value: playerSetup.flags[i],
      onChange: e => {
        const newFlags = [...playerSetup.flags];
        newFlags[i] = e.target.value;
        setPlayerSetup(prev => ({
          ...prev,
          flags: newFlags
        }));
      },
      style: {
        width: '100%',
        padding: '10px 12px',
        fontSize: '14px',
        background: 'rgba(255, 255, 255, 0.05)',
        border: '1px solid rgba(255, 255, 255, 0.1)',
        borderRadius: '6px',
        color: 'rgba(255, 255, 255, 0.9)',
        outline: 'none',
        cursor: 'pointer',
        boxSizing: 'border-box'
      }
    }, COUNTRIES.map(country => React.createElement("option", {
      key: country.name,
      value: country.flag,
      style: {
        background: '#1a1a1a',
        color: '#fff'
      }
    }, country.flag, " ", country.name)))), i > 0 && playerSetup.count > 1 && React.createElement(React.Fragment, null, React.createElement("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        marginTop: '10px',
        marginBottom: playerSetup.aiPlayers[i] ? '10px' : '0'
      }
    }, React.createElement("span", {
      style: {
        color: 'rgba(255, 255, 255, 0.4)',
        fontSize: '10px',
        letterSpacing: '2px'
      }
    }, "AI OPPONENT"), React.createElement("button", {
      onClick: () => {
        const newAiPlayers = [...playerSetup.aiPlayers];
        newAiPlayers[i] = !newAiPlayers[i];
        const newAiDifficulty = [...playerSetup.aiDifficulty];
        if (newAiPlayers[i] && !newAiDifficulty[i]) newAiDifficulty[i] = AI_DIFFICULTIES.INTERMEDIATE.key;
        setPlayerSetup(prev => ({
          ...prev,
          aiPlayers: newAiPlayers,
          aiDifficulty: newAiDifficulty
        }));
      },
      style: {
        padding: '5px 14px',
        background: playerSetup.aiPlayers[i] ? 'linear-gradient(180deg, #2d8a2d, #1f6b1f)' : 'rgba(255, 255, 255, 0.05)',
        color: playerSetup.aiPlayers[i] ? '#fff' : 'rgba(255, 255, 255, 0.4)',
        border: playerSetup.aiPlayers[i] ? 'none' : '1px solid rgba(255, 255, 255, 0.1)',
        borderRadius: '4px',
        cursor: 'pointer',
        fontSize: '11px',
        fontWeight: '600',
        letterSpacing: '1px'
      }
    }, playerSetup.aiPlayers[i] ? 'ON' : 'OFF')), playerSetup.aiPlayers[i] && React.createElement("div", null, React.createElement("label", {
      style: {
        color: 'rgba(255, 255, 255, 0.4)',
        fontSize: '10px',
        letterSpacing: '2px',
        display: 'block',
        marginBottom: '6px'
      }
    }, "DIFFICULTY"), React.createElement("div", {
      style: {
        display: 'grid',
        gridTemplateColumns: 'repeat(4, 1fr)',
        gap: '5px'
      }
    }, Object.values(AI_DIFFICULTIES).map(d => React.createElement("button", {
      key: d.key,
      onClick: () => {
        const newAiDifficulty = [...playerSetup.aiDifficulty];
        newAiDifficulty[i] = d.key;
        setPlayerSetup(prev => ({
          ...prev,
          aiDifficulty: newAiDifficulty
        }));
      },
      style: {
        padding: '7px 4px',
        fontSize: '10px',
        fontWeight: '600',
        background: playerSetup.aiDifficulty[i] === d.key ? 'linear-gradient(180deg, #c9a227 0%, #a68b1f 100%)' : 'rgba(255, 255, 255, 0.03)',
        color: playerSetup.aiDifficulty[i] === d.key ? '#0a0a0f' : 'rgba(255, 255, 255, 0.4)',
        border: playerSetup.aiDifficulty[i] === d.key ? 'none' : '1px solid rgba(255, 255, 255, 0.08)',
        borderRadius: '4px',
        cursor: 'pointer',
        textTransform: 'uppercase',
        letterSpacing: '0.5px'
      }
    }, d.label.slice(0, 3).toUpperCase()))))))), React.createElement("div", {
      style: {
        height: '1px',
        background: `linear-gradient(90deg, transparent, ${COLORS.accent}30, transparent)`,
        margin: '20px 0'
      }
    }), React.createElement("div", {
      style: {
        marginBottom: '20px'
      }
    }, React.createElement("label", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.75rem',
        letterSpacing: '2px',
        display: 'block',
        marginBottom: '10px',
        fontWeight: '600',
        textTransform: 'uppercase'
      }
    }, "Skill Level"), React.createElement("div", {
      style: {
        display: 'grid',
        gridTemplateColumns: '1fr 1fr 1fr',
        gap: '8px'
      }
    }, React.createElement("button", {
      onClick: () => setSkillLevel(30),
      style: {
        padding: '12px 8px',
        background: skillLevel <= 40 ? 'linear-gradient(135deg, #2d8a2d, #1f6b1f)' : 'rgba(255, 255, 255, 0.03)',
        color: skillLevel <= 40 ? '#fff' : COLORS.textMuted,
        border: skillLevel <= 40 ? 'none' : '1px solid rgba(255, 255, 255, 0.08)',
        borderRadius: '6px',
        cursor: 'pointer',
        fontSize: '0.75rem',
        fontWeight: '600'
      }
    }, React.createElement("div", {
      style: {
        width: '8px',
        height: '8px',
        borderRadius: '50%',
        background: skillLevel <= 40 ? '#90EE90' : 'rgba(144, 238, 144, 0.4)',
        margin: '0 auto 6px'
      }
    }), "BEGINNER"), React.createElement("button", {
      onClick: () => setSkillLevel(60),
      style: {
        padding: '12px 8px',
        background: skillLevel >= 41 && skillLevel <= 80 ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})` : 'rgba(255, 255, 255, 0.03)',
        color: skillLevel >= 41 && skillLevel <= 80 ? COLORS.textDark : COLORS.textMuted,
        border: skillLevel >= 41 && skillLevel <= 80 ? 'none' : '1px solid rgba(255, 255, 255, 0.08)',
        borderRadius: '6px',
        cursor: 'pointer',
        fontSize: '0.75rem',
        fontWeight: '600'
      }
    }, React.createElement("div", {
      style: {
        width: '8px',
        height: '8px',
        borderRadius: '50%',
        background: skillLevel >= 41 && skillLevel <= 80 ? COLORS.textDark : 'rgba(255, 193, 7, 0.4)',
        margin: '0 auto 6px'
      }
    }), "INTERMEDIATE"), React.createElement("button", {
      onClick: () => setSkillLevel(90),
      style: {
        padding: '12px 8px',
        background: skillLevel >= 81 ? 'linear-gradient(135deg, #a61c1c, #8a1717)' : 'rgba(255, 255, 255, 0.03)',
        color: skillLevel >= 81 ? '#fff' : COLORS.textMuted,
        border: skillLevel >= 81 ? 'none' : '1px solid rgba(255, 255, 255, 0.08)',
        borderRadius: '6px',
        cursor: 'pointer',
        fontSize: '0.75rem',
        fontWeight: '600'
      }
    }, React.createElement("div", {
      style: {
        width: '8px',
        height: '8px',
        borderRadius: '50%',
        background: skillLevel >= 81 ? '#ff6b6b' : 'rgba(255, 107, 107, 0.4)',
        margin: '0 auto 6px'
      }
    }), "EXPERT"))), React.createElement("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        padding: '12px 0'
      }
    }, React.createElement("span", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.75rem',
        letterSpacing: '2px',
        fontWeight: '600'
      }
    }, "SOUND"), React.createElement("button", {
      onClick: () => setSoundEnabled(!soundEnabled),
      style: {
        padding: '6px 16px',
        background: soundEnabled ? 'linear-gradient(135deg, #2d8a2d, #1f6b1f)' : 'rgba(255, 255, 255, 0.05)',
        color: soundEnabled ? '#fff' : COLORS.textMuted,
        border: soundEnabled ? 'none' : '1px solid rgba(255, 255, 255, 0.1)',
        borderRadius: '4px',
        cursor: 'pointer',
        fontSize: '0.75rem',
        fontWeight: '600'
      }
    }, soundEnabled ? 'ON' : 'OFF'))))), React.createElement("section", {
      style: {
        padding: '80px 24px',
        background: COLORS.backgroundLight
      }
    }, React.createElement("div", {
      style: {
        maxWidth: '1200px',
        margin: '0 auto'
      }
    }, React.createElement("h2", {
      style: {
        textAlign: 'center',
        color: COLORS.text,
        marginBottom: '16px'
      }
    }, "Why Play Quik Darts?"), React.createElement("p", {
      style: {
        textAlign: 'center',
        color: COLORS.textMuted,
        marginBottom: '48px',
        maxWidth: '600px',
        margin: '0 auto 48px'
      }
    }, "Experience the thrill of competitive darts with features designed for players of all skill levels."), React.createElement("div", {
      style: {
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))',
        gap: '24px'
      }
    }, [{
      icon: React.createElement(TargetIcon, {
        size: 32,
        color: COLORS.accent
      }),
      title: 'Realistic Gameplay',
      desc: 'Authentic 501 rules with double-out finish. Power meter and aim wobble simulate real darts.'
    }, {
      icon: React.createElement(GlobeIcon, {
        size: 32,
        color: COLORS.accent
      }),
      title: 'Play Online',
      desc: 'Challenge players worldwide in real-time matches. No account required to get started.'
    }, {
      icon: React.createElement(UsersIcon, {
        size: 32,
        color: COLORS.accent
      }),
      title: 'Local Multiplayer',
      desc: 'Play with up to 4 players on the same device. Perfect for game night with friends.'
    }, {
      icon: React.createElement(TrophyIcon, {
        size: 32,
        color: COLORS.accent
      }),
      title: 'Track Progress',
      desc: 'Earn achievements, track your stats, and climb the leaderboards.'
    }].map((feature, i) => React.createElement("div", {
      key: i,
      style: {
        background: COLORS.backgroundCard,
        padding: '32px',
        borderRadius: '12px',
        border: `1px solid rgba(255,255,255,0.05)`
      }
    }, React.createElement("div", {
      style: {
        marginBottom: '16px'
      }
    }, feature.icon), React.createElement("h3", {
      style: {
        color: COLORS.text,
        fontSize: '1.25rem',
        marginBottom: '8px'
      }
    }, feature.title), React.createElement("p", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.95rem',
        lineHeight: '1.6'
      }
    }, feature.desc)))))), React.createElement("section", {
      style: {
        padding: '80px 24px',
        background: COLORS.background,
        textAlign: 'center'
      }
    }, React.createElement("h2", {
      style: {
        color: COLORS.text,
        marginBottom: '16px'
      }
    }, "Ready to Play?"), React.createElement("p", {
      style: {
        color: COLORS.textMuted,
        marginBottom: '32px',
        maxWidth: '500px',
        margin: '0 auto 32px'
      }
    }, "Jump into a game now. No downloads, no sign-ups, just darts."), React.createElement("button", {
      className: "btn btn-primary",
      onClick: () => setGameState('menu'),
      style: {
        fontSize: '1.1rem',
        padding: '16px 40px'
      }
    }, React.createElement(PlayIcon, null), " Start Playing")), React.createElement(Footer, {
      onNavigate: setGameState
    }));
  }
  if (gameState === 'howToPlay') {
    return React.createElement("div", {
      style: {
        minHeight: '100vh',
        background: COLORS.background
      }
    }, React.createElement(Navigation, {
      onNavigate: setGameState,
      currentPage: "howToPlay"
    }), React.createElement("main", {
      style: {
        paddingTop: '100px',
        paddingBottom: '80px'
      }
    }, React.createElement("div", {
      style: {
        maxWidth: '800px',
        margin: '0 auto',
        padding: '0 24px'
      }
    }, React.createElement("h1", {
      style: {
        color: COLORS.text,
        marginBottom: '16px'
      }
    }, "How to Play"), React.createElement("p", {
      style: {
        color: COLORS.textMuted,
        fontSize: '1.1rem',
        marginBottom: '48px'
      }
    }, "Learn the basics of Quik Darts and become a champion."), React.createElement("section", {
      style: {
        marginBottom: '48px'
      }
    }, React.createElement("h2", {
      style: {
        color: COLORS.accent,
        fontSize: '1.5rem',
        marginBottom: '16px',
        display: 'flex',
        alignItems: 'center',
        gap: '12px'
      }
    }, React.createElement("span", {
      style: {
        background: COLORS.accent,
        color: COLORS.textDark,
        width: '32px',
        height: '32px',
        borderRadius: '50%',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        fontSize: '1rem',
        fontWeight: '700'
      }
    }, "1"), "Basic 501 Rules"), React.createElement("div", {
      style: {
        background: COLORS.backgroundCard,
        padding: '24px',
        borderRadius: '12px',
        border: '1px solid rgba(255,255,255,0.05)'
      }
    }, React.createElement("ul", {
      style: {
        color: COLORS.textMuted,
        lineHeight: '1.8',
        paddingLeft: '20px'
      }
    }, React.createElement("li", null, "Each player starts with ", React.createElement("strong", {
      style: {
        color: COLORS.text
      }
    }, "501 points")), React.createElement("li", null, "Throw 3 darts per turn to reduce your score"), React.createElement("li", null, "Score is subtracted from your total after each turn"), React.createElement("li", null, "You must finish exactly on ", React.createElement("strong", {
      style: {
        color: COLORS.text
      }
    }, "0 points")), React.createElement("li", null, "The final dart must land on a ", React.createElement("strong", {
      style: {
        color: COLORS.accent
      }
    }, "double"), " (outer ring) or the bullseye"), React.createElement("li", null, "If you go below 0 or hit exactly 1, your turn is \"bust\" and your score resets")))), React.createElement("section", {
      style: {
        marginBottom: '48px'
      }
    }, React.createElement("h2", {
      style: {
        color: COLORS.accent,
        fontSize: '1.5rem',
        marginBottom: '16px',
        display: 'flex',
        alignItems: 'center',
        gap: '12px'
      }
    }, React.createElement("span", {
      style: {
        background: COLORS.accent,
        color: COLORS.textDark,
        width: '32px',
        height: '32px',
        borderRadius: '50%',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        fontSize: '1rem',
        fontWeight: '700'
      }
    }, "2"), "Dartboard Scoring"), React.createElement("div", {
      style: {
        background: COLORS.backgroundCard,
        padding: '24px',
        borderRadius: '12px',
        border: '1px solid rgba(255,255,255,0.05)'
      }
    }, React.createElement("div", {
      style: {
        display: 'grid',
        gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))',
        gap: '16px'
      }
    }, React.createElement("div", {
      style: {
        padding: '16px',
        background: 'rgba(0,0,0,0.2)',
        borderRadius: '8px'
      }
    }, React.createElement("h4", {
      style: {
        color: COLORS.text,
        marginBottom: '8px'
      }
    }, "Single (Main Bed)"), React.createElement("p", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.9rem'
      }
    }, "Face value of the number (1-20)")), React.createElement("div", {
      style: {
        padding: '16px',
        background: 'rgba(0,0,0,0.2)',
        borderRadius: '8px'
      }
    }, React.createElement("h4", {
      style: {
        color: COLORS.text,
        marginBottom: '8px'
      }
    }, "Double (Outer Ring)"), React.createElement("p", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.9rem'
      }
    }, "2x the number value")), React.createElement("div", {
      style: {
        padding: '16px',
        background: 'rgba(0,0,0,0.2)',
        borderRadius: '8px'
      }
    }, React.createElement("h4", {
      style: {
        color: COLORS.text,
        marginBottom: '8px'
      }
    }, "Triple (Inner Ring)"), React.createElement("p", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.9rem'
      }
    }, "3x the number value")), React.createElement("div", {
      style: {
        padding: '16px',
        background: 'rgba(0,0,0,0.2)',
        borderRadius: '8px'
      }
    }, React.createElement("h4", {
      style: {
        color: COLORS.text,
        marginBottom: '8px'
      }
    }, "Bullseye"), React.createElement("p", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.9rem'
      }
    }, "Outer: 25 | Inner: 50 (double)"))))), React.createElement("section", {
      style: {
        marginBottom: '48px'
      }
    }, React.createElement("h2", {
      style: {
        color: COLORS.accent,
        fontSize: '1.5rem',
        marginBottom: '16px',
        display: 'flex',
        alignItems: 'center',
        gap: '12px'
      }
    }, React.createElement("span", {
      style: {
        background: COLORS.accent,
        color: COLORS.textDark,
        width: '32px',
        height: '32px',
        borderRadius: '50%',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        fontSize: '1rem',
        fontWeight: '700'
      }
    }, "3"), "How to Throw"), React.createElement("div", {
      style: {
        background: COLORS.backgroundCard,
        padding: '24px',
        borderRadius: '12px',
        border: '1px solid rgba(255,255,255,0.05)'
      }
    }, React.createElement("ol", {
      style: {
        color: COLORS.textMuted,
        lineHeight: '2',
        paddingLeft: '20px'
      }
    }, React.createElement("li", null, React.createElement("strong", {
      style: {
        color: COLORS.text
      }
    }, "Aim:"), " Move your mouse/finger to position your aim on the dartboard"), React.createElement("li", null, React.createElement("strong", {
      style: {
        color: COLORS.text
      }
    }, "Charge:"), " Press and hold the mouse button or tap and hold to charge power"), React.createElement("li", null, React.createElement("strong", {
      style: {
        color: COLORS.text
      }
    }, "Release:"), " Let go when the power meter is in the green zone (40-60%) for best accuracy"), React.createElement("li", null, React.createElement("strong", {
      style: {
        color: COLORS.text
      }
    }, "Wobble:"), " Your aim naturally wobbles - this simulates real throwing variance")), React.createElement("div", {
      style: {
        marginTop: '16px',
        padding: '16px',
        background: `${COLORS.accent}15`,
        borderRadius: '8px',
        borderLeft: `3px solid ${COLORS.accent}`
      }
    }, React.createElement("p", {
      style: {
        color: COLORS.text,
        fontSize: '0.9rem',
        margin: 0
      }
    }, React.createElement("strong", null, "Pro Tip:"), " Higher skill levels reduce wobble. Practice to improve your accuracy!")))), React.createElement("section", {
      style: {
        marginBottom: '48px'
      }
    }, React.createElement("h2", {
      style: {
        color: COLORS.accent,
        fontSize: '1.5rem',
        marginBottom: '16px',
        display: 'flex',
        alignItems: 'center',
        gap: '12px'
      }
    }, React.createElement("span", {
      style: {
        background: COLORS.accent,
        color: COLORS.textDark,
        width: '32px',
        height: '32px',
        borderRadius: '50%',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        fontSize: '1rem',
        fontWeight: '700'
      }
    }, "4"), "Game Modes"), React.createElement("div", {
      style: {
        display: 'grid',
        gap: '16px'
      }
    }, [{
      title: 'Local Play',
      desc: '1-4 players on the same device. Add AI opponents for extra challenge.'
    }, {
      title: 'Online Match',
      desc: 'Play against real opponents worldwide. Get matched instantly.'
    }, {
      title: 'Practice Mode',
      desc: 'Hone your skills with unlimited throws. No pressure, just practice.'
    }].map((mode, i) => React.createElement("div", {
      key: i,
      style: {
        background: COLORS.backgroundCard,
        padding: '20px',
        borderRadius: '12px',
        border: '1px solid rgba(255,255,255,0.05)'
      }
    }, React.createElement("h4", {
      style: {
        color: COLORS.text,
        marginBottom: '8px'
      }
    }, mode.title), React.createElement("p", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.95rem',
        margin: 0
      }
    }, mode.desc))))), React.createElement("div", {
      style: {
        textAlign: 'center',
        marginTop: '48px'
      }
    }, React.createElement("button", {
      className: "btn btn-primary",
      onClick: () => setGameState('menu'),
      style: {
        fontSize: '1.1rem',
        padding: '16px 40px'
      }
    }, React.createElement(PlayIcon, null), " Start Playing")))), React.createElement(Footer, {
      onNavigate: setGameState
    }));
  }
  if (gameState === 'menu') {
    return React.createElement("div", {
      style: {
        minHeight: '100vh',
        background: COLORS.background
      }
    }, React.createElement(Navigation, {
      onNavigate: setGameState,
      currentPage: "menu"
    }), React.createElement("main", {
      style: {
        minHeight: '100vh',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        padding: '100px 20px 40px',
        position: 'relative'
      }
    }, React.createElement("div", {
      style: {
        position: 'absolute',
        inset: 0,
        background: `radial-gradient(ellipse at 50% 0%, ${COLORS.primary}30 0%, transparent 50%), radial-gradient(ellipse at 80% 100%, ${COLORS.accent}15 0%, transparent 40%)`,
        zIndex: 0
      }
    }), React.createElement("div", {
      style: {
        position: 'absolute',
        right: '-150px',
        top: '50%',
        transform: 'translateY(-50%)',
        width: '500px',
        height: '500px',
        opacity: 0.03,
        zIndex: 1,
        background: 'radial-gradient(circle, #fff 0%, #fff 8%, transparent 8%, transparent 15%, #fff 15%, #fff 20%, transparent 20%, transparent 45%, #fff 45%, #fff 48%, transparent 48%, transparent 85%, #fff 85%, #fff 90%, transparent 90%)',
        borderRadius: '50%'
      }
    }), React.createElement("div", {
      style: {
        textAlign: 'center',
        marginBottom: '40px',
        zIndex: 2,
        position: 'relative'
      }
    }, React.createElement("h1", {
      style: {
        fontSize: 'clamp(36px, 10vw, 56px)',
        fontWeight: '800',
        margin: '0',
        color: COLORS.text
      }
    }, "Game Setup"), React.createElement("p", {
      style: {
        color: COLORS.textMuted,
        marginTop: '8px'
      }
    }, "Configure your match settings")), React.createElement("div", {
      style: {
        background: COLORS.backgroundCard,
        borderRadius: '16px',
        padding: '32px',
        border: '1px solid rgba(255, 255, 255, 0.05)',
        boxShadow: '0 25px 60px rgba(0, 0, 0, 0.5)',
        width: '100%',
        maxWidth: '480px',
        zIndex: 2,
        position: 'relative'
      }
    }, React.createElement("div", {
      style: {
        display: 'grid',
        gridTemplateColumns: 'repeat(2, 1fr)',
        gap: '12px',
        marginBottom: '24px'
      }
    }, React.createElement("button", {
      className: "btn btn-primary",
      onClick: startGame,
      style: {
        padding: '20px 16px',
        fontSize: '0.95rem',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '8px',
        borderRadius: '12px',
        minHeight: '90px'
      }
    }, React.createElement(DartIcon, {
      size: 24,
      color: COLORS.textDark
    }), "Start Game"), React.createElement("button", {
      className: "btn btn-secondary",
      onClick: handlePlayOnlineClick,
      style: {
        padding: '20px 16px',
        fontSize: '0.95rem',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '8px',
        borderRadius: '12px',
        minHeight: '90px'
      }
    }, React.createElement(GlobeIcon, {
      size: 24,
      color: COLORS.text
    }), "Play Online"), React.createElement("button", {
      className: "btn btn-ghost",
      onClick: enterPracticeMode,
      style: {
        padding: '20px 16px',
        fontSize: '0.95rem',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '8px',
        borderRadius: '12px',
        minHeight: '90px'
      }
    }, React.createElement(TargetIcon, {
      size: 24,
      color: COLORS.text
    }), "Practice Mode"), React.createElement("button", {
      className: "btn btn-ghost",
      onClick: () => setShowAchievements(true),
      style: {
        padding: '20px 16px',
        fontSize: '0.95rem',
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '8px',
        borderRadius: '12px',
        minHeight: '90px',
        color: COLORS.accent,
        borderColor: `${COLORS.accent}40`
      }
    }, React.createElement(TrophyIcon, {
      size: 24,
      color: COLORS.accent
    }), "Achievements")), React.createElement("div", {
      style: {
        height: '1px',
        background: `linear-gradient(90deg, transparent, ${COLORS.accent}30, transparent)`,
        marginBottom: '24px'
      }
    }), React.createElement("div", {
      style: {
        marginBottom: '20px'
      }
    }, React.createElement("label", {
      style: {
        color: COLORS.textMuted,
        fontSize: '0.75rem',
        letterSpacing: '2px',
        display: 'block',
        marginBottom: '10px',
        fontWeight: '600',
        textTransform: 'uppercase'
      }
    }, "Game Mode"), React.createElement("div", {
      style: {
        display: 'flex',
        gap: '8px'
      }
    }, [301, 501].map(mode => React.createElement("button", {
      key: mode,
      onClick: () => setPlayerSetup(prev => ({
        ...prev,
        gameMode: mode
      })),
      style: {
        flex: 1,
        padding: '12px',
        fontSize: '1rem',
        fontWeight: '600',
        background: playerSetup.gameMode === mode ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})` : 'rgba(255, 255, 255, 0.03)',
        color: playerSetup.gameMode === mode ? COLORS.textDark : COLORS.textMuted,
        border: playerSetup.gameMode === mode ? 'none' : '1px solid rgba(255, 255, 255, 0.08)',
        borderRadius: '6px',
        cursor: 'pointer',
        fontFamily: 'var(--font-primary)'
      }
    }, mode)))), React.createElement("div", {
      style: {
        marginBottom: '22px'
      }
    }, React.createElement("label", {
      style: {
        color: 'rgba(201, 162, 39, 0.8)',
        fontSize: '11px',
        letterSpacing: '3px',
        display: 'block',
        marginBottom: '10px',
        fontWeight: '500'
      }
    }, "LEGS PER SET"), React.createElement("div", {
      style: {
        display: 'flex',
        gap: '8px'
      }
    }, [1, 3, 5, 7].map(legs => React.createElement("button", {
      key: legs,
      onClick: () => setPlayerSetup(prev => ({
        ...prev,
        legsPerSet: legs
      })),
      style: {
        flex: 1,
        padding: '14px',
        fontSize: '18px',
        fontWeight: '600',
        background: playerSetup.legsPerSet === legs ? 'linear-gradient(180deg, #c9a227 0%, #a68b1f 100%)' : 'rgba(255, 255, 255, 0.03)',
        color: playerSetup.legsPerSet === legs ? '#0a0a0f' : 'rgba(255, 255, 255, 0.5)',
        border: playerSetup.legsPerSet === legs ? 'none' : '1px solid rgba(255, 255, 255, 0.08)',
        borderRadius: '6px',
        cursor: 'pointer',
        fontFamily: "'Oswald', sans-serif",
        boxShadow: playerSetup.legsPerSet === legs ? 'inset 0 1px 0 rgba(255, 255, 255, 0.3)' : 'none'
      }
    }, legs)))), React.createElement("div", {
      style: {
        marginBottom: '22px'
      }
    }, React.createElement("label", {
      style: {
        color: 'rgba(201, 162, 39, 0.8)',
        fontSize: '11px',
        letterSpacing: '3px',
        display: 'block',
        marginBottom: '10px',
        fontWeight: '500'
      }
    }, "SETS TO WIN"), React.createElement("div", {
      style: {
        display: 'flex',
        gap: '8px'
      }
    }, [1, 3, 5, 7].map(sets => React.createElement("button", {
      key: sets,
      onClick: () => setPlayerSetup(prev => ({
        ...prev,
        setsToWin: sets
      })),
      style: {
        flex: 1,
        padding: '14px',
        fontSize: '18px',
        fontWeight: '600',
        background: playerSetup.setsToWin === sets ? 'linear-gradient(180deg, #c9a227 0%, #a68b1f 100%)' : 'rgba(255, 255, 255, 0.03)',
        color: playerSetup.setsToWin === sets ? '#0a0a0f' : 'rgba(255, 255, 255, 0.5)',
        border: playerSetup.setsToWin === sets ? 'none' : '1px solid rgba(255, 255, 255, 0.08)',
        borderRadius: '6px',
        cursor: 'pointer',
        fontFamily: "'Oswald', sans-serif",
        boxShadow: playerSetup.setsToWin === sets ? 'inset 0 1px 0 rgba(255, 255, 255, 0.3)' : 'none'
      }
    }, sets)))), React.createElement("div", {
      style: {
        marginBottom: '22px'
      }
    }, React.createElement("label", {
      style: {
        color: 'rgba(201, 162, 39, 0.8)',
        fontSize: '11px',
        letterSpacing: '3px',
        display: 'block',
        marginBottom: '10px',
        fontWeight: '500'
      }
    }, "PLAYERS"), React.createElement("div", {
      style: {
        display: 'flex',
        gap: '8px'
      }
    }, [1, 2, 3, 4].map(num => React.createElement("button", {
      key: num,
      onClick: () => setPlayerSetup(prev => ({
        ...prev,
        count: num
      })),
      style: {
        flex: 1,
        padding: '14px',
        fontSize: '18px',
        fontWeight: '600',
        background: playerSetup.count === num ? 'linear-gradient(180deg, #c9a227 0%, #a68b1f 100%)' : 'rgba(255, 255, 255, 0.03)',
        color: playerSetup.count === num ? '#0a0a0f' : 'rgba(255, 255, 255, 0.5)',
        border: playerSetup.count === num ? 'none' : '1px solid rgba(255, 255, 255, 0.08)',
        borderRadius: '6px',
        cursor: 'pointer',
        fontFamily: "'Oswald', sans-serif",
        boxShadow: playerSetup.count === num ? 'inset 0 1px 0 rgba(255, 255, 255, 0.3)' : 'none'
      }
    }, num)))), Array.from({
      length: playerSetup.count
    }).map((_, i) => React.createElement("div", {
      key: i,
      style: {
        marginBottom: '12px',
        background: 'rgba(0, 0, 0, 0.3)',
        padding: '14px',
        borderRadius: '8px',
        border: '1px solid rgba(255, 255, 255, 0.05)'
      }
    }, React.createElement("input", {
      type: "text",
      id: `online-player-name-${i}`,
      name: `online-player-name-${i}`,
      "aria-label": `Player ${i + 1} name`,
      value: playerSetup.names[i],
      onChange: e => {
        const newNames = [...playerSetup.names];
        newNames[i] = sanitizeName(e.target.value);
        setPlayerSetup(prev => ({
          ...prev,
          names: newNames
        }));
      },
      placeholder: `Player ${i + 1}`,
      maxLength: 20,
      style: {
        width: '100%',
        padding: '11px 14px',
        fontSize: '14px',
        background: 'rgba(255, 255, 255, 0.05)',
        border: '1px solid rgba(255, 255, 255, 0.1)',
        borderRadius: '6px',
        color: 'rgba(255, 255, 255, 0.9)',
        outline: 'none',
        fontFamily: "'Roboto Mono', monospace",
        boxSizing: 'border-box',
        marginBottom: '10px'
      }
    }), React.createElement("div", {
      style: {
        marginBottom: '10px'
      }
    }, React.createElement("label", {
      htmlFor: `online-player-flag-${i}`,
      style: {
        color: 'rgba(255, 255, 255, 0.4)',
        fontSize: '10px',
        letterSpacing: '2px',
        display: 'block',
        marginBottom: '6px'
      }
    }, "NATIONALITY"), React.createElement("select", {
      id: `online-player-flag-${i}`,
      name: `online-player-flag-${i}`,
      value: playerSetup.flags[i],
      onChange: e => {
        const newFlags = [...playerSetup.flags];
        newFlags[i] = e.target.value;
        setPlayerSetup(prev => ({
          ...prev,
          flags: newFlags
        }));
      },
      style: {
        width: '100%',
        padding: '10px 12px',
        fontSize: '14px',
        background: 'rgba(255, 255, 255, 0.05)',
        border: '1px solid rgba(255, 255, 255, 0.1)',
        borderRadius: '6px',
        color: 'rgba(255, 255, 255, 0.9)',
        outline: 'none',
        fontFamily: "'Roboto Mono', monospace",
        cursor: 'pointer',
        boxSizing: 'border-box'
      }
    }, COUNTRIES.map(country => React.createElement("option", {
      key: country.name,
      value: country.flag,
      style: {
        background: '#1a1a1a',
        color: '#fff'
      }
    }, country.flag, " ", country.name)))), i > 0 && playerSetup.count > 1 && React.createElement(React.Fragment, null, React.createElement("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        marginBottom: playerSetup.aiPlayers[i] ? '10px' : '0'
      }
    }, React.createElement("span", {
      style: {
        color: 'rgba(255, 255, 255, 0.4)',
        fontSize: '10px',
        letterSpacing: '2px'
      }
    }, "AI OPPONENT"), React.createElement("button", {
      onClick: () => {
        const newAiPlayers = [...playerSetup.aiPlayers];
        newAiPlayers[i] = !newAiPlayers[i];
        const newAiDifficulty = [...playerSetup.aiDifficulty];
        if (newAiPlayers[i] && !newAiDifficulty[i]) newAiDifficulty[i] = AI_DIFFICULTIES.INTERMEDIATE.key;
        setPlayerSetup(prev => ({
          ...prev,
          aiPlayers: newAiPlayers,
          aiDifficulty: newAiDifficulty
        }));
      },
      style: {
        padding: '5px 14px',
        background: playerSetup.aiPlayers[i] ? 'linear-gradient(180deg, #2d8a2d, #1f6b1f)' : 'rgba(255, 255, 255, 0.05)',
        color: playerSetup.aiPlayers[i] ? '#fff' : 'rgba(255, 255, 255, 0.4)',
        border: playerSetup.aiPlayers[i] ? 'none' : '1px solid rgba(255, 255, 255, 0.1)',
        borderRadius: '4px',
        cursor: 'pointer',
        fontFamily: "'Oswald', sans-serif",
        fontSize: '11px',
        fontWeight: '600',
        letterSpacing: '1px'
      }
    }, playerSetup.aiPlayers[i] ? 'ON' : 'OFF')), playerSetup.aiPlayers[i] && React.createElement("div", null, React.createElement("label", {
      style: {
        color: 'rgba(255, 255, 255, 0.4)',
        fontSize: '10px',
        letterSpacing: '2px',
        display: 'block',
        marginBottom: '6px'
      }
    }, "DIFFICULTY"), React.createElement("div", {
      style: {
        display: 'grid',
        gridTemplateColumns: 'repeat(4, 1fr)',
        gap: '5px'
      }
    }, Object.values(AI_DIFFICULTIES).map(d => React.createElement("button", {
      key: d.key,
      onClick: () => {
        const newAiDifficulty = [...playerSetup.aiDifficulty];
        newAiDifficulty[i] = d.key;
        setPlayerSetup(prev => ({
          ...prev,
          aiDifficulty: newAiDifficulty
        }));
      },
      style: {
        padding: '7px 4px',
        fontSize: '10px',
        fontWeight: '600',
        background: playerSetup.aiDifficulty[i] === d.key ? 'linear-gradient(180deg, #c9a227 0%, #a68b1f 100%)' : 'rgba(255, 255, 255, 0.03)',
        color: playerSetup.aiDifficulty[i] === d.key ? '#0a0a0f' : 'rgba(255, 255, 255, 0.4)',
        border: playerSetup.aiDifficulty[i] === d.key ? 'none' : '1px solid rgba(255, 255, 255, 0.08)',
        borderRadius: '4px',
        cursor: 'pointer',
        fontFamily: "'Oswald', sans-serif",
        textTransform: 'uppercase',
        letterSpacing: '0.5px'
      }
    }, d.label.slice(0, 3).toUpperCase()))))))), React.createElement("div", {
      style: {
        height: '1px',
        background: 'linear-gradient(90deg, transparent, rgba(201, 162, 39, 0.2), transparent)',
        margin: '20px 0'
      }
    }), React.createElement("div", {
      style: {
        marginBottom: '20px'
      }
    }, React.createElement("label", {
      style: {
        color: 'rgba(201, 162, 39, 0.8)',
        fontSize: '11px',
        letterSpacing: '3px',
        display: 'block',
        marginBottom: '10px',
        fontWeight: '500'
      }
    }, "SKILL LEVEL"), React.createElement("div", {
      style: {
        display: 'grid',
        gridTemplateColumns: '1fr 1fr 1fr',
        gap: '8px'
      }
    }, React.createElement("button", {
      onClick: () => setSkillLevel(30),
      style: {
        padding: '14px 8px',
        background: skillLevel <= 40 ? 'linear-gradient(180deg, #2d8a2d, #1f6b1f)' : 'rgba(255, 255, 255, 0.03)',
        color: skillLevel <= 40 ? '#fff' : 'rgba(255, 255, 255, 0.5)',
        border: skillLevel <= 40 ? 'none' : '1px solid rgba(255, 255, 255, 0.08)',
        borderRadius: '6px',
        cursor: 'pointer',
        fontFamily: "'Oswald', sans-serif",
        fontSize: '12px',
        fontWeight: '600',
        letterSpacing: '1px',
        boxShadow: skillLevel <= 40 ? 'inset 0 1px 0 rgba(255, 255, 255, 0.2)' : 'none'
      }
    }, React.createElement("div", {
      style: {
        width: '8px',
        height: '8px',
        borderRadius: '50%',
        background: skillLevel <= 40 ? '#90EE90' : 'rgba(144, 238, 144, 0.4)',
        margin: '0 auto 6px'
      }
    }), "BEGINNER"), React.createElement("button", {
      onClick: () => setSkillLevel(60),
      style: {
        padding: '14px 8px',
        background: skillLevel >= 41 && skillLevel <= 80 ? 'linear-gradient(180deg, #c9a227, #a68b1f)' : 'rgba(255, 255, 255, 0.03)',
        color: skillLevel >= 41 && skillLevel <= 80 ? '#0a0a0f' : 'rgba(255, 255, 255, 0.5)',
        border: skillLevel >= 41 && skillLevel <= 80 ? 'none' : '1px solid rgba(255, 255, 255, 0.08)',
        borderRadius: '6px',
        cursor: 'pointer',
        fontFamily: "'Oswald', sans-serif",
        fontSize: '12px',
        fontWeight: '600',
        letterSpacing: '1px',
        boxShadow: skillLevel >= 41 && skillLevel <= 80 ? 'inset 0 1px 0 rgba(255, 255, 255, 0.3)' : 'none'
      }
    }, React.createElement("div", {
      style: {
        width: '8px',
        height: '8px',
        borderRadius: '50%',
        background: skillLevel >= 41 && skillLevel <= 80 ? '#0a0a0f' : 'rgba(255, 193, 7, 0.4)',
        margin: '0 auto 6px'
      }
    }), "INTERMEDIATE"), React.createElement("button", {
      onClick: () => setSkillLevel(90),
      style: {
        padding: '14px 8px',
        background: skillLevel >= 81 ? 'linear-gradient(180deg, #a61c1c, #8a1717)' : 'rgba(255, 255, 255, 0.03)',
        color: skillLevel >= 81 ? '#fff' : 'rgba(255, 255, 255, 0.5)',
        border: skillLevel >= 81 ? 'none' : '1px solid rgba(255, 255, 255, 0.08)',
        borderRadius: '6px',
        cursor: 'pointer',
        fontFamily: "'Oswald', sans-serif",
        fontSize: '12px',
        fontWeight: '600',
        letterSpacing: '1px',
        boxShadow: skillLevel >= 81 ? 'inset 0 1px 0 rgba(255, 255, 255, 0.2)' : 'none'
      }
    }, React.createElement("div", {
      style: {
        width: '8px',
        height: '8px',
        borderRadius: '50%',
        background: skillLevel >= 81 ? '#ff6b6b' : 'rgba(255, 107, 107, 0.4)',
        margin: '0 auto 6px'
      }
    }), "EXPERT"))), React.createElement("div", {
      style: {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        padding: '12px 0'
      }
    }, React.createElement("span", {
      style: {
        color: 'rgba(255, 255, 255, 0.5)',
        fontSize: '12px',
        letterSpacing: '2px'
      }
    }, "SOUND"), React.createElement("button", {
      onClick: () => setSoundEnabled(!soundEnabled),
      style: {
        padding: '6px 16px',
        background: soundEnabled ? 'linear-gradient(180deg, #2d8a2d, #1f6b1f)' : 'rgba(255, 255, 255, 0.05)',
        color: soundEnabled ? '#fff' : 'rgba(255, 255, 255, 0.4)',
        border: soundEnabled ? 'none' : '1px solid rgba(255, 255, 255, 0.1)',
        borderRadius: '4px',
        cursor: 'pointer',
        fontFamily: "'Oswald', sans-serif",
        fontSize: '12px',
        fontWeight: '600',
        letterSpacing: '1px'
      }
    }, soundEnabled ? 'ON' : 'OFF'))), React.createElement("p", {
      style: {
        color: COLORS.textMuted,
        marginTop: '24px',
        fontSize: '0.85rem',
        zIndex: 2,
        position: 'relative'
      }
    }, "Hold to charge power \u2022 Release to throw")), React.createElement(Footer, {
      onNavigate: setGameState
    }));
  }
  return React.createElement("div", {
    style: {
      minHeight: '100vh',
      background: COLORS.background,
      padding: '20px',
      paddingTop: onlineMode && isWageredMatch ? window.innerWidth < 768 ? '84px' : '92px' : '20px',
      fontFamily: "'Inter', sans-serif",
      position: 'relative'
    }
  }, onlineMode && isWageredMatch && React.createElement(WageredMatchHeader, {
    pot: escrowData?.totalPot || selectedStake * 2,
    player1: {
      uid: players[0]?.uid || '',
      name: players[0]?.name || '',
      level: players[0]?.level || userProgression?.level || 1,
      avatarUrl: players[0]?.avatarUrl,
      stake: selectedStake
    },
    player2: {
      uid: players[1]?.uid || '',
      name: players[1]?.name || opponentName || 'Opponent',
      level: players[1]?.level || 1,
      avatarUrl: players[1]?.avatarUrl,
      stake: selectedStake
    },
    phase: matchWinner ? 'end' : 'inmatch',
    winnerUid: matchWinner !== null ? matchWinner === 0 ? players[0]?.uid : players[1]?.uid : null,
    isWagered: isWageredMatch,
    currentUserId: currentUser?.uid
  }), React.createElement("div", {
    style: {
      position: 'absolute',
      inset: 0,
      background: `radial-gradient(ellipse at 30% 20%, ${COLORS.primary}40 0%, transparent 50%), radial-gradient(ellipse at 70% 80%, ${COLORS.accent}20 0%, transparent 40%)`,
      zIndex: 0,
      pointerEvents: 'none'
    }
  }), React.createElement("div", {
    className: "game-layout",
    style: {
      display: 'flex',
      flexWrap: 'wrap',
      gap: '30px',
      maxWidth: '1400px',
      margin: '0 auto',
      justifyContent: 'center',
      position: 'relative',
      zIndex: 1
    }
  }, React.createElement("div", {
    className: "game-scoreboard",
    style: {
      background: COLORS.backgroundCard,
      borderRadius: '16px',
      padding: '25px',
      minWidth: '280px',
      backdropFilter: 'blur(10px)',
      border: practiceMode === 'active' ? `1px solid ${COLORS.primary}50` : `1px solid ${COLORS.accent}30`
    }
  }, practiceMode === 'active' ? React.createElement(React.Fragment, null, React.createElement("h2", {
    style: {
      color: COLORS.primary,
      margin: '0 0 20px 0',
      letterSpacing: '2px',
      fontSize: '16px',
      fontWeight: '700',
      display: 'flex',
      alignItems: 'center',
      gap: '10px'
    }
  }, React.createElement("span", null, "\uD83C\uDFAF"), " PRACTICE MODE"), React.createElement("div", {
    style: {
      background: `${COLORS.primary}15`,
      borderRadius: '10px',
      padding: '15px',
      marginBottom: '20px',
      border: `1px solid ${COLORS.primary}30`
    }
  }, React.createElement("div", {
    style: {
      color: COLORS.textMuted,
      fontSize: '11px',
      letterSpacing: '1px',
      marginBottom: '5px'
    }
  }, "SKILL LEVEL"), React.createElement("div", {
    style: {
      color: COLORS.text,
      fontSize: '16px',
      fontWeight: '600'
    }
  }, practiceSkillLevel <= 40 && 'ðŸŸ¢ BEGINNER', practiceSkillLevel > 40 && practiceSkillLevel <= 80 && 'ðŸŸ¡ INTERMEDIATE', practiceSkillLevel > 80 && 'ðŸ”´ EXPERT')), React.createElement("div", {
    style: {
      background: 'rgba(255, 255, 255, 0.03)',
      borderRadius: '10px',
      padding: '15px',
      marginBottom: '15px',
      border: '1px solid rgba(255, 255, 255, 0.05)'
    }
  }, React.createElement("div", {
    style: {
      color: COLORS.accent,
      fontSize: '11px',
      letterSpacing: '2px',
      marginBottom: '10px',
      fontWeight: '600'
    }
  }, "SESSION STATS"), React.createElement("div", {
    style: {
      display: 'grid',
      gridTemplateColumns: '1fr 1fr',
      gap: '10px',
      fontSize: '14px'
    }
  }, React.createElement("div", null, React.createElement("div", {
    style: {
      color: COLORS.textMuted,
      fontSize: '11px'
    }
  }, "Darts Thrown"), React.createElement("div", {
    style: {
      fontSize: '20px',
      fontWeight: '600',
      color: COLORS.text
    }
  }, practiceStats.dartsThrown)), React.createElement("div", null, React.createElement("div", {
    style: {
      color: COLORS.textMuted,
      fontSize: '11px'
    }
  }, "Total Score"), React.createElement("div", {
    style: {
      fontSize: '20px',
      fontWeight: '600',
      color: COLORS.text
    }
  }, practiceStats.totalScore)), React.createElement("div", null, React.createElement("div", {
    style: {
      color: COLORS.textMuted,
      fontSize: '11px'
    }
  }, "Average"), React.createElement("div", {
    style: {
      fontSize: '20px',
      fontWeight: '600',
      color: COLORS.success
    }
  }, practiceStats.dartsThrown > 0 ? (practiceStats.totalScore / practiceStats.dartsThrown).toFixed(1) : '0.0')), React.createElement("div", null, React.createElement("div", {
    style: {
      color: COLORS.textMuted,
      fontSize: '11px'
    }
  }, "Bulls"), React.createElement("div", {
    style: {
      fontSize: '20px',
      fontWeight: '600',
      color: COLORS.error
    }
  }, practiceStats.bulls)))), React.createElement("div", {
    style: {
      background: 'rgba(255, 255, 255, 0.03)',
      borderRadius: '10px',
      padding: '15px',
      marginBottom: '20px',
      border: '1px solid rgba(255, 255, 255, 0.05)'
    }
  }, React.createElement("div", {
    style: {
      color: COLORS.accent,
      fontSize: '11px',
      letterSpacing: '2px',
      marginBottom: '10px',
      fontWeight: '600'
    }
  }, "ACCURACY"), React.createElement("div", {
    style: {
      display: 'grid',
      gridTemplateColumns: '1fr 1fr',
      gap: '10px',
      fontSize: '14px'
    }
  }, React.createElement("div", null, React.createElement("div", {
    style: {
      color: COLORS.textMuted,
      fontSize: '11px'
    }
  }, "Triples"), React.createElement("div", {
    style: {
      fontSize: '18px',
      fontWeight: '600',
      color: COLORS.text
    }
  }, practiceStats.triples)), React.createElement("div", null, React.createElement("div", {
    style: {
      color: COLORS.textMuted,
      fontSize: '11px'
    }
  }, "Doubles"), React.createElement("div", {
    style: {
      fontSize: '18px',
      fontWeight: '600',
      color: COLORS.text
    }
  }, practiceStats.doubles)), React.createElement("div", null, React.createElement("div", {
    style: {
      color: COLORS.textMuted,
      fontSize: '11px'
    }
  }, "T20"), React.createElement("div", {
    style: {
      fontSize: '18px',
      fontWeight: '600',
      color: COLORS.success
    }
  }, practiceStats.t20)), React.createElement("div", null, React.createElement("div", {
    style: {
      color: COLORS.textMuted,
      fontSize: '11px'
    }
  }, "T19"), React.createElement("div", {
    style: {
      fontSize: '18px',
      fontWeight: '600',
      color: COLORS.text
    }
  }, practiceStats.t19)))), React.createElement("button", {
    onClick: exitPracticeMode,
    style: {
      width: '100%',
      padding: '15px',
      background: `linear-gradient(135deg, ${COLORS.error}, #e74c3c)`,
      color: COLORS.text,
      border: 'none',
      borderRadius: '10px',
      fontSize: '14px',
      fontWeight: '600',
      cursor: 'pointer',
      fontFamily: "'Inter', sans-serif",
      letterSpacing: '1px',
      textTransform: 'uppercase'
    }
  }, "Exit Practice")) : React.createElement(React.Fragment, null, React.createElement("h2", {
    style: {
      color: COLORS.accent,
      margin: '0 0 20px 0',
      letterSpacing: '2px',
      fontSize: '16px',
      fontWeight: '700'
    }
  }, "SCOREBOARD"), players.map((player, index) => React.createElement("div", {
    key: index,
    style: {
      background: currentPlayerIndex === index ? `linear-gradient(135deg, ${COLORS.accent}20, ${COLORS.accent}10)` : 'rgba(255, 255, 255, 0.03)',
      borderRadius: '12px',
      padding: '20px',
      marginBottom: '15px',
      border: currentPlayerIndex === index ? `2px solid ${COLORS.accent}` : '1px solid rgba(255, 255, 255, 0.08)'
    }
  }, React.createElement("div", {
    style: {
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center',
      marginBottom: '5px'
    }
  }, React.createElement("div", {
    style: {
      display: 'flex',
      alignItems: 'center',
      gap: '8px'
    }
  }, React.createElement("span", {
    style: {
      fontSize: '20px'
    }
  }, player.flag), React.createElement("span", {
    style: {
      color: COLORS.text,
      fontSize: '15px',
      fontWeight: '500'
    }
  }, player.name), player.isAI && React.createElement("span", {
    style: {
      background: `${COLORS.primary}40`,
      color: COLORS.primaryLight,
      padding: '2px 8px',
      borderRadius: '10px',
      fontSize: '10px',
      fontWeight: '600',
      letterSpacing: '1px'
    }
  }, "AI")), currentPlayerIndex === index && React.createElement("span", {
    style: {
      color: COLORS.accent,
      fontSize: '11px',
      fontWeight: '600'
    }
  }, "\u25B6 THROWING")), player.isAI && React.createElement("div", {
    style: {
      fontSize: '10px',
      color: COLORS.primaryLight,
      marginBottom: '5px',
      textTransform: 'uppercase',
      fontWeight: '500'
    }
  }, player.aiDifficulty), React.createElement("div", {
    style: {
      fontSize: '48px',
      fontWeight: '700',
      color: player.score <= 170 ? COLORS.success : COLORS.text,
      textAlign: 'center',
      margin: '10px 0',
      fontFamily: "'Roboto Mono', monospace"
    }
  }, player.score), gameStats[index] && React.createElement("div", {
    style: {
      fontSize: '12px',
      color: COLORS.textMuted,
      textAlign: 'center'
    }
  }, "Avg: ", gameStats[index].averagePerSet, " (3-dart)"), (playerSetup.legsPerSet > 1 || playerSetup.setsToWin > 1) && React.createElement("div", {
    style: {
      fontSize: '11px',
      color: COLORS.accent,
      textAlign: 'center',
      marginTop: '8px',
      letterSpacing: '1px'
    }
  }, "Sets: ", setScores[index] || 0, " | Legs: ", legScores[index] || 0))), checkout && React.createElement("div", {
    style: {
      background: `linear-gradient(135deg, ${COLORS.success}20, ${COLORS.success}10)`,
      borderRadius: '10px',
      padding: '15px',
      marginTop: '20px',
      border: `1px solid ${COLORS.success}40`
    }
  }, React.createElement("div", {
    style: {
      color: COLORS.success,
      fontSize: '11px',
      letterSpacing: '2px',
      marginBottom: '5px',
      fontWeight: '600'
    }
  }, "CHECKOUT"), React.createElement("div", {
    style: {
      color: COLORS.text,
      fontSize: '18px',
      fontWeight: '600'
    }
  }, checkout)), onlineMode && React.createElement("div", {
    style: {
      marginTop: '20px',
      padding: '15px',
      background: `linear-gradient(135deg, ${COLORS.primary}30, ${COLORS.primary}20)`,
      borderRadius: '10px',
      border: `2px solid ${COLORS.primaryLight}`
    }
  }, React.createElement("div", {
    style: {
      color: COLORS.primaryLight,
      fontSize: '11px',
      fontWeight: '600',
      letterSpacing: '2px',
      marginBottom: '8px'
    }
  }, isWageredMatch ? 'ðŸ’° WAGERED MATCH' : 'ðŸŒ ONLINE MATCH'), React.createElement("div", {
    style: {
      color: currentPlayerIndex === playerId ? COLORS.success : COLORS.accent,
      fontSize: '15px',
      fontWeight: '700',
      letterSpacing: '1px'
    }
  }, currentPlayerIndex === playerId ? 'â–¶ YOUR TURN' : 'â¸ OPPONENT\'S TURN')), onlineMode && currentPlayerIndex === playerId && rhythmState !== 'neutral' && React.createElement("div", {
    className: "rhythm-indicator",
    style: {
      marginTop: '15px',
      padding: '12px 16px',
      borderRadius: '10px',
      textAlign: 'center',
      animation: 'rhythmPulse 0.5s ease-out',
      background: rhythmState === 'flow' ? 'rgba(255, 215, 0, 0.15)' : rhythmState === 'perfect' ? 'rgba(76, 175, 80, 0.15)' : 'rgba(255, 152, 0, 0.15)',
      border: `2px solid ${rhythmState === 'flow' ? '#FFD700' : rhythmState === 'perfect' ? '#4CAF50' : '#FF9800'}`
    }
  }, React.createElement("div", {
    style: {
      fontSize: '20px',
      marginBottom: '4px'
    }
  }, rhythmState === 'flow' ? 'ðŸ”¥' : rhythmState === 'perfect' ? 'ðŸŽ¯' : rhythmState === 'rushing' ? 'âš¡' : rhythmState === 'hesitating' ? 'â³' : ''), React.createElement("div", {
    style: {
      fontSize: '12px',
      fontWeight: '600',
      letterSpacing: '1px',
      color: rhythmState === 'flow' ? '#FFD700' : rhythmState === 'perfect' ? '#4CAF50' : '#FF9800'
    }
  }, rhythmState === 'flow' ? 'IN THE ZONE!' : rhythmState === 'perfect' ? 'PERFECT RHYTHM' : rhythmState === 'rushing' ? 'SLOW DOWN' : rhythmState === 'hesitating' ? 'KEEP MOVING' : '')), React.createElement("div", {
    style: {
      marginTop: '20px',
      padding: '15px',
      background: 'rgba(255, 255, 255, 0.03)',
      borderRadius: '10px',
      border: '1px solid rgba(255, 255, 255, 0.05)'
    }
  }, React.createElement("div", {
    style: {
      color: COLORS.textMuted,
      fontSize: '11px',
      marginBottom: '5px',
      letterSpacing: '1px'
    }
  }, "TURN SCORE"), React.createElement("div", {
    style: {
      color: scoreConfirming ? COLORS.textMuted : COLORS.accent,
      fontSize: '32px',
      fontWeight: '700',
      fontFamily: "'Roboto Mono', monospace",
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      gap: '10px'
    }
  }, currentTurnScore, scoreConfirming && React.createElement("span", {
    style: {
      fontSize: '12px',
      color: COLORS.primary,
      animation: 'confirmingPulse 1s ease-in-out infinite'
    }
  }, "\u23F3 Confirming...")), React.createElement("div", {
    style: {
      color: COLORS.textMuted,
      fontSize: '14px',
      marginTop: '5px'
    }
  }, "Darts: ", 'ðŸŽ¯'.repeat(dartsThrown), 'â—‹'.repeat(3 - dartsThrown))), React.createElement("div", {
    style: {
      marginTop: '20px',
      display: 'flex',
      gap: '10px'
    }
  }, React.createElement("button", {
    onClick: () => setShowStats(true),
    style: {
      flex: 1,
      padding: '12px',
      background: 'rgba(255, 255, 255, 0.05)',
      color: COLORS.text,
      border: '1px solid rgba(255, 255, 255, 0.1)',
      borderRadius: '10px',
      cursor: 'pointer',
      fontFamily: "'Inter', sans-serif",
      fontSize: '13px',
      fontWeight: '500'
    }
  }, "STATS"), React.createElement("button", {
    onClick: onlineMode ? handleLeaveClick : resetGame,
    style: {
      flex: 1,
      padding: '12px',
      background: `${COLORS.error}30`,
      color: COLORS.text,
      border: 'none',
      borderRadius: '10px',
      cursor: 'pointer',
      fontFamily: "'Inter', sans-serif",
      fontSize: '13px',
      fontWeight: '500'
    }
  }, onlineMode ? 'LEAVE' : 'MENU')))), React.createElement("div", {
    className: "game-dartboard",
    style: {
      display: 'flex',
      flexDirection: 'column',
      alignItems: 'center'
    }
  }, React.createElement("div", {
    ref: boardRef,
    onMouseMove: handleMouseMove,
    onMouseDown: handleMouseDown,
    onMouseUp: handleMouseUp,
    onMouseLeave: handleMouseUp,
    onTouchMove: handleTouchMove,
    onTouchStart: handleTouchStart,
    onTouchEnd: handleTouchEnd,
    onTouchCancel: handleTouchCancel,
    style: {
      width: `min(${BOARD_SIZE}px, 85vw)`,
      height: `min(${BOARD_SIZE}px, 85vw)`,
      borderRadius: '50%',
      cursor: isPowerCharging ? 'grabbing' : 'crosshair',
      boxShadow: '0 0 60px rgba(0, 0, 0, 0.8), inset 0 0 30px rgba(0, 0, 0, 0.5)',
      position: 'relative',
      userSelect: 'none'
    }
  }, React.createElement("svg", {
    viewBox: `0 0 ${BOARD_SIZE} ${BOARD_SIZE}`,
    style: {
      width: '100%',
      height: '100%',
      filter: 'drop-shadow(0 0 10px rgba(0,0,0,0.5))'
    }
  }, React.createElement("defs", null, React.createElement("radialGradient", {
    id: "boardGradient",
    cx: "50%",
    cy: "50%",
    r: "50%"
  }, React.createElement("stop", {
    offset: "0%",
    stopColor: COLORS.backgroundCard
  }), React.createElement("stop", {
    offset: "100%",
    stopColor: COLORS.background
  }))), React.createElement("circle", {
    cx: CENTER,
    cy: CENTER,
    r: CENTER - 5,
    fill: "url(#boardGradient)",
    stroke: "none",
    strokeWidth: "0"
  }), renderDartboard(), !isPowerCharging && !animatingDart && React.createElement("g", null, React.createElement("circle", {
    cx: aimPosition.x + aimWobble.x,
    cy: aimPosition.y + aimWobble.y,
    r: "15",
    fill: "none",
    stroke: `${COLORS.accent}80`,
    strokeWidth: "2",
    strokeDasharray: "5,5"
  }), React.createElement("line", {
    x1: aimPosition.x + aimWobble.x - 20,
    y1: aimPosition.y + aimWobble.y,
    x2: aimPosition.x + aimWobble.x + 20,
    y2: aimPosition.y + aimWobble.y,
    stroke: `${COLORS.accent}80`,
    strokeWidth: "1"
  }), React.createElement("line", {
    x1: aimPosition.x + aimWobble.x,
    y1: aimPosition.y + aimWobble.y - 20,
    x2: aimPosition.x + aimWobble.x,
    y2: aimPosition.y + aimWobble.y + 20,
    stroke: `${COLORS.accent}80`,
    strokeWidth: "1"
  })), dartPositions.map((pos, i) => renderDart(pos, i)), animatingDart && React.createElement("g", {
    style: {
      animation: 'throwDart 0.3s ease-out forwards'
    }
  }, renderDart(animatingDart.end, 'animating'))), showScorePopup && React.createElement("div", {
    style: {
      position: 'absolute',
      left: showScorePopup.position.x,
      top: showScorePopup.position.y - 40,
      transform: 'translateX(-50%)',
      background: showScorePopup.label === '180!!!' ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentLight})` : showScorePopup.label === 'BUST!' ? COLORS.error : showScorePopup.score === 50 ? COLORS.accent : COLORS.success,
      color: showScorePopup.score === 50 || showScorePopup.label === '180!!!' ? COLORS.background : COLORS.text,
      padding: showScorePopup.label === '180!!!' ? '12px 24px' : '8px 16px',
      borderRadius: '20px',
      fontSize: showScorePopup.label === '180!!!' ? '32px' : '20px',
      fontWeight: '700',
      animation: 'popUp 0.5s ease-out',
      pointerEvents: 'none',
      zIndex: 10,
      boxShadow: showScorePopup.label === '180!!!' ? `0 0 30px ${COLORS.accent}CC` : 'none'
    }
  }, showScorePopup.label)), achievementPopup && React.createElement("div", {
    style: {
      position: 'fixed',
      top: '50%',
      left: '50%',
      transform: 'translate(-50%, -50%)',
      background: 'linear-gradient(135deg, rgba(0, 0, 0, 0.98), rgba(20, 20, 40, 0.98))',
      border: `3px solid ${getRarityColor(achievementPopup.rarity)}`,
      borderRadius: '20px',
      padding: '32px',
      minWidth: '340px',
      maxWidth: '420px',
      boxShadow: `0 20px 60px ${getRarityColor(achievementPopup.rarity)}60, 0 0 40px ${getRarityColor(achievementPopup.rarity)}30, inset 0 0 60px ${getRarityColor(achievementPopup.rarity)}10`,
      animation: 'achievementUnlock 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275)',
      zIndex: 1000,
      textAlign: 'center'
    }
  }, (achievementPopup.rarity === 'legendary' || achievementPopup.rarity === 'mythic') && React.createElement(React.Fragment, null, [...Array(12)].map((_, i) => React.createElement("div", {
    key: i,
    style: {
      position: 'absolute',
      width: '8px',
      height: '8px',
      background: getRarityColor(achievementPopup.rarity),
      borderRadius: '50%',
      top: '50%',
      left: '50%',
      animation: `confetti${i % 4} 1s ease-out forwards`,
      animationDelay: `${i * 0.05}s`
    }
  }))), React.createElement("div", {
    style: {
      color: getRarityColor(achievementPopup.rarity),
      fontSize: '0.75rem',
      fontWeight: '700',
      letterSpacing: '3px',
      marginBottom: '16px',
      textTransform: 'uppercase'
    }
  }, "\uD83C\uDFC6 Achievement Unlocked"), React.createElement("div", {
    style: {
      fontSize: '64px',
      marginBottom: '16px',
      filter: `drop-shadow(0 0 20px ${getRarityColor(achievementPopup.rarity)})`,
      animation: 'iconBounce 0.5s ease-out 0.3s'
    }
  }, achievementPopup.icon), React.createElement("div", {
    style: {
      color: '#fff',
      fontSize: '1.5rem',
      fontWeight: '700',
      marginBottom: '8px',
      textShadow: `0 0 20px ${getRarityColor(achievementPopup.rarity)}80`
    }
  }, achievementPopup.name), React.createElement("div", {
    style: {
      color: COLORS.textMuted,
      fontSize: '0.9rem',
      marginBottom: '16px',
      lineHeight: '1.4'
    }
  }, achievementPopup.description), React.createElement("div", {
    style: {
      display: 'inline-block',
      color: getRarityColor(achievementPopup.rarity),
      fontSize: '0.7rem',
      fontWeight: '700',
      letterSpacing: '2px',
      textTransform: 'uppercase',
      background: `${getRarityColor(achievementPopup.rarity)}20`,
      border: `1px solid ${getRarityColor(achievementPopup.rarity)}`,
      borderRadius: '20px',
      padding: '6px 16px'
    }
  }, achievementPopup.rarity), (() => {
    const currentIndex = ACHIEVEMENTS_DATA.findIndex(a => a.id === achievementPopup.id);
    const nextAchievement = ACHIEVEMENTS_DATA[currentIndex + 1];
    if (nextAchievement && nextAchievement.statKey === achievementPopup.statKey) {
      return React.createElement("div", {
        style: {
          marginTop: '20px',
          padding: '12px',
          background: 'rgba(255, 255, 255, 0.05)',
          borderRadius: '10px',
          fontSize: '0.8rem'
        }
      }, React.createElement("div", {
        style: {
          color: COLORS.textMuted,
          marginBottom: '4px'
        }
      }, "Next Target:"), React.createElement("div", {
        style: {
          color: COLORS.text,
          fontWeight: '600'
        }
      }, nextAchievement.icon, " ", nextAchievement.name));
    }
    return null;
  })()), achievementPopup && React.createElement("div", {
    style: {
      position: 'fixed',
      inset: 0,
      background: 'rgba(0, 0, 0, 0.7)',
      zIndex: 999,
      animation: 'fadeIn 0.3s ease-out'
    }
  }), React.createElement("div", {
    style: {
      width: `min(${BOARD_SIZE}px, 85vw)`,
      marginTop: '20px'
    }
  }, React.createElement("div", {
    style: {
      background: 'rgba(255, 255, 255, 0.05)',
      borderRadius: '10px',
      height: '30px',
      overflow: 'hidden',
      position: 'relative',
      border: '1px solid rgba(255, 255, 255, 0.08)'
    }
  }, (() => {
    const currentPlayer = players[currentPlayerIndex];
    const aimingAt = currentPlayer ? calculateScore(aimPosition.x, aimPosition.y) : {
      multiplier: 0,
      score: 0
    };
    const isAimingAtWinningDouble = isCheckoutPosition && aimingAt.multiplier === 2 && aimingAt.score === currentPlayer?.score;
    let perfectZoneWidth;
    if (skillLevel <= 40) {
      perfectZoneWidth = 10;
    } else {
      if (isAimingAtWinningDouble) {
        perfectZoneWidth = 2;
      } else {
        const baseZoneWidth = 10;
        const shrinkRate = onlineMode || skillLevel >= 81 ? 3 : 2.5;
        perfectZoneWidth = Math.max(baseZoneWidth - triplesHit * shrinkRate, 4);
      }
    }
    const perfectZoneLeft = 50 - perfectZoneWidth / 2;
    const perfectZoneRight = 50 + perfectZoneWidth / 2;
    const isInPerfectZone = power > perfectZoneLeft && power < perfectZoneRight;
    return React.createElement(React.Fragment, null, React.createElement("div", {
      style: {
        height: '100%',
        width: `${power}%`,
        background: isInPerfectZone ? 'linear-gradient(90deg, #228b22, #32cd32)' : `linear-gradient(90deg, ${COLORS.error}, #e74c3c)`,
        transition: isPowerCharging ? 'none' : 'width 0.2s',
        borderRadius: '10px'
      }
    }), React.createElement("div", {
      style: {
        position: 'absolute',
        left: '50%',
        top: 0,
        bottom: 0,
        width: '4px',
        marginLeft: '-2px',
        background: COLORS.accent,
        opacity: 0.5
      }
    }), React.createElement("div", {
      style: {
        position: 'absolute',
        left: `${perfectZoneLeft}%`,
        top: 0,
        bottom: 0,
        width: `${perfectZoneWidth}%`,
        background: 'rgba(50, 205, 50, 0.25)',
        borderRadius: '5px'
      }
    }));
  })()), React.createElement("div", {
    style: {
      display: 'flex',
      justifyContent: 'space-between',
      color: COLORS.textMuted,
      fontSize: '11px',
      marginTop: '5px'
    }
  }, React.createElement("span", null, "WEAK"), React.createElement("span", {
    style: {
      color: isCheckoutPosition ? COLORS.accent : COLORS.success,
      fontWeight: isCheckoutPosition ? '700' : 'normal'
    }
  }, (() => {
    if (skillLevel <= 40) {
      return isCheckoutPosition ? 'CHECKOUT!' : 'PERFECT';
    }
    const shrinkRate = onlineMode || skillLevel >= 81 ? 3 : 2.5;
    const totalShrink = triplesHit > 0 ? triplesHit * shrinkRate : 0;
    return isCheckoutPosition ? `CHECKOUT! ${totalShrink > 0 ? `(-${totalShrink}%)` : ''}` : `PERFECT ${totalShrink > 0 ? `(-${totalShrink}%)` : ''}`;
  })()), React.createElement("span", null, "STRONG"))), React.createElement("p", {
    style: {
      color: COLORS.textMuted,
      marginTop: '15px',
      fontSize: '13px',
      textAlign: 'center'
    }
  }, isPowerCharging ? 'Release to throw!' : 'Click and hold to charge, release to throw')), React.createElement("div", {
    className: "game-history",
    style: {
      background: COLORS.backgroundCard,
      borderRadius: '16px',
      padding: '25px',
      minWidth: '200px',
      maxHeight: '500px',
      overflowY: 'auto',
      backdropFilter: 'blur(10px)',
      border: `1px solid ${COLORS.accent}30`
    }
  }, React.createElement("h2", {
    style: {
      color: COLORS.accent,
      margin: '0 0 20px 0',
      letterSpacing: '2px',
      fontSize: '16px',
      fontWeight: '700'
    }
  }, "HISTORY"), throwHistory.slice(-15).reverse().map((throw_, index) => React.createElement("div", {
    key: index,
    style: {
      display: 'flex',
      justifyContent: 'space-between',
      padding: '10px',
      background: 'rgba(255, 255, 255, 0.03)',
      borderRadius: '8px',
      marginBottom: '8px',
      fontSize: '13px',
      border: '1px solid rgba(255, 255, 255, 0.05)'
    }
  }, React.createElement("span", {
    style: {
      color: COLORS.textMuted
    }
  }, players[throw_.player]?.name), React.createElement("span", {
    style: {
      color: throw_.multiplier === 3 ? COLORS.accent : throw_.multiplier === 2 ? COLORS.success : COLORS.text,
      fontWeight: '600'
    }
  }, throw_.label))), throwHistory.length === 0 && React.createElement("p", {
    style: {
      color: COLORS.textMuted,
      textAlign: 'center',
      fontSize: '13px'
    }
  }, "No throws yet"))), showNineDarter && React.createElement("div", {
    style: {
      position: 'fixed',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      zIndex: 200,
      pointerEvents: 'none',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center'
    }
  }, React.createElement("div", {
    style: {
      position: 'absolute',
      top: '50%',
      left: '50%',
      transform: 'translate(-50%, -50%)',
      width: '400px',
      height: '400px',
      background: 'radial-gradient(circle, rgba(255,215,0,0.3) 0%, rgba(255,215,0,0) 70%)',
      animation: 'pulseGlow 2s ease-in-out infinite',
      borderRadius: '50%'
    }
  }), [...Array(20)].map((_, i) => React.createElement("div", {
    key: i,
    style: {
      position: 'absolute',
      top: '50%',
      left: '50%',
      width: '6px',
      height: '6px',
      background: '#ffd700',
      borderRadius: '50%',
      boxShadow: '0 0 10px #ffd700',
      animation: `sparkle${i % 4} 2s ease-out infinite`,
      animationDelay: `${i * 0.1}s`,
      opacity: 0
    }
  })), React.createElement("div", {
    style: {
      position: 'relative',
      animation: 'epicStarEntry 6s cubic-bezier(0.34, 1.56, 0.64, 1)',
      transformOrigin: 'center center'
    }
  }, React.createElement("svg", {
    width: "250",
    height: "250",
    viewBox: "0 0 200 200",
    style: {
      filter: 'drop-shadow(0 0 20px rgba(255,215,0,0.8)) drop-shadow(0 0 40px rgba(255,215,0,0.4))',
      animation: 'starGlowSequence 6s cubic-bezier(0.34, 1.56, 0.64, 1)'
    }
  }, React.createElement("defs", null, React.createElement("radialGradient", {
    id: "starGradient"
  }, React.createElement("stop", {
    offset: "0%",
    stopColor: "#ffed4a"
  }), React.createElement("stop", {
    offset: "50%",
    stopColor: "#ffd700"
  }), React.createElement("stop", {
    offset: "100%",
    stopColor: "#daa520"
  })), React.createElement("radialGradient", {
    id: "starInnerGlow"
  }, React.createElement("stop", {
    offset: "0%",
    stopColor: "#fff",
    stopOpacity: "0.8"
  }), React.createElement("stop", {
    offset: "50%",
    stopColor: "#ffd700",
    stopOpacity: "0.4"
  }), React.createElement("stop", {
    offset: "100%",
    stopColor: "#ffd700",
    stopOpacity: "0"
  }))), React.createElement("circle", {
    cx: "100",
    cy: "100",
    r: "70",
    fill: "url(#starInnerGlow)",
    opacity: "0.6",
    style: {
      animation: 'starPulse 2s ease-in-out infinite'
    }
  }), React.createElement("circle", {
    cx: "100",
    cy: "100",
    r: "50",
    fill: "url(#starInnerGlow)",
    opacity: "0.4",
    style: {
      animation: 'starPulse 2s ease-in-out infinite 0.3s'
    }
  }), React.createElement("path", {
    d: "M 100 20 L 115 70 L 170 75 L 125 110 L 140 165 L 100 135 L 60 165 L 75 110 L 30 75 L 85 70 Z",
    fill: "url(#starGradient)",
    stroke: "#daa520",
    strokeWidth: "3",
    style: {
      animation: 'starRotate 4s linear infinite 2s'
    }
  }), React.createElement("path", {
    d: "M 100 40 L 110 80 L 150 85 L 118 108 L 127 148 L 100 125 L 73 148 L 82 108 L 50 85 L 90 80 Z",
    fill: "#ffed4a",
    opacity: "0.7",
    style: {
      animation: 'starRotate 4s linear infinite 2s'
    }
  }), React.createElement("circle", {
    cx: "100",
    cy: "100",
    r: "15",
    fill: "#fff",
    opacity: "0.9",
    style: {
      animation: 'starTwinkle 1.5s ease-in-out infinite'
    }
  }), React.createElement("circle", {
    cx: "100",
    cy: "100",
    r: "8",
    fill: "#ffed4a",
    style: {
      animation: 'starTwinkle 1.5s ease-in-out infinite 0.2s'
    }
  })), React.createElement("div", {
    style: {
      position: 'absolute',
      top: '-80px',
      left: '50%',
      transform: 'translateX(-50%)',
      fontSize: '64px',
      fontWeight: '900',
      color: '#ffd700',
      textShadow: '0 0 30px rgba(255,215,0,1), 0 0 60px rgba(255,215,0,0.8), 0 4px 10px rgba(0,0,0,0.5)',
      whiteSpace: 'nowrap',
      fontFamily: "'Oswald', sans-serif",
      letterSpacing: '4px',
      animation: 'textPulse 2s ease-in-out infinite 3s',
      opacity: 0,
      animationFillMode: 'forwards'
    }
  }, "NINE DARTER!!!"), React.createElement("div", {
    style: {
      position: 'absolute',
      bottom: '-60px',
      left: '50%',
      transform: 'translateX(-50%)',
      fontSize: '24px',
      fontWeight: '600',
      color: '#ffed4a',
      textShadow: '0 0 20px rgba(255,215,0,0.8)',
      whiteSpace: 'nowrap',
      fontFamily: "'Oswald', sans-serif",
      letterSpacing: '2px',
      animation: 'textPulse 2s ease-in-out infinite 3.5s',
      opacity: 0,
      animationFillMode: 'forwards'
    }
  }, "LEGENDARY!"))), showStats && React.createElement("div", {
    style: {
      position: 'fixed',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      background: 'rgba(0, 0, 0, 0.8)',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      zIndex: 100
    },
    onClick: () => setShowStats(false)
  }, React.createElement("div", {
    style: {
      background: COLORS.backgroundCard,
      borderRadius: '16px',
      padding: '30px',
      maxWidth: '600px',
      width: '90%',
      border: `1px solid ${COLORS.accent}30`
    },
    onClick: e => e.stopPropagation()
  }, React.createElement("h2", {
    style: {
      color: COLORS.accent,
      margin: '0 0 25px 0',
      letterSpacing: '2px',
      fontSize: '18px',
      fontWeight: '700'
    }
  }, "GAME STATISTICS"), players.map((player, index) => React.createElement("div", {
    key: index,
    style: {
      background: 'rgba(255, 255, 255, 0.03)',
      borderRadius: '12px',
      padding: '20px',
      marginBottom: '15px',
      border: '1px solid rgba(255, 255, 255, 0.05)'
    }
  }, React.createElement("h3", {
    style: {
      color: COLORS.text,
      margin: '0 0 15px 0',
      fontSize: '16px',
      fontWeight: '600'
    }
  }, player.name), gameStats[index] ? React.createElement("div", {
    style: {
      display: 'grid',
      gridTemplateColumns: 'repeat(3, 1fr)',
      gap: '15px'
    }
  }, React.createElement("div", {
    style: {
      textAlign: 'center'
    }
  }, React.createElement("div", {
    style: {
      color: COLORS.accent,
      fontSize: '24px',
      fontWeight: '700'
    }
  }, gameStats[index].throws), React.createElement("div", {
    style: {
      color: COLORS.textMuted,
      fontSize: '12px'
    }
  }, "Throws")), React.createElement("div", {
    style: {
      textAlign: 'center'
    }
  }, React.createElement("div", {
    style: {
      color: COLORS.accent,
      fontSize: '24px',
      fontWeight: '700'
    }
  }, gameStats[index].averagePerSet), React.createElement("div", {
    style: {
      color: COLORS.textMuted,
      fontSize: '12px'
    }
  }, "3-Dart Avg")), React.createElement("div", {
    style: {
      textAlign: 'center'
    }
  }, React.createElement("div", {
    style: {
      color: COLORS.accent,
      fontSize: '24px',
      fontWeight: '700'
    }
  }, gameStats[index].highestThrow), React.createElement("div", {
    style: {
      color: COLORS.textMuted,
      fontSize: '12px'
    }
  }, "Best")), React.createElement("div", {
    style: {
      textAlign: 'center'
    }
  }, React.createElement("div", {
    style: {
      color: COLORS.success,
      fontSize: '24px',
      fontWeight: '700'
    }
  }, gameStats[index].triples), React.createElement("div", {
    style: {
      color: COLORS.textMuted,
      fontSize: '12px'
    }
  }, "Triples")), React.createElement("div", {
    style: {
      textAlign: 'center'
    }
  }, React.createElement("div", {
    style: {
      color: COLORS.primaryLight,
      fontSize: '24px',
      fontWeight: '700'
    }
  }, gameStats[index].doubles), React.createElement("div", {
    style: {
      color: COLORS.textMuted,
      fontSize: '12px'
    }
  }, "Doubles")), React.createElement("div", {
    style: {
      textAlign: 'center'
    }
  }, React.createElement("div", {
    style: {
      color: COLORS.error,
      fontSize: '24px',
      fontWeight: '700'
    }
  }, gameStats[index].bullseyes), React.createElement("div", {
    style: {
      color: COLORS.textMuted,
      fontSize: '12px'
    }
  }, "Bullseyes"))) : React.createElement("p", {
    style: {
      color: COLORS.textMuted,
      margin: 0
    }
  }, "No stats yet"))), React.createElement("button", {
    onClick: () => setShowStats(false),
    style: {
      width: '100%',
      padding: '15px',
      background: `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentLight})`,
      color: COLORS.background,
      border: 'none',
      borderRadius: '10px',
      fontSize: '14px',
      fontWeight: '600',
      cursor: 'pointer',
      fontFamily: "'Inter', sans-serif"
    }
  }, "CLOSE"))), winner && React.createElement("div", {
    style: {
      position: 'fixed',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      background: 'rgba(0, 0, 0, 0.9)',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      zIndex: 100
    }
  }, React.createElement("div", {
    style: {
      textAlign: 'center',
      animation: 'fadeIn 0.5s ease-out'
    }
  }, React.createElement("div", {
    style: {
      fontSize: '100px',
      marginBottom: '20px'
    }
  }, matchWinner ? 'ðŸ†' : 'âœ“'), React.createElement("h1", {
    style: {
      fontSize: '42px',
      color: COLORS.accent,
      margin: '0 0 10px 0',
      textShadow: `0 0 30px ${COLORS.accent}80`,
      fontWeight: '700'
    }
  }, winner.name, " ", matchWinner ? 'WINS THE MATCH!' : 'WINS THE LEG!'), React.createElement("p", {
    style: {
      color: COLORS.textMuted,
      fontSize: '18px',
      marginBottom: '30px'
    }
  }, matchWinner ? 'Match Complete - Champion Crowned!' : 'Next leg starting soon...'), matchWinner && React.createElement("div", {
    style: {
      display: 'flex',
      gap: '15px',
      justifyContent: 'center'
    }
  }, React.createElement("button", {
    onClick: startGame,
    style: {
      padding: '15px 40px',
      background: `linear-gradient(135deg, ${COLORS.primary}, ${COLORS.primaryLight})`,
      color: COLORS.text,
      border: 'none',
      borderRadius: '10px',
      fontSize: '16px',
      fontWeight: '600',
      cursor: 'pointer',
      fontFamily: "'Inter', sans-serif"
    }
  }, "PLAY AGAIN"), React.createElement("button", {
    onClick: resetGame,
    style: {
      padding: '15px 40px',
      background: 'rgba(255, 255, 255, 0.05)',
      color: COLORS.text,
      border: '1px solid rgba(255, 255, 255, 0.1)',
      borderRadius: '10px',
      fontSize: '16px',
      fontWeight: '600',
      cursor: 'pointer',
      fontFamily: "'Inter', sans-serif"
    }
  }, "MAIN MENU")))), React.createElement("style", null, `
            @keyframes popUp { 0% { transform: translateX(-50%) scale(0.5); opacity: 0; } 50% { transform: translateX(-50%) scale(1.2); } 100% { transform: translateX(-50%) scale(1); opacity: 1; } }
            @keyframes fadeIn { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
            @keyframes throwDart { from { opacity: 0; transform: translateY(50px); } to { opacity: 1; transform: translateY(0); } }
            @keyframes slideInRight { 0% { transform: translateX(400px); opacity: 0; } 100% { transform: translateX(0); opacity: 1; } }

            /* Rhythm Indicator Animations */
            @keyframes rhythmPulse {
              0% { transform: scale(0.8); opacity: 0; }
              50% { transform: scale(1.05); }
              100% { transform: scale(1); opacity: 1; }
            }

            /* Score Confirming Animation */
            @keyframes confirmingPulse {
              0%, 100% { opacity: 0.5; }
              50% { opacity: 1; }
            }

            /* Epic Nine-Darter Star Animations */
            @keyframes epicStarEntry {
              0% { transform: scale(0.3) translateY(100px); opacity: 0; }
              15% { transform: scale(1.3) translateY(-80px) rotate(0deg); opacity: 1; }
              30% { transform: scale(1.2) translateY(-60px) rotate(360deg); }
              45% { transform: scale(1.25) translateY(-40px) rotate(360deg); }
              60% { transform: scale(1.1) translateY(0px) rotate(720deg); }
              75% { transform: scale(1.15) translateY(-10px) rotate(720deg); }
              85% { transform: scale(1.05) translateY(5px) rotate(720deg); }
              100% { transform: scale(1.1) translateY(0px) rotate(720deg); }
            }

            @keyframes starGlowSequence {
              0% { filter: drop-shadow(0 0 10px rgba(255,215,0,0.3)); }
              50% { filter: drop-shadow(0 0 50px rgba(255,215,0,1)) drop-shadow(0 0 100px rgba(255,215,0,0.8)); }
              100% { filter: drop-shadow(0 0 40px rgba(255,215,0,0.9)) drop-shadow(0 0 80px rgba(255,215,0,0.6)); }
            }

            @keyframes starRotate {
              0% { transform: rotate(0deg); }
              100% { transform: rotate(360deg); }
            }

            @keyframes starPulse {
              0%, 100% { transform: scale(1); opacity: 0.6; }
              50% { transform: scale(1.2); opacity: 0.3; }
            }

            @keyframes starTwinkle {
              0%, 100% { opacity: 0.9; transform: scale(1); }
              50% { opacity: 0.4; transform: scale(0.7); }
            }

            @keyframes pulseGlow {
              0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.4; }
              50% { transform: translate(-50%, -50%) scale(1.3); opacity: 0.7; }
            }

            @keyframes textPulse {
              0% { opacity: 0; transform: translateX(-50%) scale(0.5); }
              10% { opacity: 1; transform: translateX(-50%) scale(1.2); }
              20% { opacity: 1; transform: translateX(-50%) scale(1); }
              30%, 100% { opacity: 1; transform: translateX(-50%) scale(1); }
            }

            @keyframes sparkle0 {
              0% { transform: translate(0, 0) scale(0); opacity: 0; }
              10% { opacity: 1; }
              100% { transform: translate(120px, -150px) scale(1); opacity: 0; }
            }

            @keyframes sparkle1 {
              0% { transform: translate(0, 0) scale(0); opacity: 0; }
              10% { opacity: 1; }
              100% { transform: translate(-130px, -140px) scale(1); opacity: 0; }
            }

            @keyframes sparkle2 {
              0% { transform: translate(0, 0) scale(0); opacity: 0; }
              10% { opacity: 1; }
              100% { transform: translate(140px, 120px) scale(1); opacity: 0; }
            }

            @keyframes sparkle3 {
              0% { transform: translate(0, 0) scale(0); opacity: 0; }
              10% { opacity: 1; }
              100% { transform: translate(-110px, 130px) scale(1); opacity: 0; }
            }
          `));
};
ReactDOM.render(React.createElement(DartsGame, null), document.getElementById('root'));</script>
</body>
</html>
