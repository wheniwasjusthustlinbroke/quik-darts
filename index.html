<!DOCTYPE html>
<!-- Quik Darts v1.1 - January 2026 -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <!-- Security Headers (X-Frame-Options and frame-ancestors require HTTP headers, not meta tags) -->
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  <meta name="referrer" content="strict-origin-when-cross-origin">
  <!-- CSP: Allow scripts from trusted CDNs only -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdnjs.cloudflare.com https://www.gstatic.com https://apis.google.com https://unpkg.com https://*.firebasedatabase.app; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; connect-src 'self' https://*.firebaseio.com https://*.firebasedatabase.app wss://*.firebaseio.com wss://*.firebasedatabase.app https://identitytoolkit.googleapis.com https://securetoken.googleapis.com https://unpkg.com https://www.gstatic.com; frame-src https://*.firebaseapp.com https://*.firebasedatabase.app; img-src 'self' data:;">

  <meta name="description" content="Quik Darts - Championship-style online darts. Play solo, challenge friends, or compete online. No download required.">
  <title>Quik Darts - Championship Edition</title>

  <!-- Favicons - Google requires 48x48 minimum -->
  <link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="48x48" href="/favicon-48x48.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta name="theme-color" content="#0D1117">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">

  <!-- External Scripts with Subresource Integrity (SRI) for supply chain protection -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js" integrity="sha512-8Q6Y9XnTbOE+JNvjBQwJ2H8S+UV4uA6hiRykhdtIyDYZ2TprdNmWOUaKdGzOhyr4dCyk287OejbPvwl7lrfqrQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js" integrity="sha512-MOCpqoRoisCTwJ8vQQiciZv0qcpROCidek3GTFS6KTk2+y7munJIlKCVkFCYY+p3ErYFXCjmFjnfTTRSC1OHWQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://unpkg.com/@babel/standalone@7.26.5/babel.min.js" integrity="sha384-SF03qAKhbEVbqj7hDewV6mk3wJJyzxf3nBCxNuF46+Sof8f1fx4Pes2gOVItRZn9" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <!-- Firebase SDKs with SRI -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js" integrity="sha384-yuGdyIzzYtOBlBG6JOWn+Ey9kpq7HocusNuxEGyyohr1eEyXpeEyehIIXC/hznw4" crossorigin="anonymous"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js" integrity="sha384-lI+CxEx/bCvWP1b0OK13j5HTrTZP7yf1xle8TVOFq2smz6KC1RChTarRV/RHP5PP" crossorigin="anonymous"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js" integrity="sha384-M6AmjBRXEjkdGzRN1Y94xtkmblFbYBSLkqzyZ8rPvpRM2c48nhjIRFXVvUM/VATL" crossorigin="anonymous"></script>
  <style>
    /* CSS Custom Properties - Design System */
    :root {
      --color-primary: #1B4332;
      --color-primary-light: #2D6A4F;
      --color-primary-dark: #143728;
      --color-accent: #D4A03A;
      --color-accent-light: #E8B94A;
      --color-accent-dark: #B8862E;
      --color-background: #0D1117;
      --color-background-light: #161B22;
      --color-background-card: #1C2128;
      --color-text: #F5F5F5;
      --color-text-muted: #8B949E;
      --color-text-dark: #0D1117;
      --color-success: #2D8A2D;
      --color-error: #C92A2A;
      --font-primary: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      --font-mono: 'Roboto Mono', monospace;
      --radius-sm: 6px;
      --radius-md: 10px;
      --radius-lg: 16px;
      --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);
      --shadow-md: 0 8px 24px rgba(0, 0, 0, 0.4);
      --shadow-lg: 0 16px 48px rgba(0, 0, 0, 0.5);
      --transition-fast: 0.15s ease;
      --transition-normal: 0.3s ease;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    html { scroll-behavior: smooth; }

    body {
      font-family: var(--font-primary);
      background: var(--color-background);
      color: var(--color-text);
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      touch-action: manipulation;
      line-height: 1.5;
    }

    /* Typography */
    h1, h2, h3, h4 { font-weight: 700; line-height: 1.2; }
    h1 { font-size: clamp(2rem, 5vw, 3.5rem); }
    h2 { font-size: clamp(1.5rem, 4vw, 2.5rem); }
    h3 { font-size: clamp(1.25rem, 3vw, 1.75rem); }

    /* Navigation */
    .nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      background: rgba(13, 17, 23, 0.95);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      transition: var(--transition-normal);
    }
    .nav-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 24px;
      height: 64px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .nav-logo {
      font-size: 1.25rem;
      font-weight: 800;
      color: var(--color-accent);
      text-decoration: none;
      letter-spacing: 1px;
    }
    .nav-links {
      display: flex;
      align-items: center;
      gap: 32px;
      list-style: none;
    }
    .nav-link {
      color: var(--color-text-muted);
      text-decoration: none;
      font-size: 0.9rem;
      font-weight: 500;
      transition: var(--transition-fast);
      cursor: pointer;
    }
    .nav-link:hover { color: var(--color-text); }
    .nav-cta {
      background: var(--color-accent);
      color: var(--color-text-dark);
      padding: 10px 20px;
      border-radius: var(--radius-sm);
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
      border: none;
      transition: var(--transition-fast);
    }
    .nav-cta:hover {
      background: var(--color-accent-light);
      transform: translateY(-1px);
    }
    .nav-hamburger {
      display: none;
      flex-direction: column;
      gap: 5px;
      cursor: pointer;
      padding: 8px;
      background: none;
      border: none;
    }
    .nav-hamburger span {
      width: 24px;
      height: 2px;
      background: var(--color-text);
      transition: var(--transition-fast);
    }
    .nav-mobile {
      display: none;
      position: fixed;
      top: 64px;
      left: 0;
      right: 0;
      background: var(--color-background);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding: 16px 24px;
    }
    .nav-mobile.open { display: block; }
    .nav-mobile-links {
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    @media (max-width: 768px) {
      .nav-links { display: none; }
      .nav-hamburger { display: flex; }
      .game-layout { flex-direction: column !important; }
      .game-dartboard { order: 1 !important; }
      .game-history { order: 2 !important; max-height: 180px !important; }
      .game-scoreboard { order: 3 !important; }
    }

    /* Buttons */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 14px 28px;
      font-family: var(--font-primary);
      font-size: 1rem;
      font-weight: 600;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all var(--transition-normal);
      text-decoration: none;
      min-height: 48px;
    }
    .btn-primary {
      background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-dark) 100%);
      color: var(--color-text-dark);
      box-shadow: 0 4px 16px rgba(212, 160, 58, 0.3);
    }
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(212, 160, 58, 0.4);
    }
    .btn-secondary {
      background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
      color: var(--color-text);
      box-shadow: 0 4px 16px rgba(27, 67, 50, 0.3);
    }
    .btn-secondary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(27, 67, 50, 0.4);
    }
    .btn-ghost {
      background: transparent;
      color: var(--color-text);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .btn-ghost:hover {
      background: rgba(255, 255, 255, 0.05);
      border-color: rgba(255, 255, 255, 0.3);
    }
    .btn:active { transform: translateY(0) scale(0.98); }

    /* Footer */
    .footer {
      background: var(--color-background);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      padding: 48px 24px 24px;
    }
    .footer-container {
      max-width: 1200px;
      margin: 0 auto;
    }
    .footer-content {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      flex-wrap: wrap;
      gap: 32px;
      margin-bottom: 32px;
    }
    .footer-brand h3 {
      color: var(--color-accent);
      margin-bottom: 8px;
    }
    .footer-brand p {
      color: var(--color-text-muted);
      font-size: 0.9rem;
    }
    .footer-links {
      display: flex;
      gap: 48px;
      flex-wrap: wrap;
    }
    .footer-links-group h4 {
      color: var(--color-text);
      font-size: 0.9rem;
      margin-bottom: 12px;
    }
    .footer-links-group ul {
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .footer-links-group a {
      color: var(--color-text-muted);
      text-decoration: none;
      font-size: 0.85rem;
      transition: var(--transition-fast);
      cursor: pointer;
    }
    .footer-links-group a:hover { color: var(--color-text); }
    .footer-bottom {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-top: 24px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      flex-wrap: wrap;
      gap: 16px;
    }
    .footer-bottom p {
      color: var(--color-text-muted);
      font-size: 0.8rem;
    }
    .footer-social {
      display: flex;
      gap: 16px;
    }
    .footer-social a {
      color: var(--color-text-muted);
      transition: var(--transition-fast);
    }
    .footer-social a:hover { color: var(--color-accent); }

    /* Animations */
    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    @keyframes almostTherePulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(212, 160, 58, 0); }
      50% { box-shadow: 0 0 20px 2px rgba(212, 160, 58, 0.3); }
    }
    @keyframes achievementUnlock {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }
    @keyframes iconBounce {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @keyframes confetti0 {
      0% { transform: translate(0, 0) scale(0); opacity: 1; }
      100% { transform: translate(-80px, -100px) scale(1); opacity: 0; }
    }
    @keyframes confetti1 {
      0% { transform: translate(0, 0) scale(0); opacity: 1; }
      100% { transform: translate(80px, -90px) scale(1); opacity: 0; }
    }
    @keyframes confetti2 {
      0% { transform: translate(0, 0) scale(0); opacity: 1; }
      100% { transform: translate(-70px, 80px) scale(1); opacity: 0; }
    }
    @keyframes confetti3 {
      0% { transform: translate(0, 0) scale(0); opacity: 1; }
      100% { transform: translate(90px, 70px) scale(1); opacity: 0; }
    }
    @keyframes rareShimmer {
      0%, 100% { box-shadow: 0 0 15px rgba(52, 152, 219, 0.3); }
      50% { box-shadow: 0 0 25px rgba(52, 152, 219, 0.5); }
    }
    @keyframes epicGlow {
      0%, 100% { box-shadow: 0 0 20px rgba(155, 89, 182, 0.4), inset 0 0 30px rgba(155, 89, 182, 0.1); }
      50% { box-shadow: 0 0 35px rgba(155, 89, 182, 0.6), inset 0 0 40px rgba(155, 89, 182, 0.15); }
    }
    @keyframes legendaryPulse {
      0%, 100% { box-shadow: 0 0 25px rgba(243, 156, 18, 0.5), 0 0 50px rgba(243, 156, 18, 0.2); }
      50% { box-shadow: 0 0 40px rgba(243, 156, 18, 0.7), 0 0 70px rgba(243, 156, 18, 0.3); }
    }
    @keyframes mythicGlow {
      0%, 100% {
        box-shadow: 0 0 30px rgba(231, 76, 60, 0.6), 0 0 60px rgba(231, 76, 60, 0.3), inset 0 0 40px rgba(231, 76, 60, 0.1);
        border-color: rgba(231, 76, 60, 0.8);
      }
      50% {
        box-shadow: 0 0 50px rgba(231, 76, 60, 0.8), 0 0 80px rgba(231, 76, 60, 0.4), inset 0 0 50px rgba(231, 76, 60, 0.15);
        border-color: rgba(231, 76, 60, 1);
      }
    }
    .animate-fade-in { animation: fadeInUp 0.6s ease forwards; }
    .animate-delay-1 { animation-delay: 0.1s; opacity: 0; }
    .animate-delay-2 { animation-delay: 0.2s; opacity: 0; }
    .animate-delay-3 { animation-delay: 0.3s; opacity: 0; }

    /* Utility */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      border: 0;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useRef, useEffect, useCallback } = React;

    // Firebase Configuration
    const firebaseConfig = {
      apiKey: "AIzaSyAapEmqdhRMQgRyrXIzhhMGSvNbpfQlaoM",
      authDomain: "quikdarts.firebaseapp.com",
      databaseURL: "https://quikdarts-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "quikdarts",
      storageBucket: "quikdarts.firebasestorage.app",
      messagingSenderId: "287454496132",
      appId: "1:287454496132:web:dd17354a71f9eb907f89d1",
      measurementId: "G-TE4B2W2CEJ"
    };

    // Initialize Firebase
    let database = null;
    let auth = null;
    let currentAuthUser = null;

    // Promise that resolves when auth is ready
    let authReadyResolve;
    const authReadyPromise = new Promise(resolve => { authReadyResolve = resolve; });

    try {
      if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
      }
      database = firebase.database();
      auth = firebase.auth();

      // Listen for auth state changes
      auth.onAuthStateChanged((user) => {
        if (user) {
          currentAuthUser = user;
          authReadyResolve(user);
        } else {
          // Sign in anonymously if not authenticated
          auth.signInAnonymously().catch((error) => {
            console.warn('Anonymous auth failed:', error);
            authReadyResolve(null);
          });
        }
      });
    } catch (error) {
      console.warn('Firebase not configured. Online multiplayer disabled.', error);
      authReadyResolve(null);
    }

    // Menu Icon Components (defined outside component to prevent recreation on each render)
    const DartIcon = ({ size = 20, color = 'currentColor' }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" aria-hidden="true" style={{ marginRight: '12px', flexShrink: 0 }}>
        <path d="M22 2L13 11M22 2L18 22L13 11M22 2L2 7L13 11" stroke={color} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
      </svg>
    );

    const GlobeIcon = ({ size = 20, color = 'currentColor' }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" aria-hidden="true" style={{ marginRight: '12px', flexShrink: 0 }}>
        <circle cx="12" cy="12" r="10" stroke={color} strokeWidth="2"/>
        <path d="M2 12H22M12 2C14.5 4.5 16 8 16 12C16 16 14.5 19.5 12 22C9.5 19.5 8 16 8 12C8 8 9.5 4.5 12 2Z" stroke={color} strokeWidth="2"/>
      </svg>
    );

    const TargetIcon = ({ size = 20, color = 'currentColor' }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" aria-hidden="true" style={{ marginRight: '12px', flexShrink: 0 }}>
        <circle cx="12" cy="12" r="10" stroke={color} strokeWidth="2"/>
        <circle cx="12" cy="12" r="6" stroke={color} strokeWidth="2"/>
        <circle cx="12" cy="12" r="2" fill={color}/>
      </svg>
    );

    const TrophyIcon = ({ size = 20, color = 'currentColor' }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" aria-hidden="true" style={{ marginRight: '12px', flexShrink: 0 }}>
        <path d="M8 21H16M12 17V21M6 4H18V8C18 11.3137 15.3137 14 12 14C8.68629 14 6 11.3137 6 8V4Z" stroke={color} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
        <path d="M6 4H4V6C4 7.10457 4.89543 8 6 8V4ZM18 4V8C19.1046 8 20 7.10457 20 6V4H18Z" stroke={color} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
      </svg>
    );

    // Additional icons for navigation and UI
    const MenuIcon = ({ size = 24 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" aria-hidden="true">
        <path d="M3 12H21M3 6H21M3 18H21" stroke="currentColor" strokeWidth="2" strokeLinecap="round"/>
      </svg>
    );

    const CloseIcon = ({ size = 24 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" aria-hidden="true">
        <path d="M18 6L6 18M6 6L18 18" stroke="currentColor" strokeWidth="2" strokeLinecap="round"/>
      </svg>
    );

    const PlayIcon = ({ size = 20 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
        <path d="M8 5v14l11-7z"/>
      </svg>
    );

    const BookIcon = ({ size = 20 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" aria-hidden="true" style={{ marginRight: '8px', flexShrink: 0 }}>
        <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20M4 19.5A2.5 2.5 0 0 0 6.5 22H20V2H6.5A2.5 2.5 0 0 0 4 4.5v15z" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
      </svg>
    );

    const UsersIcon = ({ size = 20 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" aria-hidden="true" style={{ marginRight: '8px', flexShrink: 0 }}>
        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2M9 11a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM23 21v-2a4 4 0 0 0-3-3.87M16 3.13a4 4 0 0 1 0 7.75" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
      </svg>
    );

    // Design System Colors (matching CSS variables)
    const COLORS = {
      primary: '#1B4332',
      primaryLight: '#2D6A4F',
      primaryDark: '#143728',
      accent: '#D4A03A',
      accentLight: '#E8B94A',
      accentDark: '#B8862E',
      background: '#0D1117',
      backgroundLight: '#161B22',
      backgroundCard: '#1C2128',
      text: '#F5F5F5',
      textMuted: '#8B949E',
      textDark: '#0D1117',
      success: '#2D8A2D',
      error: '#C92A2A'
    };

    // Pre-computed bokeh light sizes (deterministic, no Math.random in render)
    const BOKEH_LIGHTS = [
      { size: 45, left: 10, top: 5 },
      { size: 65, left: 22, top: 15 },
      { size: 38, left: 34, top: 25 },
      { size: 72, left: 46, top: 35 },
      { size: 50, left: 58, top: 45 },
      { size: 58, left: 70, top: 55 },
      { size: 42, left: 82, top: 65 },
      { size: 68, left: 94, top: 75 }
    ];

    const BOARD_SIZE = 500;
    const CENTER = BOARD_SIZE / 2;
    const SEGMENTS = [20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5];
    const SEGMENT_COLORS = ['#0a0a0a', '#f5f0e8']; // Deep black and cream (more realistic)
    const TRIPLE_INNER = 119;
    const TRIPLE_OUTER = 134;
    const DOUBLE_INNER = 200;
    const DOUBLE_OUTER = 215;
    const OUTER_BULL = 20;
    const INNER_BULL = 10;

    // ============================================
    // DARTBOARD THEME SYSTEM
    // ============================================

    // Theme ID constants (no magic strings)
    const THEME_IDS = Object.freeze({
      CLASSIC: 'classic',
      PRO_WIRE: 'proWire',
      NEON_GLOW: 'neonGlow',
      GOLD_ELITE: 'goldElite',
      STEALTH: 'stealth'
    });

    // Neon color options for neonGlow theme
    const NEON_COLOR_OPTIONS = Object.freeze({
      CYAN: 'cyan',
      PINK: 'pink',
      GREEN: 'green'
    });

    // Classic theme - Matches iOS dartboard exactly (flat rendering, no 3D effects)
    const THEME_CLASSIC = Object.freeze({
      id: THEME_IDS.CLASSIC,
      name: 'Classic',
      description: 'Traditional dartboard matching iOS appearance',
      icon: 'ğŸ¯',
      colors: {
        segmentPrimary: '#0a0a0a',      // Deep black
        segmentSecondary: '#f5f0e8',     // Cream
        doubleTripleEven: '#b8232a',     // Deep red
        doubleTripleOdd: '#0d6b2e',      // Deep green
        outerBull: '#0d6b2e',            // Green
        innerBull: '#b8232a',            // Red
        wireColor: '#888888',            // Light silver wire (matches iOS)
        wireHighlight: 'rgba(255,255,255,0.6)',
        chromeRing: '#c0c0c0',           // Silver chrome
        numberRing: '#1a1a2e',           // Navy background
        numberText: '#f5f0e8',           // Cream text
        frameColor: '#b8860b',           // Gold frame
        boardBackground: '#1a1a1a'
      },
      effects: {
        useSisalTexture: false,          // Disabled to match iOS (iOS doesn't render textures)
        useWoodGrain: false,             // Disabled to match iOS (iOS doesn't render wood grain)
        useChromeGradient: false,        // Disabled to match iOS (iOS uses solid chrome color)
        useBoardLighting: false,         // Disabled to match iOS (iOS doesn't render lighting)
        glowEffect: false,
        pulseAnimation: false,
        wireWidth: 1.0,                  // Thinner wire (matches iOS)
        shadowIntensity: 0               // Disabled to match iOS (iOS doesn't render shadows)
      }
    });

    // Pro Wire theme - Tournament look with metal wire dividers
    const THEME_PRO_WIRE = Object.freeze({
      id: THEME_IDS.PRO_WIRE,
      name: 'Pro Wire',
      description: 'Tournament style with thin metal wire dividers',
      icon: 'ğŸ†',
      colors: {
        segmentPrimary: '#0a0a0a',
        segmentSecondary: '#e8e4dc',     // Slightly lighter cream
        doubleTripleEven: '#c41e3a',     // Brighter red
        doubleTripleOdd: '#1a8b45',      // Brighter green
        outerBull: '#1a8b45',
        innerBull: '#c41e3a',
        wireColor: '#d4d4d4',            // Silver wire
        wireHighlight: 'rgba(255,255,255,0.9)',
        chromeRing: '#e0e0e0',           // Bright chrome
        numberRing: '#1a1a2e',
        numberText: '#ffffff',           // White text
        frameColor: '#a0a0a0',           // Silver frame
        boardBackground: '#1a1a1a'
      },
      effects: {
        useSisalTexture: true,
        useWoodGrain: false,
        useChromeGradient: true,
        useBoardLighting: true,
        glowEffect: false,
        pulseAnimation: false,
        wireWidth: 0.8,                  // Thinner wires
        shadowIntensity: 0.2
      }
    });

    // Neon Glow theme - Dark board with glowing neon wires
    const THEME_NEON_GLOW = Object.freeze({
      id: THEME_IDS.NEON_GLOW,
      name: 'Neon Glow',
      description: 'Dark board with glowing neon wires',
      icon: 'âœ¨',
      neonColorOptions: [NEON_COLOR_OPTIONS.CYAN, NEON_COLOR_OPTIONS.PINK, NEON_COLOR_OPTIONS.GREEN],
      defaultNeonColor: NEON_COLOR_OPTIONS.CYAN,
      // Colors will be dynamically set based on neon color selection
      getColors: (neonColor) => {
        const neonColors = {
          [NEON_COLOR_OPTIONS.CYAN]: {
            primary: '#00ffff',
            secondary: '#00d4ff',
            glow: 'rgba(0, 255, 255, 0.6)'
          },
          [NEON_COLOR_OPTIONS.PINK]: {
            primary: '#ff00ff',
            secondary: '#ff44aa',
            glow: 'rgba(255, 0, 255, 0.6)'
          },
          [NEON_COLOR_OPTIONS.GREEN]: {
            primary: '#00ff66',
            secondary: '#44ff88',
            glow: 'rgba(0, 255, 102, 0.6)'
          }
        };
        const neon = neonColors[neonColor] || neonColors[NEON_COLOR_OPTIONS.CYAN];
        return {
          segmentPrimary: '#0a0a12',       // Very dark
          segmentSecondary: '#1a1a28',     // Dark purple-black
          doubleTripleEven: '#2a0a1a',     // Dark red tint
          doubleTripleOdd: '#0a1a1a',      // Dark green tint
          outerBull: '#0a1a1a',
          innerBull: '#2a0a1a',
          wireColor: neon.primary,
          wireHighlight: neon.glow,
          chromeRing: '#1a1a28',
          numberRing: '#0a0a12',
          numberText: neon.primary,
          frameColor: neon.secondary,
          boardBackground: '#050508',
          neonGlow: neon.glow,
          neonPrimary: neon.primary
        };
      },
      effects: {
        useSisalTexture: false,
        useWoodGrain: false,
        useChromeGradient: false,
        useBoardLighting: false,
        glowEffect: true,
        pulseAnimation: true,
        wireWidth: 2.0,
        shadowIntensity: 0.1
      }
    });

    // Gold Elite theme - Black and gold luxury theme
    const THEME_GOLD_ELITE = Object.freeze({
      id: THEME_IDS.GOLD_ELITE,
      name: 'Gold Elite',
      description: 'Black and gold luxury premium theme',
      icon: 'ğŸ‘‘',
      colors: {
        segmentPrimary: '#0a0a0a',        // Black
        segmentSecondary: '#1a1a1a',      // Dark gray
        doubleTripleEven: '#b8860b',      // Dark gold
        doubleTripleOdd: '#daa520',       // Goldenrod
        outerBull: '#daa520',
        innerBull: '#ffd700',             // Gold
        wireColor: '#ffd700',             // Gold wire
        wireHighlight: 'rgba(255,215,0,0.8)',
        chromeRing: '#ffd700',            // Gold
        numberRing: '#0a0a0a',
        numberText: '#ffd700',
        frameColor: '#ffd700',
        boardBackground: '#050505',
        metallicSheen: 'rgba(255,215,0,0.15)'
      },
      effects: {
        useSisalTexture: false,
        useWoodGrain: false,
        useChromeGradient: false,
        useBoardLighting: true,
        glowEffect: false,
        pulseAnimation: false,
        wireWidth: 1.2,
        shadowIntensity: 0.4,
        useMetallicSheen: true
      }
    });

    // Stealth theme - All black/dark gray minimal (hard mode aesthetic)
    const THEME_STEALTH = Object.freeze({
      id: THEME_IDS.STEALTH,
      name: 'Stealth',
      description: 'Minimal dark theme - hard mode aesthetic',
      icon: 'ğŸŒ‘',
      colors: {
        segmentPrimary: '#0a0a0a',        // Deep black
        segmentSecondary: '#151515',      // Very dark gray
        doubleTripleEven: '#1a1a1a',      // Slightly lighter
        doubleTripleOdd: '#222222',       // Dark gray
        outerBull: '#1a1a1a',
        innerBull: '#252525',
        wireColor: '#333333',             // Dark gray wire
        wireHighlight: 'rgba(255,255,255,0.1)',
        chromeRing: '#1a1a1a',
        numberRing: '#0a0a0a',
        numberText: '#444444',            // Subtle text
        frameColor: '#151515',
        boardBackground: '#050505'
      },
      effects: {
        useSisalTexture: false,
        useWoodGrain: false,
        useChromeGradient: false,
        useBoardLighting: false,
        glowEffect: false,
        pulseAnimation: false,
        wireWidth: 0.5,
        shadowIntensity: 0.1
      }
    });

    // All themes collection
    const DARTBOARD_THEMES = Object.freeze({
      [THEME_IDS.CLASSIC]: THEME_CLASSIC,
      [THEME_IDS.PRO_WIRE]: THEME_PRO_WIRE,
      [THEME_IDS.NEON_GLOW]: THEME_NEON_GLOW,
      [THEME_IDS.GOLD_ELITE]: THEME_GOLD_ELITE,
      [THEME_IDS.STEALTH]: THEME_STEALTH
    });

    // Theme IDs array for iteration
    const THEME_IDS_LIST = Object.freeze([
      THEME_IDS.CLASSIC,
      THEME_IDS.PRO_WIRE,
      THEME_IDS.NEON_GLOW,
      THEME_IDS.GOLD_ELITE,
      THEME_IDS.STEALTH
    ]);

    // Default theme
    const DEFAULT_THEME_ID = THEME_IDS.CLASSIC;

    // Validate theme ID
    const isValidThemeId = (themeId) => {
      return themeId && Object.values(THEME_IDS).includes(themeId);
    };

    // Get theme by ID with validation
    const getThemeById = (themeId) => {
      if (!isValidThemeId(themeId)) {
        console.warn(`Invalid theme ID: ${themeId}, falling back to default`);
        return DARTBOARD_THEMES[DEFAULT_THEME_ID];
      }
      return DARTBOARD_THEMES[themeId];
    };

    // Get theme colors (handles neon glow special case)
    const getThemeColors = (theme, neonColor = null) => {
      if (theme.id === THEME_IDS.NEON_GLOW && theme.getColors) {
        return theme.getColors(neonColor || theme.defaultNeonColor);
      }
      return theme.colors;
    };

    // ============================================
    // END DARTBOARD THEME SYSTEM
    // ============================================

    // Achievements data - moved outside component to prevent recreation on every render
    // Achievements with chain property are part of tiered progression ladders
    const ACHIEVEMENTS_DATA = [
      // First Steps (standalone)
      { id: 'first_game', name: 'First Steps', description: 'Every champion starts somewhere. Complete your first game.', icon: 'ğŸ¯', rarity: 'common', mode: 'offline' },
      { id: 'first_win', name: 'First Victory', description: 'The taste of victory never gets old. Win your first game.', icon: 'ğŸ†', rarity: 'common', mode: 'offline' },

      // Maximum! Chain - 180 progression
      { id: 'first_180', name: 'Maximum! I', description: 'The crowd goes wild! Hit your first perfect 180.', icon: 'ğŸ’¯', rarity: 'uncommon', mode: 'offline', chain: 'maximum', tier: 1 },
      { id: 'ten_180s', name: 'Maximum! II', description: 'Consistency is key. Land 10 maximum scores.', icon: 'ğŸ’¯', rarity: 'rare', mode: 'offline', statKey: 'total180s', target: 10, chain: 'maximum', tier: 2 },
      { id: 'fifty_180s', name: 'Maximum! III', description: 'Only the elite reach this level. Hit 50 perfect 180s.', icon: 'ğŸ’¯', rarity: 'epic', mode: 'offline', statKey: 'total180s', target: 50, chain: 'maximum', tier: 3 },
      { id: 'hundred_180s', name: 'Maximum! IV', description: 'Legendary precision. 100 perfect 180s.', icon: 'ğŸ’¯', rarity: 'legendary', mode: 'offline', statKey: 'total180s', target: 100, chain: 'maximum', tier: 4 },

      // Nine Darter (standalone legendary)
      { id: 'nine_darter_offline', name: 'Perfect Game', description: 'The holy grail of darts. Achieve a legendary nine-dart finish.', icon: 'ğŸ‘‘', rarity: 'legendary', mode: 'offline' },
      { id: 'nine_darter_online', name: 'Online Legend', description: 'Perfection under pressure. Nine-dart finish against a real opponent.', icon: 'ğŸ’', rarity: 'mythic', mode: 'online' },

      // Bullseye! Chain
      { id: 'first_bull', name: 'Bullseye! I', description: 'Right in the center! Hit your first bullseye.', icon: 'ğŸ¯', rarity: 'common', mode: 'offline', chain: 'bullseye', tier: 1 },
      { id: 'fifty_bulls', name: 'Bullseye! II', description: 'Precision personified. Find the bullseye 50 times.', icon: 'ğŸ¯', rarity: 'rare', mode: 'offline', statKey: 'totalBulls', target: 50, chain: 'bullseye', tier: 2 },
      { id: 'hundred_bulls', name: 'Bullseye! III', description: 'The center is your home. 100 bullseyes and counting.', icon: 'ğŸ¯', rarity: 'epic', mode: 'offline', statKey: 'totalBulls', target: 100, chain: 'bullseye', tier: 3 },
      { id: 'twofifty_bulls', name: 'Bullseye! IV', description: 'Master of the center. 250 bullseyes.', icon: 'ğŸ¯', rarity: 'legendary', mode: 'offline', statKey: 'totalBulls', target: 250, chain: 'bullseye', tier: 4 },

      // Victory Chain
      { id: 'five_wins', name: 'Victory I', description: 'You\'re heating up! Claim 5 victories.', icon: 'ğŸ†', rarity: 'uncommon', mode: 'offline', statKey: 'totalGamesWon', target: 5, chain: 'victory', tier: 1 },
      { id: 'twenty_wins', name: 'Victory II', description: 'They fear your name. Dominate with 20 wins.', icon: 'ğŸ†', rarity: 'rare', mode: 'offline', statKey: 'totalGamesWon', target: 20, chain: 'victory', tier: 2 },
      { id: 'fifty_wins', name: 'Victory III', description: 'A true champion emerges. Conquer 50 games.', icon: 'ğŸ†', rarity: 'epic', mode: 'offline', statKey: 'totalGamesWon', target: 50, chain: 'victory', tier: 3 },
      { id: 'hundred_wins', name: 'Victory IV', description: 'Unstoppable force. 100 victories.', icon: 'ğŸ†', rarity: 'legendary', mode: 'offline', statKey: 'totalGamesWon', target: 100, chain: 'victory', tier: 4 },

      // Global Chain - Online progression
      { id: 'first_online', name: 'Global I', description: 'Step into the arena. Face your first online opponent.', icon: 'ğŸŒ', rarity: 'common', mode: 'online', chain: 'global', tier: 1 },
      { id: 'first_online_win', name: 'Global II', description: 'Real opponents, real pressure, real victory.', icon: 'ğŸŒ', rarity: 'uncommon', mode: 'online', chain: 'global', tier: 2 },
      { id: 'ten_online_wins', name: 'Global III', description: 'Battle-tested. Defeat 10 online challengers.', icon: 'ğŸŒ', rarity: 'rare', mode: 'online', statKey: 'totalOnlineWins', target: 10, chain: 'global', tier: 3 },
      { id: 'fifty_online_wins', name: 'Global IV', description: 'World-class competitor. 50 online victories.', icon: 'ğŸŒ', rarity: 'epic', mode: 'online', statKey: 'totalOnlineWins', target: 50, chain: 'global', tier: 4 },

      // Checkout Chain
      { id: 'big_checkout', name: 'Checkout I', description: 'Nerves of steel. Checkout 100+ in one visit.', icon: 'ğŸ¯', rarity: 'uncommon', mode: 'offline', statKey: 'highestCheckout', target: 100, isThreshold: true, chain: 'checkout', tier: 1 },
      { id: 'huge_checkout', name: 'Checkout II', description: 'The impossible made possible. Checkout 150+ points.', icon: 'ğŸ¯', rarity: 'rare', mode: 'offline', statKey: 'highestCheckout', target: 150, isThreshold: true, chain: 'checkout', tier: 2 },
      { id: 'max_checkout', name: 'Checkout III', description: 'The ultimate finish. Checkout 170 - the maximum.', icon: 'ğŸ¯', rarity: 'legendary', mode: 'offline', statKey: 'highestCheckout', target: 170, isThreshold: true, chain: 'checkout', tier: 3 },

      // Triple Chain
      { id: 'fifty_triples', name: 'Triple I', description: 'Treble trouble for opponents. Hit 50 triples.', icon: '3ï¸âƒ£', rarity: 'uncommon', mode: 'offline', statKey: 'totalTriples', target: 50, chain: 'triple', tier: 1 },
      { id: 'two_hundred_triples', name: 'Triple II', description: 'The triple 20 is your playground. 200 triples.', icon: '3ï¸âƒ£', rarity: 'rare', mode: 'offline', statKey: 'totalTriples', target: 200, chain: 'triple', tier: 2 },
      { id: 'five_hundred_triples', name: 'Triple III', description: 'Triple mastery achieved. 500 triples.', icon: '3ï¸âƒ£', rarity: 'epic', mode: 'offline', statKey: 'totalTriples', target: 500, chain: 'triple', tier: 3 }
    ];

    // Time-Limited Achievements - Weekly rotating challenges synced via Firebase
    // These rotate on a 4-week cycle
    const TIME_LIMITED_ACHIEVEMENTS = [
      // Week 1 - 180 Focus
      {
        id: 'weekly_180_sprint',
        name: 'Maximum Week',
        description: 'Hit 10 perfect 180s this week',
        icon: 'ğŸ’¯',
        rarity: 'rare',
        statKey: 'weekly180s',
        target: 10,
        week: 1,
        reward: '180 Master Badge'
      },
      // Week 2 - Bullseye Focus
      {
        id: 'weekly_bulls_blitz',
        name: 'Bulls Week',
        description: 'Hit 25 bullseyes this week',
        icon: 'ğŸ¯',
        rarity: 'rare',
        statKey: 'weeklyBulls',
        target: 25,
        week: 2,
        reward: 'Bullseye Badge'
      },
      // Week 3 - Victory Focus
      {
        id: 'weekly_win_streak',
        name: 'Victory Week',
        description: 'Win 10 games this week',
        icon: 'ğŸ†',
        rarity: 'rare',
        statKey: 'weeklyWins',
        target: 10,
        week: 3,
        reward: 'Champion Badge'
      },
      // Week 4 - Triples Focus
      {
        id: 'weekly_triple_threat',
        name: 'Triples Week',
        description: 'Hit 50 triples this week',
        icon: '3ï¸âƒ£',
        rarity: 'rare',
        statKey: 'weeklyTriples',
        target: 50,
        week: 4,
        reward: 'Triple Badge'
      }
    ];

    // Get current week number (1-4 rotation)
    const getCurrentWeekNumber = () => {
      const now = new Date();
      const startOfYear = new Date(now.getFullYear(), 0, 1);
      const weekNumber = Math.ceil((((now - startOfYear) / 86400000) + startOfYear.getDay() + 1) / 7);
      return ((weekNumber - 1) % 4) + 1; // Returns 1-4
    };

    // Get the current active time-limited achievement
    const getActiveTimeLimitedAchievement = () => {
      const currentWeek = getCurrentWeekNumber();
      return TIME_LIMITED_ACHIEVEMENTS.find(a => a.week === currentWeek);
    };

    // Create default weekly challenge data for a given week
    const createDefaultWeeklyChallengeData = (weekNumber) => ({
      weekNumber: weekNumber,
      challengeId: TIME_LIMITED_ACHIEVEMENTS.find(a => a.week === weekNumber)?.id,
      stats: { weekly180s: 0, weeklyBulls: 0, weeklyWins: 0, weeklyTriples: 0 },
      completed: false,
      completedChallenges: []
    });

    // Validate weekly challenge data structure from localStorage
    const isValidWeeklyChallengeData = (data) => {
      if (!data || typeof data !== 'object') return false;
      if (typeof data.weekNumber !== 'number') return false;
      if (!data.stats || typeof data.stats !== 'object') return false;
      if (typeof data.completed !== 'boolean') return false;
      if (!Array.isArray(data.completedChallenges)) return false;
      return true;
    };

    // Get time until next weekly reset (Sunday midnight)
    const getTimeUntilWeeklyReset = () => {
      const now = new Date();
      const nextSunday = new Date(now);
      nextSunday.setDate(now.getDate() + (7 - now.getDay()));
      nextSunday.setHours(0, 0, 0, 0);
      return nextSunday - now;
    };

    // Format time remaining
    const formatTimeRemaining = (ms) => {
      const days = Math.floor(ms / (1000 * 60 * 60 * 24));
      const hours = Math.floor((ms % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
      if (days > 0) return `${days}d ${hours}h`;
      if (hours > 0) return `${hours}h ${minutes}m`;
      return `${minutes}m`;
    };

    // Daily Challenges - Rotating daily goals that reset at midnight
    const DAILY_CHALLENGES_POOL = [
      // 180s challenges
      { id: 'daily_180_1', name: 'Maximum!', description: 'Hit 1 perfect 180', icon: 'ğŸ’¯', statKey: 'daily180s', target: 1, difficulty: 'easy' },
      { id: 'daily_180_3', name: 'Triple Maximum', description: 'Hit 3 perfect 180s', icon: 'ğŸ’¯', statKey: 'daily180s', target: 3, difficulty: 'medium' },
      { id: 'daily_180_5', name: '180 Machine', description: 'Hit 5 perfect 180s', icon: 'ğŸ’¯', statKey: 'daily180s', target: 5, difficulty: 'hard' },
      // Bulls challenges
      { id: 'daily_bulls_5', name: 'Bullseye Starter', description: 'Hit 5 bullseyes', icon: 'ğŸ¯', statKey: 'dailyBulls', target: 5, difficulty: 'easy' },
      { id: 'daily_bulls_15', name: 'Bulls on Target', description: 'Hit 15 bullseyes', icon: 'ğŸ¯', statKey: 'dailyBulls', target: 15, difficulty: 'medium' },
      { id: 'daily_bulls_30', name: 'Bull Master', description: 'Hit 30 bullseyes', icon: 'ğŸ¯', statKey: 'dailyBulls', target: 30, difficulty: 'hard' },
      // Wins challenges
      { id: 'daily_wins_1', name: 'First Win', description: 'Win 1 game', icon: 'ğŸ†', statKey: 'dailyWins', target: 1, difficulty: 'easy' },
      { id: 'daily_wins_3', name: 'Winning Streak', description: 'Win 3 games', icon: 'ğŸ†', statKey: 'dailyWins', target: 3, difficulty: 'medium' },
      { id: 'daily_wins_5', name: 'Dominant Day', description: 'Win 5 games', icon: 'ğŸ†', statKey: 'dailyWins', target: 5, difficulty: 'hard' },
      // Games played challenges
      { id: 'daily_games_3', name: 'Warm Up', description: 'Play 3 games', icon: 'ğŸ®', statKey: 'dailyGames', target: 3, difficulty: 'easy' },
      { id: 'daily_games_5', name: 'Practice Run', description: 'Play 5 games', icon: 'ğŸ®', statKey: 'dailyGames', target: 5, difficulty: 'medium' },
      { id: 'daily_games_10', name: 'Marathon', description: 'Play 10 games', icon: 'ğŸ®', statKey: 'dailyGames', target: 10, difficulty: 'hard' },
      // Triples challenges
      { id: 'daily_triples_10', name: 'Triple Starter', description: 'Hit 10 triples', icon: '3ï¸âƒ£', statKey: 'dailyTriples', target: 10, difficulty: 'easy' },
      { id: 'daily_triples_25', name: 'Triple Threat', description: 'Hit 25 triples', icon: '3ï¸âƒ£', statKey: 'dailyTriples', target: 25, difficulty: 'medium' },
      { id: 'daily_triples_50', name: 'Triple Master', description: 'Hit 50 triples', icon: '3ï¸âƒ£', statKey: 'dailyTriples', target: 50, difficulty: 'hard' },
      // Score challenges
      { id: 'daily_score_500', name: 'Score Seeker', description: 'Score 500 points', icon: 'ğŸ“Š', statKey: 'dailyScore', target: 500, difficulty: 'easy' },
      { id: 'daily_score_1500', name: 'Point Collector', description: 'Score 1500 points', icon: 'ğŸ“Š', statKey: 'dailyScore', target: 1500, difficulty: 'medium' },
      { id: 'daily_score_3000', name: 'High Scorer', description: 'Score 3000 points', icon: 'ğŸ“Š', statKey: 'dailyScore', target: 3000, difficulty: 'hard' }
    ];

    // Difficulty level colors for challenge UI
    const DIFFICULTY_COLORS = {
      easy: '#27ae60',
      medium: '#f39c12',
      hard: '#e74c3c'
    };

    // AI opponent difficulty levels and accuracy percentages
    const AI_DIFFICULTIES = {
      BEGINNER: { key: 'beginner', accuracy: 35, label: 'Beginner' },
      INTERMEDIATE: { key: 'intermediate', accuracy: 60, label: 'Intermediate' },
      EXPERT: { key: 'expert', accuracy: 80, label: 'Expert' },
      IMPOSSIBLE: { key: 'impossible', accuracy: 95, label: 'Impossible' }
    };

    // Generate daily challenges based on date seed
    const generateDailyChallenges = (dateString) => {
      const seed = dateString.split('-').reduce((acc, val) => acc + parseInt(val), 0);
      const shuffled = [...DAILY_CHALLENGES_POOL].sort((a, b) => {
        const hashA = (seed * 31 + a.id.charCodeAt(0)) % 1000;
        const hashB = (seed * 31 + b.id.charCodeAt(0)) % 1000;
        return hashA - hashB;
      });
      const easy = shuffled.find(c => c.difficulty === 'easy');
      const medium = shuffled.find(c => c.difficulty === 'medium');
      const hard = shuffled.find(c => c.difficulty === 'hard');
      return [easy, medium, hard].filter(Boolean);
    };

    // Get today's date string in YYYY-MM-DD format
    const getTodayString = () => {
      const today = new Date();
      return `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
    };

    // Create default daily challenge data for a given date
    const createDefaultDailyChallengeData = (dateString) => ({
      date: dateString,
      challenges: generateDailyChallenges(dateString),
      stats: { daily180s: 0, dailyBulls: 0, dailyWins: 0, dailyGames: 0, dailyTriples: 0, dailyScore: 0 },
      completedChallenges: []
    });

    // Validate daily challenge data structure from localStorage
    const isValidDailyChallengeData = (data) => {
      if (!data || typeof data !== 'object') return false;
      if (typeof data.date !== 'string') return false;
      if (!Array.isArray(data.challenges)) return false;
      if (!data.stats || typeof data.stats !== 'object') return false;
      if (!Array.isArray(data.completedChallenges)) return false;
      // Validate each challenge has required properties
      for (const challenge of data.challenges) {
        if (!challenge.id || !challenge.statKey || typeof challenge.target !== 'number') {
          return false;
        }
      }
      return true;
    };

    // Country list for player nationality selection (static data, moved outside component for performance)
    const COUNTRIES = [
      { name: 'Afghanistan', flag: 'ğŸ‡¦ğŸ‡«' }, { name: 'Albania', flag: 'ğŸ‡¦ğŸ‡±' }, { name: 'Algeria', flag: 'ğŸ‡©ğŸ‡¿' },
      { name: 'Argentina', flag: 'ğŸ‡¦ğŸ‡·' }, { name: 'Armenia', flag: 'ğŸ‡¦ğŸ‡²' }, { name: 'Australia', flag: 'ğŸ‡¦ğŸ‡º' },
      { name: 'Austria', flag: 'ğŸ‡¦ğŸ‡¹' }, { name: 'Azerbaijan', flag: 'ğŸ‡¦ğŸ‡¿' }, { name: 'Bahrain', flag: 'ğŸ‡§ğŸ‡­' },
      { name: 'Bangladesh', flag: 'ğŸ‡§ğŸ‡©' }, { name: 'Belarus', flag: 'ğŸ‡§ğŸ‡¾' }, { name: 'Belgium', flag: 'ğŸ‡§ğŸ‡ª' },
      { name: 'Bolivia', flag: 'ğŸ‡§ğŸ‡´' }, { name: 'Bosnia', flag: 'ğŸ‡§ğŸ‡¦' }, { name: 'Brazil', flag: 'ğŸ‡§ğŸ‡·' },
      { name: 'Bulgaria', flag: 'ğŸ‡§ğŸ‡¬' }, { name: 'Cambodia', flag: 'ğŸ‡°ğŸ‡­' }, { name: 'Canada', flag: 'ğŸ‡¨ğŸ‡¦' },
      { name: 'Chile', flag: 'ğŸ‡¨ğŸ‡±' }, { name: 'China', flag: 'ğŸ‡¨ğŸ‡³' }, { name: 'Colombia', flag: 'ğŸ‡¨ğŸ‡´' },
      { name: 'Costa Rica', flag: 'ğŸ‡¨ğŸ‡·' }, { name: 'Croatia', flag: 'ğŸ‡­ğŸ‡·' }, { name: 'Cuba', flag: 'ğŸ‡¨ğŸ‡º' },
      { name: 'Cyprus', flag: 'ğŸ‡¨ğŸ‡¾' }, { name: 'Czech Republic', flag: 'ğŸ‡¨ğŸ‡¿' }, { name: 'Denmark', flag: 'ğŸ‡©ğŸ‡°' },
      { name: 'Ecuador', flag: 'ğŸ‡ªğŸ‡¨' }, { name: 'Egypt', flag: 'ğŸ‡ªğŸ‡¬' }, { name: 'England', flag: 'ğŸ´ó §ó ¢ó ¥ó ®ó §ó ¿' },
      { name: 'Estonia', flag: 'ğŸ‡ªğŸ‡ª' }, { name: 'Ethiopia', flag: 'ğŸ‡ªğŸ‡¹' }, { name: 'Finland', flag: 'ğŸ‡«ğŸ‡®' },
      { name: 'France', flag: 'ğŸ‡«ğŸ‡·' }, { name: 'Georgia', flag: 'ğŸ‡¬ğŸ‡ª' }, { name: 'Germany', flag: 'ğŸ‡©ğŸ‡ª' },
      { name: 'Ghana', flag: 'ğŸ‡¬ğŸ‡­' }, { name: 'Greece', flag: 'ğŸ‡¬ğŸ‡·' }, { name: 'Hong Kong', flag: 'ğŸ‡­ğŸ‡°' },
      { name: 'Hungary', flag: 'ğŸ‡­ğŸ‡º' }, { name: 'Iceland', flag: 'ğŸ‡®ğŸ‡¸' }, { name: 'India', flag: 'ğŸ‡®ğŸ‡³' },
      { name: 'Indonesia', flag: 'ğŸ‡®ğŸ‡©' }, { name: 'Iran', flag: 'ğŸ‡®ğŸ‡·' }, { name: 'Iraq', flag: 'ğŸ‡®ğŸ‡¶' },
      { name: 'Ireland', flag: 'ğŸ‡®ğŸ‡ª' }, { name: 'Israel', flag: 'ğŸ‡®ğŸ‡±' }, { name: 'Italy', flag: 'ğŸ‡®ğŸ‡¹' },
      { name: 'Jamaica', flag: 'ğŸ‡¯ğŸ‡²' }, { name: 'Japan', flag: 'ğŸ‡¯ğŸ‡µ' }, { name: 'Jordan', flag: 'ğŸ‡¯ğŸ‡´' },
      { name: 'Kazakhstan', flag: 'ğŸ‡°ğŸ‡¿' }, { name: 'Kenya', flag: 'ğŸ‡°ğŸ‡ª' }, { name: 'Kuwait', flag: 'ğŸ‡°ğŸ‡¼' },
      { name: 'Latvia', flag: 'ğŸ‡±ğŸ‡»' }, { name: 'Lebanon', flag: 'ğŸ‡±ğŸ‡§' }, { name: 'Libya', flag: 'ğŸ‡±ğŸ‡¾' },
      { name: 'Lithuania', flag: 'ğŸ‡±ğŸ‡¹' }, { name: 'Luxembourg', flag: 'ğŸ‡±ğŸ‡º' }, { name: 'Malaysia', flag: 'ğŸ‡²ğŸ‡¾' },
      { name: 'Malta', flag: 'ğŸ‡²ğŸ‡¹' }, { name: 'Mexico', flag: 'ğŸ‡²ğŸ‡½' }, { name: 'Morocco', flag: 'ğŸ‡²ğŸ‡¦' },
      { name: 'Nepal', flag: 'ğŸ‡³ğŸ‡µ' }, { name: 'Netherlands', flag: 'ğŸ‡³ğŸ‡±' }, { name: 'New Zealand', flag: 'ğŸ‡³ğŸ‡¿' },
      { name: 'Nigeria', flag: 'ğŸ‡³ğŸ‡¬' }, { name: 'North Korea', flag: 'ğŸ‡°ğŸ‡µ' }, { name: 'Northern Ireland', flag: 'ğŸ‡¬ğŸ‡§' },
      { name: 'Norway', flag: 'ğŸ‡³ğŸ‡´' }, { name: 'Pakistan', flag: 'ğŸ‡µğŸ‡°' }, { name: 'Palestine', flag: 'ğŸ‡µğŸ‡¸' },
      { name: 'Panama', flag: 'ğŸ‡µğŸ‡¦' }, { name: 'Peru', flag: 'ğŸ‡µğŸ‡ª' }, { name: 'Philippines', flag: 'ğŸ‡µğŸ‡­' },
      { name: 'Poland', flag: 'ğŸ‡µğŸ‡±' }, { name: 'Portugal', flag: 'ğŸ‡µğŸ‡¹' }, { name: 'Qatar', flag: 'ğŸ‡¶ğŸ‡¦' },
      { name: 'Romania', flag: 'ğŸ‡·ğŸ‡´' }, { name: 'Russia', flag: 'ğŸ‡·ğŸ‡º' }, { name: 'Saudi Arabia', flag: 'ğŸ‡¸ğŸ‡¦' },
      { name: 'Scotland', flag: 'ğŸ´ó §ó ¢ó ³ó £ó ´ó ¿' }, { name: 'Senegal', flag: 'ğŸ‡¸ğŸ‡³' }, { name: 'Serbia', flag: 'ğŸ‡·ğŸ‡¸' },
      { name: 'Singapore', flag: 'ğŸ‡¸ğŸ‡¬' }, { name: 'Slovakia', flag: 'ğŸ‡¸ğŸ‡°' }, { name: 'Slovenia', flag: 'ğŸ‡¸ğŸ‡®' },
      { name: 'South Africa', flag: 'ğŸ‡¿ğŸ‡¦' }, { name: 'South Korea', flag: 'ğŸ‡°ğŸ‡·' }, { name: 'Spain', flag: 'ğŸ‡ªğŸ‡¸' },
      { name: 'Sri Lanka', flag: 'ğŸ‡±ğŸ‡°' }, { name: 'Sweden', flag: 'ğŸ‡¸ğŸ‡ª' }, { name: 'Switzerland', flag: 'ğŸ‡¨ğŸ‡­' },
      { name: 'Syria', flag: 'ğŸ‡¸ğŸ‡¾' }, { name: 'Taiwan', flag: 'ğŸ‡¹ğŸ‡¼' }, { name: 'Thailand', flag: 'ğŸ‡¹ğŸ‡­' },
      { name: 'Tunisia', flag: 'ğŸ‡¹ğŸ‡³' }, { name: 'Turkey', flag: 'ğŸ‡¹ğŸ‡·' }, { name: 'UAE', flag: 'ğŸ‡¦ğŸ‡ª' },
      { name: 'Uganda', flag: 'ğŸ‡ºğŸ‡¬' }, { name: 'Ukraine', flag: 'ğŸ‡ºğŸ‡¦' }, { name: 'United Kingdom', flag: 'ğŸ‡¬ğŸ‡§' },
      { name: 'Uruguay', flag: 'ğŸ‡ºğŸ‡¾' }, { name: 'USA', flag: 'ğŸ‡ºğŸ‡¸' }, { name: 'Uzbekistan', flag: 'ğŸ‡ºğŸ‡¿' },
      { name: 'Venezuela', flag: 'ğŸ‡»ğŸ‡ª' }, { name: 'Vietnam', flag: 'ğŸ‡»ğŸ‡³' }, { name: 'Wales', flag: 'ğŸ´ó §ó ¢ó ·ó ¬ó ³ó ¿' },
      { name: 'Yemen', flag: 'ğŸ‡¾ğŸ‡ª' }, { name: 'Zimbabwe', flag: 'ğŸ‡¿ğŸ‡¼' }
    ];

    // Checkout suggestions for darts (static data, moved outside component for performance)
    const CHECKOUT_SUGGESTIONS = {
      170: 'T20 T20 Bull', 167: 'T20 T19 Bull', 164: 'T20 T18 Bull', 161: 'T20 T17 Bull',
      160: 'T20 T20 D20', 158: 'T20 T20 D19', 157: 'T20 T19 D20', 156: 'T20 T20 D18',
      155: 'T20 T19 D19', 154: 'T20 T18 D20', 153: 'T20 T19 D18', 152: 'T20 T20 D16',
      151: 'T20 T17 D20', 150: 'T20 T18 D18', 149: 'T20 T19 D16', 148: 'T20 T20 D14',
      147: 'T20 T17 D18', 146: 'T20 T18 D16', 145: 'T20 T19 D14', 144: 'T20 T20 D12',
      143: 'T20 T17 D16', 142: 'T20 T14 D20', 141: 'T20 T19 D12', 140: 'T20 T20 D10',
      139: 'T20 T13 D20', 138: 'T20 T18 D12', 137: 'T20 T19 D10', 136: 'T20 T20 D8',
      135: 'T20 T17 D12', 134: 'T20 T14 D16', 133: 'T20 T19 D8', 132: 'T20 T16 D12',
      131: 'T20 T13 D16', 130: 'T20 T18 D8', 129: 'T19 T16 D12', 128: 'T18 T14 D16',
      127: 'T20 T17 D8', 126: 'T19 T19 D6', 125: 'T20 T19 D4', 124: 'T20 T16 D8',
      123: 'T19 T16 D9', 122: 'T18 T18 D7', 121: 'T20 T11 D14', 120: 'T20 S20 D20',
      119: 'T19 T12 D13', 118: 'T20 S18 D20', 117: 'T20 S17 D20', 116: 'T20 S16 D20',
      115: 'T20 S15 D20', 114: 'T20 S14 D20', 113: 'T20 S13 D20', 112: 'T20 S12 D20',
      111: 'T20 S11 D20', 110: 'T20 S10 D20', 109: 'T20 S9 D20', 108: 'T20 S8 D20',
      107: 'T19 S10 D20', 106: 'T20 S6 D20', 105: 'T20 S5 D20', 104: 'T20 S4 D20',
      103: 'T20 S3 D20', 102: 'T20 S2 D20', 101: 'T20 S1 D20', 100: 'T20 D20',
      99: 'T19 S10 D16', 98: 'T20 D19', 97: 'T19 D20', 96: 'T20 D18', 95: 'T19 D19',
      94: 'T18 D20', 93: 'T19 D18', 92: 'T20 D16', 91: 'T17 D20', 90: 'T18 D18',
      89: 'T19 D16', 88: 'T20 D14', 87: 'T17 D18', 86: 'T18 D16', 85: 'T19 D14',
      84: 'T20 D12', 83: 'T17 D16', 82: 'T14 D20', 81: 'T19 D12', 80: 'T20 D10',
      79: 'T13 D20', 78: 'T18 D12', 77: 'T19 D10', 76: 'T20 D8', 75: 'T17 D12',
      74: 'T14 D16', 73: 'T19 D8', 72: 'T16 D12', 71: 'T13 D16', 70: 'T18 D8',
      69: 'T19 D6', 68: 'T20 D4', 67: 'T17 D8', 66: 'T10 D18', 65: 'T19 D4',
      64: 'T16 D8', 63: 'T13 D12', 62: 'T10 D16', 61: 'T15 D8', 60: 'S20 D20',
      59: 'S19 D20', 58: 'S18 D20', 57: 'S17 D20', 56: 'S16 D20', 55: 'S15 D20',
      54: 'S14 D20', 53: 'S13 D20', 52: 'S12 D20', 51: 'S11 D20', 50: 'S10 D20',
      49: 'S9 D20', 48: 'S8 D20', 47: 'S7 D20', 46: 'S6 D20', 45: 'S5 D20',
      44: 'S4 D20', 43: 'S3 D20', 42: 'S2 D20', 41: 'S1 D20', 40: 'D20',
      38: 'D19', 36: 'D18', 34: 'D17', 32: 'D16', 30: 'D15', 28: 'D14',
      26: 'D13', 24: 'D12', 22: 'D11', 20: 'D10', 18: 'D9', 16: 'D8',
      14: 'D7', 12: 'D6', 10: 'D5', 8: 'D4', 6: 'D3', 4: 'D2', 2: 'D1'
    };

    const DartsGame = () => {
      const [gameState, setGameState] = useState('landing');
      const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
      const [players, setPlayers] = useState([]);
      const [currentPlayerIndex, setCurrentPlayerIndex] = useState(0);
      const [dartsThrown, setDartsThrown] = useState(0);
      const [currentTurnScore, setCurrentTurnScore] = useState(0);
      const [throwHistory, setThrowHistory] = useState([]);
      const [aimPosition, setAimPosition] = useState({ x: CENTER, y: CENTER });
      const [isAiming, setIsAiming] = useState(false);
      const [power, setPower] = useState(0);
      const [isPowerCharging, setIsPowerCharging] = useState(false);
      const [dartPositions, setDartPositions] = useState([]);
      const [showScorePopup, setShowScorePopup] = useState(null);
      const [gameStats, setGameStats] = useState({});
      const [winner, setWinner] = useState(null);
      const [skillLevel, setSkillLevel] = useState(60); // Default to Intermediate
      const [soundEnabled, setSoundEnabled] = useState(true);
      const [showStats, setShowStats] = useState(false);
      const [playerSetup, setPlayerSetup] = useState({ count: 1, names: ['Player 1', 'Player 2', 'Player 3', 'Player 4'], gameMode: 501, aiPlayers: [false, false, false, false], aiDifficulty: [null, null, null, null], legsPerSet: 3, setsToWin: 1, flags: ['ğŸ´ó §ó ¢ó ¥ó ®ó §ó ¿', 'ğŸ´ó §ó ¢ó ¥ó ®ó §ó ¿', 'ğŸ´ó §ó ¢ó ¥ó ®ó §ó ¿', 'ğŸ´ó §ó ¢ó ¥ó ®ó §ó ¿'] });
      const [animatingDart, setAnimatingDart] = useState(null);
      const [checkout, setCheckout] = useState(null);
      const [triplesHit, setTriplesHit] = useState(0);
      const [isCheckoutPosition, setIsCheckoutPosition] = useState(false);
      const [legScores, setLegScores] = useState([]); // Track legs won per player
      const [setScores, setSetScores] = useState([]); // Track sets won per player
      const [matchWinner, setMatchWinner] = useState(null);
      const [legDartsThrown, setLegDartsThrown] = useState([]); // Track darts thrown per player in current leg
      const [showNineDarter, setShowNineDarter] = useState(false);
      const [currentTurnThrows, setCurrentTurnThrows] = useState([]); // Track throws in current turn for wobble detection
      const [aimWobble, setAimWobble] = useState({ x: 0, y: 0 }); // Wobble offset for aim position
      const [isMobile, setIsMobile] = useState(() => {
        // Robust mobile detection: check screen width, touch capability, and user agent
        const isSmallScreen = window.innerWidth < 600;
        const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const isMobileUA = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        return isSmallScreen || (hasTouchScreen && isMobileUA);
      }); // Mobile detection for responsive UI

      // Online multiplayer states
      const [onlineMode, setOnlineMode] = useState(false); // true when in online multiplayer
      const [matchmakingState, setMatchmakingState] = useState(null); // null, 'searching', 'found', 'playing'
      const [gameRoomId, setGameRoomId] = useState(null); // Firebase room ID
      const [playerId, setPlayerId] = useState(null); // Player index (0 or 1) in the game
      const [myAuthId, setMyAuthId] = useState(null); // Auth UID for matchmaking queue
      const [opponentName, setOpponentName] = useState('');
      const [opponentFlag, setOpponentFlag] = useState('ğŸŒ');
      const gameRoomRef = useRef(null); // Firebase room reference
      const opponentWasConnected = useRef(false); // Track if opponent was ever connected

      // Practice mode states
      const [practiceMode, setPracticeMode] = useState(false); // true when in practice mode
      const [practiceSkillLevel, setPracticeSkillLevel] = useState(null); // skill level for practice
      const [practiceStats, setPracticeStats] = useState({
        dartsThrown: 0,
        t20: 0,
        t19: 0,
        t18: 0,
        bulls: 0,
        singleBull: 0,
        triples: 0,
        doubles: 0,
        totalScore: 0
      }); // track what player hits in practice

      // Achievements system
      const [unlockedAchievements, setUnlockedAchievements] = useState(() => {
        try {
          const saved = localStorage.getItem('quikdarts_achievements');
          return saved ? JSON.parse(saved) : [];
        } catch (error) {
          console.error('Failed to load achievements from localStorage:', error);
          return [];
        }
      });
      const [achievementPopup, setAchievementPopup] = useState(null); // Currently showing achievement
      const [showAchievements, setShowAchievements] = useState(false); // Show achievements gallery
      const [showLoginModal, setShowLoginModal] = useState(false); // Show login modal
      const [currentUser, setCurrentUser] = useState(null); // Current signed-in user
      const [achievementStats, setAchievementStats] = useState(() => {
        try {
          const saved = localStorage.getItem('quikdarts_stats');
          return saved ? JSON.parse(saved) : {
            totalGamesPlayed: 0,
            totalGamesWon: 0,
            total180s: 0,
            totalNineDarters: 0,
            totalOnlineGames: 0,
            totalOnlineWins: 0,
            totalBulls: 0,
            totalTriples: 0,
            highestCheckout: 0
          };
        } catch (error) {
          console.error('Failed to load achievement stats from localStorage:', error);
          return {
            totalGamesPlayed: 0,
            totalGamesWon: 0,
            total180s: 0,
            totalNineDarters: 0,
            totalOnlineGames: 0,
            totalOnlineWins: 0,
            totalBulls: 0,
            totalTriples: 0,
            highestCheckout: 0
          };
        }
      });

      // Weekly time-limited challenge state - synced via Firebase, resets weekly
      const [weeklyChallenge, setWeeklyChallenge] = useState(() => {
        const currentWeek = getCurrentWeekNumber();
        try {
          const saved = localStorage.getItem('quikdarts_weekly_challenge');
          if (saved) {
            const parsed = JSON.parse(saved);
            // Validate data structure and check if it's from the current week
            if (isValidWeeklyChallengeData(parsed) && parsed.weekNumber === currentWeek) {
              return parsed;
            }
          }
        } catch (error) {
          console.error('Failed to load weekly challenge:', error);
        }
        return createDefaultWeeklyChallengeData(currentWeek);
      });

      // Time remaining until weekly reset
      const [timeUntilReset, setTimeUntilReset] = useState(getTimeUntilWeeklyReset());

      // Daily challenges state - resets at midnight each day
      const [dailyChallengeData, setDailyChallengeData] = useState(() => {
        const today = getTodayString();
        try {
          const saved = localStorage.getItem('quikdarts_daily_challenges');
          if (saved) {
            const parsed = JSON.parse(saved);
            // Validate data structure and check if it's from today
            if (isValidDailyChallengeData(parsed) && parsed.date === today) {
              return parsed;
            }
          }
        } catch (error) {
          console.error('Failed to load daily challenges:', error);
        }
        return createDefaultDailyChallengeData(today);
      });

      // Dartboard theme customization state
      const [selectedThemeId, setSelectedThemeId] = useState(() => {
        try {
          const saved = localStorage.getItem('quikdarts_theme');
          if (saved) {
            const parsed = JSON.parse(saved);
            // Validate the saved theme ID
            if (isValidThemeId(parsed.themeId)) {
              return parsed.themeId;
            }
          }
          return DEFAULT_THEME_ID;
        } catch (error) {
          console.error('Failed to load theme from localStorage:', error);
          return DEFAULT_THEME_ID;
        }
      });

      const [selectedNeonColor, setSelectedNeonColor] = useState(() => {
        try {
          const saved = localStorage.getItem('quikdarts_theme');
          if (saved) {
            const parsed = JSON.parse(saved);
            if (parsed.neonColor && Object.values(NEON_COLOR_OPTIONS).includes(parsed.neonColor)) {
              return parsed.neonColor;
            }
          }
          return NEON_COLOR_OPTIONS.CYAN;
        } catch (error) {
          console.error('Failed to load neon color from localStorage:', error);
          return NEON_COLOR_OPTIONS.CYAN;
        }
      });

      const [neonPulsePhase, setNeonPulsePhase] = useState(0); // For neon pulse animation

      // Save theme selection to localStorage
      const saveThemeSelection = useCallback((themeId, neonColor) => {
        try {
          const themeData = {
            themeId: themeId,
            neonColor: neonColor,
            savedAt: new Date().toISOString()
          };
          localStorage.setItem('quikdarts_theme', JSON.stringify(themeData));
        } catch (error) {
          console.error('Failed to save theme to localStorage:', error);
        }
      }, []);

      // Update theme selection handler
      const handleThemeChange = useCallback((themeId) => {
        if (isValidThemeId(themeId)) {
          setSelectedThemeId(themeId);
          saveThemeSelection(themeId, selectedNeonColor);
        }
      }, [selectedNeonColor, saveThemeSelection]);

      // Update neon color selection handler
      const handleNeonColorChange = useCallback((neonColor) => {
        if (Object.values(NEON_COLOR_OPTIONS).includes(neonColor)) {
          setSelectedNeonColor(neonColor);
          saveThemeSelection(selectedThemeId, neonColor);
        }
      }, [selectedThemeId, saveThemeSelection]);

      // Get current theme and colors
      const currentTheme = getThemeById(selectedThemeId);
      const currentThemeColors = getThemeColors(currentTheme, selectedNeonColor);

      // Neon pulse animation effect
      useEffect(() => {
        if (currentTheme.effects.pulseAnimation) {
          const interval = setInterval(() => {
            setNeonPulsePhase(prev => (prev + 0.05) % (2 * Math.PI));
          }, 50);
          return () => clearInterval(interval);
        }
      }, [currentTheme.effects.pulseAnimation]);

      // Mobile detection resize listener
      useEffect(() => {
        const handleResize = () => {
          const isSmallScreen = window.innerWidth < 600;
          const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
          const isMobileUA = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
          setIsMobile(isSmallScreen || (hasTouchScreen && isMobileUA));
        };
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
      }, []);

      const boardRef = useRef(null);
      const powerIntervalRef = useRef(null);
      const powerResetTimeoutRef = useRef(null);
      const matchmakingIntervalRef = useRef(null);
      const audioContext = useRef(null);
      const aimPositionRef = useRef({ x: CENTER, y: CENTER });

      const playSound = useCallback((type) => {
        if (!soundEnabled) return;
        if (!audioContext.current) {
          audioContext.current = new (window.AudioContext || window.webkitAudioContext)();
        }
        const ctx = audioContext.current;
        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(ctx.destination);
        
        switch(type) {
          case 'throw':
            oscillator.frequency.setValueAtTime(200, ctx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.1);
            gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + 0.1);
            break;
          case 'hit':
            oscillator.frequency.setValueAtTime(800, ctx.currentTime);
            gainNode.gain.setValueAtTime(0.2, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.05);
            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + 0.05);
            break;
          case 'bullseye':
            oscillator.frequency.setValueAtTime(523, ctx.currentTime);
            oscillator.frequency.setValueAtTime(659, ctx.currentTime + 0.1);
            oscillator.frequency.setValueAtTime(784, ctx.currentTime + 0.2);
            gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + 0.3);
            break;
          case 'bust':
            oscillator.frequency.setValueAtTime(200, ctx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.3);
            gainNode.gain.setValueAtTime(0.4, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + 0.3);
            break;
          case 'win':
            [523, 659, 784, 1047].forEach((freq, i) => {
              const osc = ctx.createOscillator();
              const gain = ctx.createGain();
              osc.connect(gain);
              gain.connect(ctx.destination);
              osc.frequency.setValueAtTime(freq, ctx.currentTime + i * 0.15);
              gain.gain.setValueAtTime(0.3, ctx.currentTime + i * 0.15);
              gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.15 + 0.2);
              osc.start(ctx.currentTime + i * 0.15);
              osc.stop(ctx.currentTime + i * 0.15 + 0.2);
            });
            break;
          case '180':
            // Exciting ascending celebration sound for 180!
            [392, 523, 659, 784, 1047, 1319].forEach((freq, i) => {
              const osc = ctx.createOscillator();
              const gain = ctx.createGain();
              osc.connect(gain);
              gain.connect(ctx.destination);
              osc.frequency.setValueAtTime(freq, ctx.currentTime + i * 0.08);
              gain.gain.setValueAtTime(0.4, ctx.currentTime + i * 0.08);
              gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.08 + 0.15);
              osc.start(ctx.currentTime + i * 0.08);
              osc.stop(ctx.currentTime + i * 0.08 + 0.15);
            });
            break;
          case 'ninedarter':
            // Epic crowd roar effect
            // Create white noise for crowd roar
            const bufferSize = ctx.sampleRate * 3; // 3 seconds
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
              data[i] = Math.random() * 2 - 1;
            }
            const crowdNoise = ctx.createBufferSource();
            crowdNoise.buffer = buffer;

            const crowdFilter = ctx.createBiquadFilter();
            crowdFilter.type = 'bandpass';
            crowdFilter.frequency.setValueAtTime(800, ctx.currentTime);
            crowdFilter.Q.setValueAtTime(1, ctx.currentTime);

            const crowdGain = ctx.createGain();
            crowdGain.gain.setValueAtTime(0, ctx.currentTime);
            crowdGain.gain.linearRampToValueAtTime(0.3, ctx.currentTime + 0.5);
            crowdGain.gain.setValueAtTime(0.3, ctx.currentTime + 2);
            crowdGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 3);

            crowdNoise.connect(crowdFilter);
            crowdFilter.connect(crowdGain);
            crowdGain.connect(ctx.destination);
            crowdNoise.start(ctx.currentTime);
            crowdNoise.stop(ctx.currentTime + 3);

            // Add epic fanfare over the crowd roar
            [523, 659, 784, 1047, 1319, 1568].forEach((freq, i) => {
              const osc = ctx.createOscillator();
              const gain = ctx.createGain();
              osc.type = 'triangle';
              osc.connect(gain);
              gain.connect(ctx.destination);
              osc.frequency.setValueAtTime(freq, ctx.currentTime + i * 0.15);
              gain.gain.setValueAtTime(0.25, ctx.currentTime + i * 0.15);
              gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.15 + 0.4);
              osc.start(ctx.currentTime + i * 0.15);
              osc.stop(ctx.currentTime + i * 0.15 + 0.4);
            });
            break;
        }
      }, [soundEnabled]);

      // ========== ONLINE MULTIPLAYER FUNCTIONS ==========

      // Whitelist-based sanitization for player names
      // Only allows safe characters - much more secure than blacklist approach
      const sanitizeName = (name) => {
        if (!name || typeof name !== 'string') return 'Player';
        return name
          .slice(0, 20)                                    // Limit length first
          .replace(/[^a-zA-Z0-9\s\-_.!?]/g, '')           // Whitelist: only letters, numbers, spaces, -_.!?
          .replace(/\s+/g, ' ')                            // Collapse multiple spaces
          .trim() || 'Player';
      };

      // Sanitize flag emoji - validates it's a proper emoji and limits length
      const sanitizeFlag = (flag) => {
        if (!flag || typeof flag !== 'string') return 'ğŸŒ';
        // Flag emojis can be up to 28 bytes (regional indicator pairs or flag sequences)
        // Limit to 50 characters to allow for complex emojis while preventing abuse
        const trimmed = flag.slice(0, 50);
        // Basic validation: must contain at least one emoji-like character
        // Regional indicators are in range U+1F1E6 to U+1F1FF, flags use U+1F3F4
        const hasEmoji = /[\u{1F1E6}-\u{1F1FF}]|[\u{1F3F4}]|[\u{1F300}-\u{1F9FF}]/u.test(trimmed);
        return hasEmoji ? trimmed : 'ğŸŒ';
      };

      // Validate numeric values from Firebase to prevent data tampering
      const validateScore = (score, gameMode) => {
        if (typeof score !== 'number' || !Number.isInteger(score)) return gameMode || 501;
        if (score < 0 || score > 501 || score === 1) return gameMode || 501;
        return score;
      };

      const validatePlayerIndex = (index) => {
        if (typeof index !== 'number' || !Number.isInteger(index)) return 0;
        return index === 0 || index === 1 ? index : 0;
      };

      const validateDartsThrown = (darts) => {
        if (typeof darts !== 'number' || !Number.isInteger(darts)) return 0;
        return darts >= 0 && darts <= 3 ? darts : 0;
      };

      const validateTurnScore = (score) => {
        if (typeof score !== 'number' || !Number.isInteger(score)) return 0;
        return score >= 0 && score <= 180 ? score : 0;
      };

      const validateScoreArray = (arr, defaultValue = 0) => {
        if (!Array.isArray(arr) || arr.length !== 2) return [defaultValue, defaultValue];
        return arr.map(val => {
          if (typeof val !== 'number' || !Number.isInteger(val) || val < 0) return defaultValue;
          return val;
        });
      };

      // Validate throw history item from Firebase
      const validateThrowItem = (item) => {
        if (!item || typeof item !== 'object') return null;
        const score = typeof item.score === 'number' && item.score >= 0 && item.score <= 180 ? item.score : 0;
        const label = typeof item.label === 'string' && item.label.length <= 20 ? item.label : 'MISS';
        const player = (item.player === 0 || item.player === 1) ? item.player : 0;
        const multiplier = typeof item.multiplier === 'number' && item.multiplier >= 0 && item.multiplier <= 3 ? item.multiplier : 1;
        return { score, label, player, multiplier };
      };

      // Validate dart position from Firebase
      const validateDartPosition = (pos) => {
        if (!pos || typeof pos !== 'object') return null;
        const x = typeof pos.x === 'number' && pos.x >= 0 && pos.x <= 500 ? pos.x : 250;
        const y = typeof pos.y === 'number' && pos.y >= 0 && pos.y <= 500 ? pos.y : 250;
        return { x, y };
      };

      // Retry wrapper for Firebase operations with exponential backoff
      const retryFirebaseOperation = async (operation, maxRetries = 3) => {
        let lastError;
        for (let attempt = 0; attempt < maxRetries; attempt++) {
          try {
            return await operation();
          } catch (error) {
            lastError = error;
            if (attempt < maxRetries - 1) {
              // Exponential backoff: 100ms, 200ms, 400ms
              await new Promise(resolve => setTimeout(resolve, 100 * Math.pow(2, attempt)));
            }
          }
        }
        throw lastError;
      };

      // Start matchmaking - find a random opponent
      const startMatchmaking = useCallback(async () => {
        if (!database) {
          alert('Firebase not configured. Please add your Firebase credentials to play online.');
          return;
        }

        // Rate limiting: Prevent spamming matchmaking button
        if (matchmakingState === 'searching') {
          return; // Already searching
        }

        setMatchmakingState('searching');
        setOnlineMode(true);
        const queueRef = database.ref('matchmaking_queue');
        const gamesRef = database.ref('games');

        // Wait for authentication and use auth UID as player ID
        const authUser = await authReadyPromise;
        if (!authUser) {
          console.error('Authentication required for online play');
          setMatchmakingState('idle');
          setOnlineMode(false);
          return;
        }

        // Use authenticated user ID (prevents spoofing/spam)
        const myPlayerId = authUser.uid;
        setMyAuthId(myPlayerId);

        // Clean up ALL games where we're a player (ensures clean slate for new matchmaking)
        const gamesSnapshot = await database.ref('games').orderByChild('player1/id').equalTo(myPlayerId).once('value');
        if (gamesSnapshot.exists()) {
          const myGames = gamesSnapshot.val();
          for (const gameId of Object.keys(myGames)) {
            await database.ref(`games/${gameId}`).remove().catch(err => console.error('Failed to delete game:', err));
          }
        }
        // Also check if we're player2 in any games
        const gamesSnapshot2 = await database.ref('games').once('value');
        if (gamesSnapshot2.exists()) {
          const allGames = gamesSnapshot2.val();
          for (const [gameId, gameData] of Object.entries(allGames)) {
            if (gameData.player2 && gameData.player2.id === myPlayerId) {
              await database.ref(`games/${gameId}`).remove().catch(err => console.error('Failed to delete game:', err));
            }
          }
        }

        // Small delay to avoid race condition where both players check queue at exact same time
        setTimeout(() => {
          // Look for available opponent in queue
          queueRef.orderByChild('timestamp').limitToFirst(1).once('value', (snapshot) => {
          if (snapshot.exists()) {
            // Found an opponent - join their game
            const opponentId = Object.keys(snapshot.val())[0];
            const opponentData = snapshot.val()[opponentId];

            // Make sure we're not matching with ourselves
            if (opponentData.playerId === myPlayerId) {
              // This shouldn't happen, but if it does, add ourselves to queue instead
              const myQueueEntry = {
                playerId: myPlayerId,
                name: playerSetup.names[0] || 'Player 1',
                flag: playerSetup.flags[0] || 'ğŸŒ',
                timestamp: firebase.database.ServerValue.TIMESTAMP
              };
              queueRef.child(myPlayerId).set(myQueueEntry);
              return;
            }

            // Note: Opponent will remove themselves from queue when they find the game
            // (we can't remove their entry due to auth rules)

            // Create game room
            const roomId = database.ref().push().key;
            setGameRoomId(roomId);
            gameRoomRef.current = database.ref(`games/${roomId}`);

            // Set up game data (sanitize opponent name from Firebase for security)
            gameRoomRef.current.set({
              player1: {
                id: opponentData.playerId,
                name: sanitizeName(opponentData.name),
                flag: sanitizeFlag(opponentData.flag),
                score: playerSetup.gameMode,
                ready: true
                // connected will be set when player1 joins
              },
              player2: {
                id: myPlayerId,
                name: sanitizeName(playerSetup.names[0]) || 'Player 2',
                flag: playerSetup.flags[0] || 'ğŸŒ',
                score: playerSetup.gameMode,
                ready: true,
                connected: true  // Set immediately so player1 can find this game
              },
              currentPlayer: 0,
              gameMode: playerSetup.gameMode,
              dartsThrown: 0,
              currentTurnScore: 0,
              throwHistory: {},
              dartPositions: {},
              legScores: [0, 0],
              setScores: [0, 0],
              status: 'playing',
              createdAt: firebase.database.ServerValue.TIMESTAMP
            });

            setOpponentName(sanitizeName(opponentData.name));
            setOpponentFlag(sanitizeFlag(opponentData.flag));
            setMatchmakingState('found');

            // Start game as player 2
            setTimeout(() => startOnlineGame(roomId, 1), 1500);

          } else {
            // No opponent found - add self to queue
            const myQueueEntry = {
              playerId: myPlayerId,
              name: sanitizeName(playerSetup.names[0]) || 'Player 1',
              flag: playerSetup.flags[0] || 'ğŸŒ',
              timestamp: firebase.database.ServerValue.TIMESTAMP
            };

            queueRef.child(myPlayerId).set(myQueueEntry);

            // Auto-remove from queue if user disconnects (closes browser, loses connection, etc.)
            queueRef.child(myPlayerId).onDisconnect().remove();

            // Listen for when someone joins OR check if others joined queue while waiting
            matchmakingIntervalRef.current = setInterval(() => {
              // First check if someone created a game with us as player1
              database.ref(`games`).orderByChild('player1/id').equalTo(myPlayerId).once('value', (gameSnapshot) => {
                if (gameSnapshot.exists()) {
                  // Find a recent game where player2 is connected (not a stale game)
                  const games = gameSnapshot.val();
                  const now = Date.now();
                  let activeRoomId = null;
                  let activeGameData = null;

                  for (const [roomId, gameData] of Object.entries(games)) {
                    // Only join if:
                    // 1. player2 is connected (active game waiting for us), AND
                    // 2. game was created within the last 30 seconds (not stale)
                    const gameAge = now - (gameData.createdAt || 0);
                    const isRecent = gameAge < 30000; // 30 seconds
                    const isPlayer2Connected = gameData.player2 && gameData.player2.connected === true;

                    if (isRecent && isPlayer2Connected) {
                      activeRoomId = roomId;
                      activeGameData = gameData;
                      break;
                    } else {
                      // Delete stale game (old or player2 disconnected)
                      database.ref(`games/${roomId}`).remove()
                        .catch(err => console.error(`Failed to delete stale game ${roomId}:`, err));
                    }
                  }

                  // If no active game found, continue waiting (stale games were deleted)
                  if (!activeRoomId) {
                    return;
                  }
                  if (matchmakingIntervalRef.current) {
                    clearInterval(matchmakingIntervalRef.current);
                    matchmakingIntervalRef.current = null;
                  }
                  queueRef.child(myPlayerId).remove();

                  setGameRoomId(activeRoomId);
                  gameRoomRef.current = database.ref(`games/${activeRoomId}`);
                  setOpponentName(sanitizeName(activeGameData.player2.name));
                  setOpponentFlag(sanitizeFlag(activeGameData.player2.flag));
                  setMatchmakingState('found');

                  setTimeout(() => startOnlineGame(activeRoomId, 0), 1500);
                } else {
                  // Also check if there are OTHER players waiting in queue we can join
                  queueRef.orderByChild('timestamp').limitToFirst(2).once('value', (queueSnapshot) => {
                    if (queueSnapshot.exists()) {
                      const queuePlayers = queueSnapshot.val();
                      // Find first player that isn't us
                      const otherPlayerId = Object.keys(queuePlayers).find(id => id !== myPlayerId);

                      if (otherPlayerId) {
                        const otherPlayer = queuePlayers[otherPlayerId];

                        // Join this player's game
                        if (matchmakingIntervalRef.current) {
                          clearInterval(matchmakingIntervalRef.current);
                          matchmakingIntervalRef.current = null;
                        }

                        // Remove myself from queue (other player removes themselves when they find the game)
                        queueRef.child(myPlayerId).remove();

                        // Create game room
                        const roomId = database.ref().push().key;
                        setGameRoomId(roomId);
                        gameRoomRef.current = database.ref(`games/${roomId}`);

                        // Set up game data with other player as player1 (sanitize name from Firebase)
                        gameRoomRef.current.set({
                          player1: {
                            id: otherPlayer.playerId,
                            name: sanitizeName(otherPlayer.name),
                            flag: sanitizeFlag(otherPlayer.flag),
                            score: playerSetup.gameMode,
                            ready: true
                            // connected will be set when player1 joins
                          },
                          player2: {
                            id: myPlayerId,
                            name: sanitizeName(playerSetup.names[0]) || 'Player 2',
                            flag: playerSetup.flags[0] || 'ğŸŒ',
                            score: playerSetup.gameMode,
                            ready: true,
                            connected: true  // Set immediately so player1 can find this game
                          },
                          currentPlayer: 0,
                          gameMode: playerSetup.gameMode,
                          dartsThrown: 0,
                          currentTurnScore: 0,
                          throwHistory: {},
                          dartPositions: {},
                          legScores: [0, 0],
                          setScores: [0, 0],
                          status: 'playing',
                          createdAt: firebase.database.ServerValue.TIMESTAMP
                        });

                        // Auto-cleanup: Remove game if this player disconnects
                        gameRoomRef.current.onDisconnect().remove();

                        setOpponentName(sanitizeName(otherPlayer.name));
                        setOpponentFlag(sanitizeFlag(otherPlayer.flag));
                        setMatchmakingState('found');

                        setTimeout(() => startOnlineGame(roomId, 1), 1500);
                      }
                    }
                  });
                }
              });
            }, 2000);

            // Timeout after 60 seconds
            setTimeout(() => {
              if (matchmakingState === 'searching') {
                if (matchmakingIntervalRef.current) {
                  clearInterval(matchmakingIntervalRef.current);
                  matchmakingIntervalRef.current = null;
                }
                queueRef.child(myPlayerId).remove();
                cancelMatchmaking();
                alert('No opponent found. Please try again.');
              }
            }, 60000);
          }
        });
        }, 500); // 500ms delay to avoid race condition
      }, [database, playerSetup, matchmakingState]);

      // Start the online game
      const startOnlineGame = useCallback((roomId, playerIndex) => {
        setMatchmakingState('playing');
        setGameState('playing');
        setPlayerId(playerIndex);

        // Cleanup any existing listener first (prevent memory leak)
        if (gameRoomRef.current) {
          gameRoomRef.current.off();
          gameRoomRef.current = null;
        }

        // Initialize game state for online mode
        setWinner(null);
        setMatchWinner(null);
        setTriplesHit(0);
        setIsCheckoutPosition(false);
        setCurrentTurnThrows([]);
        setGameStats({});
        setLegDartsThrown([0, 0]);
        opponentWasConnected.current = false; // Reset for new game

        // Listen for game state changes
        const roomRef = database.ref(`games/${roomId}`);
        gameRoomRef.current = roomRef;

        // Set my presence as connected
        const myPlayerKey = playerIndex === 0 ? 'player1' : 'player2';
        roomRef.child(`${myPlayerKey}/connected`).set(true);

        // Auto-disconnect presence when I leave
        roomRef.child(`${myPlayerKey}/connected`).onDisconnect().set(false);

        roomRef.on('value', (snapshot) => {
          const gameData = snapshot.val();
          if (!gameData) return;

          // Update local game state from Firebase
          const myPlayer = playerIndex === 0 ? gameData.player1 : gameData.player2;
          const opponent = playerIndex === 0 ? gameData.player2 : gameData.player1;

          // Track if opponent was ever connected
          if (opponent.connected === true) {
            opponentWasConnected.current = true;
          }

          // Only alert about disconnection if opponent WAS connected before
          if (opponentWasConnected.current && opponent.connected === false && !gameData.winner) {
            alert(`${sanitizeName(opponent.name)} has disconnected. Returning to menu.`);
            opponentWasConnected.current = false; // Reset for next game
            // Delete the game since opponent already left - prevents stale games
            const gameRefToDelete = gameRoomRef.current;
            if (gameRefToDelete) {
              gameRefToDelete.remove()
                .catch(err => console.error('Failed to delete game:', err));
            }
            cancelMatchmaking();
            return;
          }

          // Sanitize and validate all player data received from Firebase for security
          const validatedGameMode = gameData.gameMode === 301 || gameData.gameMode === 501 ? gameData.gameMode : 501;
          setPlayers([
            {
              name: sanitizeName(gameData.player1.name),
              flag: sanitizeFlag(gameData.player1.flag),
              score: validateScore(gameData.player1.score, validatedGameMode),
              isAI: false
            },
            {
              name: sanitizeName(gameData.player2.name),
              flag: sanitizeFlag(gameData.player2.flag),
              score: validateScore(gameData.player2.score, validatedGameMode),
              isAI: false
            }
          ]);

          setCurrentPlayerIndex(validatePlayerIndex(gameData.currentPlayer));
          setDartsThrown(validateDartsThrown(gameData.dartsThrown));
          setCurrentTurnScore(validateTurnScore(gameData.currentTurnScore));

          // Convert and validate throwHistory from Firebase object to array
          const throwsArray = gameData.throwHistory
            ? Object.values(gameData.throwHistory).map(validateThrowItem).filter(Boolean)
            : [];
          setThrowHistory(throwsArray);

          // Convert and validate dartPositions from Firebase object to array
          const dartsArray = gameData.dartPositions
            ? Object.values(gameData.dartPositions).map(validateDartPosition).filter(Boolean)
            : [];
          setDartPositions(dartsArray);

          setLegScores(validateScoreArray(gameData.legScores, 0));
          setSetScores(validateScoreArray(gameData.setScores, 0));

          // Check for winner
          if (gameData.winner !== undefined) {
            const winnerIndex = validatePlayerIndex(gameData.winner);
            setMatchWinner(winnerIndex === playerIndex ? myPlayer : opponent);
          }
        }, (error) => {
          // Handle Firebase listener errors
          console.error('Game listener error:', error);
          alert('Connection to game lost. Returning to menu.');
          cancelMatchmaking();
        });
      }, [database]);

      // Sync throw to Firebase with retry logic
      const syncThrowToFirebase = useCallback((throwData) => {
        if (!onlineMode || !gameRoomRef.current) return;

        // Generate keys for push operations
        const throwKey = gameRoomRef.current.child('throwHistory').push().key;
        const dartKey = gameRoomRef.current.child('dartPositions').push().key;
        const playerKey = playerId === 0 ? 'player1' : 'player2';

        // Combine all updates into a single atomic operation
        const updates = {
          [`throwHistory/${throwKey}`]: throwData,
          [`dartPositions/${dartKey}`]: throwData.position,
          'dartsThrown': throwData.dartsThrown,
          'currentTurnScore': throwData.currentTurnScore,
          'currentPlayer': throwData.currentPlayer,
          [`${playerKey}/score`]: throwData.newScore
        };

        // Capture ref for retry closure
        const roomRef = gameRoomRef.current;
        retryFirebaseOperation(() => roomRef.update(updates))
          .catch(err => console.error('Failed to sync throw to Firebase after retries:', err));
      }, [onlineMode, playerId]);

      // Cancel matchmaking
      const cancelMatchmaking = useCallback(() => {
        // If in an active game, set my connected status to false to notify opponent
        if (gameRoomRef.current && playerId !== null) {
          const myPlayerKey = playerId === 0 ? 'player1' : 'player2';
          gameRoomRef.current.child(`${myPlayerKey}/connected`).set(false)
            .catch(err => console.error('Failed to set disconnected:', err));
        }

        // Clear matchmaking interval if it's running
        if (matchmakingIntervalRef.current) {
          clearInterval(matchmakingIntervalRef.current);
          matchmakingIntervalRef.current = null;
        }

        // Remove from queue if still in matchmaking (use auth ID, not player index)
        if (myAuthId && database) {
          database.ref('matchmaking_queue').child(myAuthId).remove();
        }

        // Clean up game room listener
        if (gameRoomRef.current) {
          gameRoomRef.current.off();
          gameRoomRef.current = null;
        }

        setMatchmakingState(null);
        setOnlineMode(false);
        setGameRoomId(null);
        setPlayerId(null);
        setMyAuthId(null);
        setGameState('menu');
      }, [myAuthId, database, playerId]);

      // Leave online game
      const leaveOnlineGame = useCallback(() => {
        // cancelMatchmaking now handles all cleanup including setting connected=false
        cancelMatchmaking();
      }, [cancelMatchmaking]);

      // ========== END ONLINE MULTIPLAYER FUNCTIONS ==========

      const calculateScore = useCallback((x, y) => {
        const dx = x - CENTER;
        const dy = y - CENTER;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > DOUBLE_OUTER) return { score: 0, label: 'MISS', multiplier: 0 };
        if (distance <= INNER_BULL) return { score: 50, label: 'BULL', multiplier: 1 };
        if (distance <= OUTER_BULL) return { score: 25, label: '25', multiplier: 1 };
        
        let angle = Math.atan2(dy, dx) * (180 / Math.PI) + 90;
        if (angle < 0) angle += 360;
        const segmentIndex = Math.floor((angle + 9) / 18) % 20;
        const baseScore = SEGMENTS[segmentIndex];
        
        if (distance >= DOUBLE_INNER && distance <= DOUBLE_OUTER) {
          return { score: baseScore * 2, label: `D${baseScore}`, multiplier: 2, base: baseScore };
        }
        if (distance >= TRIPLE_INNER && distance <= TRIPLE_OUTER) {
          return { score: baseScore * 3, label: `T${baseScore}`, multiplier: 3, base: baseScore };
        }
        return { score: baseScore, label: `${baseScore}`, multiplier: 1, base: baseScore };
      }, []);

      const addRandomness = useCallback((targetX, targetY, power, isInPerfectZone) => {
        // If in perfect zone, guarantee 100% accuracy - no randomness at all
        if (isInPerfectZone) {
          return {
            x: targetX,
            y: targetY
          };
        }

        // Not in perfect zone - apply massive penalty to make hitting targets nearly impossible
        const skillFactor = (100 - skillLevel) / 100;
        const powerFactor = Math.abs(power - 50) / 50;

        const skillRandomness = skillFactor * 25;
        const powerRandomness = powerFactor * 20;

        // Calculate how far from perfect zone (50%)
        const distanceFromPerfect = Math.abs(power - 50);
        // Huge penalty: 80 base + up to 60 more based on distance from 50%
        const perfectZonePenalty = 80 + (distanceFromPerfect * 1.2);

        // Total randomness - very high when outside perfect zone
        const randomness = skillRandomness + powerRandomness + perfectZonePenalty;

        const angle = Math.random() * Math.PI * 2;
        const offset = Math.random() * randomness;

        return {
          x: targetX + Math.cos(angle) * offset,
          y: targetY + Math.sin(angle) * offset
        };
      }, [skillLevel]);

      const getAITarget = useCallback((difficulty, currentScore) => {
        // Calculate angle and distance for a specific segment
        const getSegmentPosition = (segmentValue, multiplier = 1) => {
          const segmentIndex = SEGMENTS.indexOf(segmentValue);
          const angle = (segmentIndex * 18 - 90) * (Math.PI / 180);
          let distance;
          if (multiplier === 3) distance = (TRIPLE_INNER + TRIPLE_OUTER) / 2;
          else if (multiplier === 2) distance = (DOUBLE_INNER + DOUBLE_OUTER) / 2;
          else distance = (TRIPLE_OUTER + DOUBLE_INNER) / 2;

          return {
            x: CENTER + distance * Math.cos(angle),
            y: CENTER + distance * Math.sin(angle)
          };
        };

        // Parse a dart notation (e.g., "T20", "D12", "S19", "Bull") into target position
        const parseDartNotation = (notation) => {
          if (notation === 'Bull') {
            return { x: CENTER, y: CENTER }; // Bullseye
          }
          const prefix = notation[0]; // T, D, or S
          const segment = parseInt(notation.slice(1));
          let multiplier = 1;
          if (prefix === 'T') multiplier = 3;
          else if (prefix === 'D') multiplier = 2;
          return getSegmentPosition(segment, multiplier);
        };

        // For checkout situations - expert and impossible use checkout suggestions
        if (CHECKOUT_SUGGESTIONS[currentScore] && (difficulty === AI_DIFFICULTIES.EXPERT.key || difficulty === AI_DIFFICULTIES.IMPOSSIBLE.key)) {
          const suggestion = CHECKOUT_SUGGESTIONS[currentScore];
          // Get the first target from the suggestion (e.g., "T20 T19 D12" -> "T20")
          const firstTarget = suggestion.split(' ')[0];
          return parseDartNotation(firstTarget);
        }

        switch(difficulty) {
          case AI_DIFFICULTIES.BEGINNER.key:
            // Aim at random segments, single rings
            const randomSegment = SEGMENTS[Math.floor(Math.random() * SEGMENTS.length)];
            return getSegmentPosition(randomSegment, 1);

          case AI_DIFFICULTIES.INTERMEDIATE.key:
            // Aim at high-value segments (19, 20), sometimes triples
            const targetSegment = Math.random() > 0.5 ? 20 : 19;
            const useTriple = Math.random() > 0.6;
            return getSegmentPosition(targetSegment, useTriple ? 3 : 1);

          case AI_DIFFICULTIES.EXPERT.key:
            // Consistently aim for T20, T19, or doubles for checkout
            if (currentScore <= 40 && currentScore % 2 === 0) {
              return getSegmentPosition(currentScore / 2, 2);
            }
            return getSegmentPosition(20, 3);

          case AI_DIFFICULTIES.IMPOSSIBLE.key:
            // Perfect strategy - always aim T20 when not in checkout range
            return getSegmentPosition(20, 3);

          default:
            return { x: CENTER, y: CENTER };
        }
      }, []);

      const getAIAccuracy = (difficulty) => {
        const difficultyConfig = Object.values(AI_DIFFICULTIES).find(d => d.key === difficulty);
        return difficultyConfig ? difficultyConfig.accuracy : 50;
      };

      const handleLegWin = useCallback((playerIndex, dartsInLeg = null) => {
        // Check for nine-darter (only possible in 501)
        // Use passed dartsInLeg if provided, otherwise read from state
        const playerDartsInLeg = dartsInLeg !== null ? dartsInLeg : (legDartsThrown[playerIndex] || 0);
        if (playerSetup.gameMode === 501 && playerDartsInLeg === 9) {
          setShowNineDarter(true);
          playSound('ninedarter'); // Epic crowd roar and fanfare
          setTimeout(() => setShowNineDarter(false), 6000);

          // Track nine-darter achievement
          if (!players[playerIndex].isAI) {
            if (onlineMode) {
              unlockAchievement('nine_darter_online');
            } else if (!practiceMode) {
              unlockAchievement('nine_darter_offline');
              updateAchievementStats({ totalNineDarters: achievementStats.totalNineDarters + 1 });
            }
          }
        }

        if (playerSetup.gameMode !== 501 || playerDartsInLeg !== 9) {
          playSound('win'); // Only play regular win sound if not a nine-darter
        }

        // Update leg scores
        const newLegScores = [...legScores];
        newLegScores[playerIndex] = (newLegScores[playerIndex] || 0) + 1;
        setLegScores(newLegScores);

        // Check if player won the set (first to legsPerSet wins)
        if (newLegScores[playerIndex] >= playerSetup.legsPerSet) {
          // Player won the set!
          const newSetScores = [...setScores];
          newSetScores[playerIndex] = (newSetScores[playerIndex] || 0) + 1;
          setSetScores(newSetScores);

          // Check if player won the match (first to setsToWin wins)
          if (newSetScores[playerIndex] >= playerSetup.setsToWin) {
            // Player won the match!
            setMatchWinner(players[playerIndex]);
            setWinner(players[playerIndex]);

            // In online mode, sync winner to Firebase and schedule game deletion
            if (onlineMode && gameRoomRef.current) {
              // Update Firebase with winner so opponent sees it (with retry)
              const roomRef = gameRoomRef.current;
              retryFirebaseOperation(() => roomRef.update({
                winner: playerIndex,
                status: 'finished'
              })).catch(err => console.error('Failed to update winner after retries:', err));

              // Delete the game after 10 seconds (enough time for both to see result)
              setTimeout(() => {
                if (gameRoomRef.current) {
                  gameRoomRef.current.remove().catch(err => console.error('Failed to delete completed game:', err));
                }
              }, 10000);
            }

            // Track game completion and win
            if (!players[playerIndex].isAI && !practiceMode) {
              if (onlineMode) {
                updateAchievementStats({
                  totalOnlineGames: achievementStats.totalOnlineGames + 1,
                  totalOnlineWins: achievementStats.totalOnlineWins + 1
                });
              } else {
                updateAchievementStats({
                  totalGamesPlayed: achievementStats.totalGamesPlayed + 1,
                  totalGamesWon: achievementStats.totalGamesWon + 1
                });
                updateWeeklyChallengeStats({ weeklyWins: 1 });
                updateDailyChallengeStats({ dailyWins: 1, dailyGames: 1 });
              }
            } else if (!practiceMode) {
              // Track game played but not won (lost to AI or other player)
              if (onlineMode) {
                updateAchievementStats({ totalOnlineGames: achievementStats.totalOnlineGames + 1 });
              } else {
                updateAchievementStats({ totalGamesPlayed: achievementStats.totalGamesPlayed + 1 });
                updateDailyChallengeStats({ dailyGames: 1 });
              }
            }
            return;
          }

          // Reset legs for new set
          setLegScores(new Array(players.length).fill(0));
        }

        // Start new leg
        setTimeout(() => {
          const newPlayers = players.map(p => ({
            ...p,
            score: playerSetup.gameMode
          }));
          setPlayers(newPlayers);
          setDartsThrown(0);
          setCurrentTurnScore(0);
          setDartPositions([]);
          setTriplesHit(0);
          setThrowHistory([]);
          setWinner(null);
          setLegDartsThrown(new Array(players.length).fill(0));
        }, 2000);
      }, [legScores, setScores, players, playerSetup, playSound, legDartsThrown, unlockAchievement, updateAchievementStats, achievementStats, onlineMode, practiceMode, updateWeeklyChallengeStats]);

      const throwDart = useCallback(() => {
        // Practice mode: unlimited throws with stat tracking
        if (practiceMode === 'active') {
          playSound('throw');

          // Apply wobble offset to aim position (use ref for current value, avoids stale closure)
          const effectiveAimX = aimPositionRef.current.x + aimWobble.x;
          const effectiveAimY = aimPositionRef.current.y + aimWobble.y;

          // Use practice skill level for difficulty
          const currentSkill = practiceSkillLevel;
          let perfectZoneWidth;
          if (currentSkill <= 40) {
            perfectZoneWidth = 10; // Beginner
          } else {
            const baseZoneWidth = 10;
            const shrinkRate = currentSkill >= 81 ? 3 : 2.5;
            perfectZoneWidth = Math.max(baseZoneWidth - (triplesHit * shrinkRate), 4);
          }
          const perfectZoneLeft = 50 - (perfectZoneWidth / 2);
          const perfectZoneRight = 50 + (perfectZoneWidth / 2);
          const isInPerfectZone = power > perfectZoneLeft && power < perfectZoneRight;

          const finalPosition = addRandomness(effectiveAimX, effectiveAimY, power, isInPerfectZone);
          const result = calculateScore(finalPosition.x, finalPosition.y);

          if (isInPerfectZone) {
            setTriplesHit(prev => prev + 1);
          }

          setAnimatingDart({ start: { x: CENTER, y: BOARD_SIZE + 50 }, end: finalPosition });

          setTimeout(() => {
            setAnimatingDart(null);
            setDartPositions(prev => [...prev, finalPosition]);

            // Update practice stats
            setPracticeStats(prev => {
              const newStats = { ...prev };
              newStats.dartsThrown += 1;
              newStats.totalScore += result.score;

              // Track specific hits
              if (result.score === 50) {
                newStats.bulls += 1;
                playSound('bullseye');
              } else if (result.score === 25) {
                newStats.singleBull += 1;
                playSound('hit');
              } else if (result.multiplier === 3) {
                newStats.triples += 1;
                if (result.label === 'T20') newStats.t20 += 1;
                if (result.label === 'T19') newStats.t19 += 1;
                if (result.label === 'T18') newStats.t18 += 1;
                playSound('hit');
              } else if (result.multiplier === 2) {
                newStats.doubles += 1;
                playSound('hit');
              } else if (result.score > 0) {
                playSound('hit');
              }

              return newStats;
            });

            // Show score popup
            setShowScorePopup({ ...result, position: finalPosition });
            setTimeout(() => setShowScorePopup(null), 1000);

            // Clear board after 3 darts
            if (dartPositions.length + 1 >= 3) {
              setTimeout(() => {
                setDartPositions([]);
                setTriplesHit(0);
                setCurrentTurnThrows([]);
                setAimWobble({ x: 0, y: 0 });
              }, 1000);
            }
          }, 300);

          return; // Exit early for practice mode
        }

        // Regular game mode checks
        if (dartsThrown >= 3 || winner) return;

        // Online mode: only allow throws on your turn
        if (onlineMode && currentPlayerIndex !== playerId) {
          return; // Not your turn
        }

        playSound('throw');

        // Apply wobble offset to aim position (use ref for current value, avoids stale closure)
        const effectiveAimX = aimPositionRef.current.x + aimWobble.x;
        const effectiveAimY = aimPositionRef.current.y + aimWobble.y;

        // Check if player is aiming at the winning double
        const currentPlayer = players[currentPlayerIndex];
        const aimingAt = calculateScore(effectiveAimX, effectiveAimY);
        const isAimingAtWinningDouble = isCheckoutPosition && aimingAt.multiplier === 2 && aimingAt.score === currentPlayer.score;

        // Calculate if power is in perfect zone
        // Beginner mode (40% or below): constant 10% zone, no shrinking
        // Intermediate (41-80%): shrinks by 2.5% for each perfect hit
        // Expert (81%+): shrinks by 3% for each perfect hit
        // Aiming at winning double: ultra-small 2% zone
        let perfectZoneWidth;
        if (skillLevel <= 40) {
          // Beginner mode - constant 10% zone, no shrinking
          perfectZoneWidth = 10;
        } else {
          // Normal mode - shrinking zones
          if (isAimingAtWinningDouble) {
            perfectZoneWidth = 2; // Ultra-small zone for winning double
          } else {
            const baseZoneWidth = 10;
            const shrinkRate = (onlineMode || skillLevel >= 81) ? 3 : 2.5; // 3% for online/expert, 2.5% for intermediate
            perfectZoneWidth = Math.max(baseZoneWidth - (triplesHit * shrinkRate), 4);
          }
        }
        const perfectZoneLeft = 50 - (perfectZoneWidth / 2);
        const perfectZoneRight = 50 + (perfectZoneWidth / 2);
        const isInPerfectZone = power > perfectZoneLeft && power < perfectZoneRight;

        // Use effective aim position (includes wobble for expert mode)
        const finalPosition = addRandomness(effectiveAimX, effectiveAimY, power, isInPerfectZone);
        const result = calculateScore(finalPosition.x, finalPosition.y);

        // Increase difficulty by shrinking perfect zone when perfect throw is hit
        if (isInPerfectZone) {
          setTriplesHit(prev => prev + 1);
        }

        setAnimatingDart({ start: { x: CENTER, y: BOARD_SIZE + 50 }, end: finalPosition });
        
        setTimeout(() => {
          setAnimatingDart(null);
          setDartPositions(prev => [...prev, finalPosition]);

          const currentPlayer = players[currentPlayerIndex];
          const newScore = currentPlayer.score - result.score;

          // Track throw for wobble detection (expert mode 180 challenge)
          setCurrentTurnThrows(prev => [...prev, { score: result.score, multiplier: result.multiplier }]);

          // Check for 180 FIRST (before any sounds or popups)
          const newTurnScore = currentTurnScore + result.score;
          const is180 = newTurnScore === 180 && dartsThrown + 1 === 3;

          if (is180) {
            playSound('180');
            setShowScorePopup({ score: 180, label: '180!!!', position: finalPosition });
            setTimeout(() => setShowScorePopup(null), 2000);

            // Track 180 for achievements (only in offline mode, not practice)
            if (!onlineMode && !practiceMode) {
              updateAchievementStats({ total180s: achievementStats.total180s + 1 });
              updateWeeklyChallengeStats({ weekly180s: 1 });
              updateDailyChallengeStats({ daily180s: 1 });
            }
          } else {
            // Play regular hit sounds only if NOT a 180
            if (result.score === 50) {
              playSound('bullseye');
              // Track bull for achievements (only in offline mode, not practice)
              if (!onlineMode && !practiceMode) {
                updateAchievementStats({ totalBulls: achievementStats.totalBulls + 1 });
                updateWeeklyChallengeStats({ weeklyBulls: 1 });
                updateDailyChallengeStats({ dailyBulls: 1 });
              }
            } else if (result.score > 0) {
              playSound('hit');
            }

            // Track triples for achievements (only in offline mode, not practice)
            if (result.multiplier === 3 && !onlineMode && !practiceMode) {
              updateAchievementStats({ totalTriples: achievementStats.totalTriples + 1 });
              updateWeeklyChallengeStats({ weeklyTriples: 1 });
              updateDailyChallengeStats({ dailyTriples: 1 });
            }

            setShowScorePopup({ ...result, position: finalPosition });
            setTimeout(() => setShowScorePopup(null), 1000);
          }

          // Track daily score for all throws
          if (!onlineMode && !practiceMode && result.score > 0) {
            updateDailyChallengeStats({ dailyScore: result.score });
          }

          if (newScore < 0 || newScore === 1 || (newScore === 0 && result.multiplier !== 2)) {
            playSound('bust');
            setShowScorePopup({ score: 'BUST!', label: 'BUST!', position: finalPosition });
            setTimeout(() => {
              setShowScorePopup(null);
              nextPlayer(true);
            }, 1500);
            return;
          }

          if (newScore === 0 && result.multiplier === 2) {
            const newPlayers = [...players];
            newPlayers[currentPlayerIndex] = { ...currentPlayer, score: 0 };
            setPlayers(newPlayers);
            updateStats(currentPlayerIndex, result);

            // Track checkout for achievements
            const checkoutValue = currentPlayer.score;
            if (!players[currentPlayerIndex].isAI && !onlineMode && !practiceMode) {
              if (checkoutValue > (achievementStats.highestCheckout || 0)) {
                updateAchievementStats({ highestCheckout: checkoutValue });
              }
            }

            // Calculate final dart count including this winning dart
            const finalDartCount = (legDartsThrown[currentPlayerIndex] || 0) + 1;

            // Increment leg darts before checking for nine-darter
            setLegDartsThrown(prev => {
              const newLegDarts = [...prev];
              newLegDarts[currentPlayerIndex] = finalDartCount;
              return newLegDarts;
            });

            setWinner(currentPlayer); // Set temporary leg winner for display
            handleLegWin(currentPlayerIndex, finalDartCount);
            return;
          }

          const newCurrentTurnScore = currentTurnScore + result.score;
          const newDartsThrown = dartsThrown + 1;
          const nextPlayerIndex = newDartsThrown >= 3 ? (currentPlayerIndex + 1) % players.length : currentPlayerIndex;

          // In online mode, ONLY sync to Firebase - don't update local state
          // The Firebase listener will update state for both players
          if (onlineMode) {
            syncThrowToFirebase({
              player: currentPlayerIndex,
              score: result.score,
              multiplier: result.multiplier,
              label: result.label,
              newScore: newScore,
              remaining: newScore,
              dartsThrown: newDartsThrown,
              currentTurnScore: newCurrentTurnScore,
              currentPlayer: nextPlayerIndex,
              position: finalPosition
            });

            // After 3 darts, clear the board in Firebase
            if (newDartsThrown >= 3) {
              setTimeout(() => {
                if (gameRoomRef.current) {
                  gameRoomRef.current.update({
                    dartPositions: {},
                    dartsThrown: 0,
                    currentTurnScore: 0
                  }).catch(err => console.error('Failed to clear board in Firebase:', err));
                }
                // Reset turn tracking - same as offline mode
                setCurrentTurnThrows([]);
                setTriplesHit(0); // Reset power bar shrinking
                setAimWobble({ x: 0, y: 0 }); // Reset wobble
              }, 1000);
            }
          } else {
            // Offline mode: update local state directly
            const newPlayers = [...players];
            newPlayers[currentPlayerIndex] = { ...currentPlayer, score: newScore };
            setPlayers(newPlayers);

            setCurrentTurnScore(newCurrentTurnScore);
            setThrowHistory(prev => [...prev, { player: currentPlayerIndex, ...result, remaining: newScore }]);
            setDartsThrown(newDartsThrown);
            setLegDartsThrown(prev => {
              const newLegDarts = [...prev];
              newLegDarts[currentPlayerIndex] = (newLegDarts[currentPlayerIndex] || 0) + 1;
              return newLegDarts;
            });
            updateStats(currentPlayerIndex, result);

            if (newDartsThrown >= 3) {
              setTimeout(() => nextPlayer(false), 1000);
            }
          }
        }, 300);
      }, [aimWobble, power, dartsThrown, players, currentPlayerIndex, winner, calculateScore, addRandomness, playSound, isCheckoutPosition, triplesHit, handleLegWin, updateStats, nextPlayer, onlineMode, playerId, syncThrowToFirebase, currentTurnScore, practiceMode, practiceSkillLevel, dartPositions, updateAchievementStats, achievementStats, updateWeeklyChallengeStats]);

      const updateStats = useCallback((playerIndex, result) => {
        setGameStats(prev => {
          const playerStats = prev[playerIndex] || { 
            throws: 0, totalScore: 0, doubles: 0, triples: 0, bullseyes: 0,
            misses: 0, highestThrow: 0, averagePerDart: 0
          };
          
          const newThrows = playerStats.throws + 1;
          const newTotal = playerStats.totalScore + result.score;
          
          return {
            ...prev,
            [playerIndex]: {
              throws: newThrows, totalScore: newTotal,
              doubles: playerStats.doubles + (result.multiplier === 2 ? 1 : 0),
              triples: playerStats.triples + (result.multiplier === 3 ? 1 : 0),
              bullseyes: playerStats.bullseyes + (result.score === 50 ? 1 : 0),
              misses: playerStats.misses + (result.score === 0 ? 1 : 0),
              highestThrow: Math.max(playerStats.highestThrow, result.score),
              averagePerDart: (newTotal / newThrows).toFixed(1)
            }
          };
        });
      }, []);

      const nextPlayer = useCallback((busted) => {
        if (busted) {
          const newPlayers = [...players];
          newPlayers[currentPlayerIndex] = { ...players[currentPlayerIndex], score: players[currentPlayerIndex].score + currentTurnScore };
          setPlayers(newPlayers);
        }

        setDartsThrown(0);
        setCurrentTurnScore(0);
        setDartPositions([]);
        setTriplesHit(0);
        setCurrentTurnThrows([]); // Reset turn throws for wobble detection
        setAimWobble({ x: 0, y: 0 }); // Reset wobble
        setCurrentPlayerIndex((currentPlayerIndex + 1) % players.length);
      }, [currentPlayerIndex, players, currentTurnScore]);

      const handleMouseMove = useCallback((e) => {
        if (!boardRef.current || isPowerCharging) return;
        const rect = boardRef.current.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * BOARD_SIZE;
        const y = ((e.clientY - rect.top) / rect.height) * BOARD_SIZE;
        aimPositionRef.current = { x, y };
        setAimPosition({ x, y });
      }, [isPowerCharging]);

      const handleMouseDown = useCallback((e) => {
        const currentPlayer = players[currentPlayerIndex];
        if (dartsThrown >= 3 || winner || animatingDart || (currentPlayer && currentPlayer.isAI)) return;
        e.preventDefault();

        // Clear any existing interval before starting a new one (safety check)
        if (powerIntervalRef.current) {
          clearInterval(powerIntervalRef.current);
          powerIntervalRef.current = null;
        }

        // Clear any pending power reset timeout
        if (powerResetTimeoutRef.current) {
          clearTimeout(powerResetTimeoutRef.current);
          powerResetTimeoutRef.current = null;
        }

        setIsPowerCharging(true);
        setPower(0);

        let increasing = true;
        let currentPower = 0;

        powerIntervalRef.current = setInterval(() => {
          if (increasing) {
            currentPower += 2;
            if (currentPower >= 100) increasing = false;
          } else {
            currentPower -= 2;
            if (currentPower <= 0) increasing = true;
          }
          setPower(currentPower);
        }, 20);
      }, [dartsThrown, winner, animatingDart, players, currentPlayerIndex]);

      const handleMouseUp = useCallback(() => {
        if (powerIntervalRef.current) {
          clearInterval(powerIntervalRef.current);
          powerIntervalRef.current = null;
        }
        if (isPowerCharging) {
          setIsPowerCharging(false);
          throwDart();
          // Delayed power reset to show where user stopped, then reset
          powerResetTimeoutRef.current = setTimeout(() => {
            setPower(0);
            powerResetTimeoutRef.current = null;
          }, 500);
        }
      }, [isPowerCharging, throwDart]);

      // Touch event handlers for mobile devices (iPhone, iPad, etc.)
      const handleTouchMove = useCallback((e) => {
        if (!boardRef.current || isPowerCharging) return;
        e.preventDefault();
        const touch = e.touches[0];
        const rect = boardRef.current.getBoundingClientRect();
        const x = ((touch.clientX - rect.left) / rect.width) * BOARD_SIZE;
        const y = ((touch.clientY - rect.top) / rect.height) * BOARD_SIZE;
        aimPositionRef.current = { x, y };
        setAimPosition({ x, y });
      }, [isPowerCharging]);

      const handleTouchStart = useCallback((e) => {
        const currentPlayer = players[currentPlayerIndex];
        if (dartsThrown >= 3 || winner || animatingDart || (currentPlayer && currentPlayer.isAI)) return;
        e.preventDefault();

        // Clear any existing interval before starting a new one (safety check)
        if (powerIntervalRef.current) {
          clearInterval(powerIntervalRef.current);
          powerIntervalRef.current = null;
        }

        // Clear any pending power reset timeout
        if (powerResetTimeoutRef.current) {
          clearTimeout(powerResetTimeoutRef.current);
          powerResetTimeoutRef.current = null;
        }

        // Update aim position on touch start
        const touch = e.touches[0];
        const rect = boardRef.current.getBoundingClientRect();
        const x = ((touch.clientX - rect.left) / rect.width) * BOARD_SIZE;
        const y = ((touch.clientY - rect.top) / rect.height) * BOARD_SIZE;
        aimPositionRef.current = { x, y };
        setAimPosition({ x, y });

        setIsPowerCharging(true);
        setPower(0);

        let increasing = true;
        let currentPower = 0;

        powerIntervalRef.current = setInterval(() => {
          if (increasing) {
            currentPower += 2;
            if (currentPower >= 100) increasing = false;
          } else {
            currentPower -= 2;
            if (currentPower <= 0) increasing = true;
          }
          setPower(currentPower);
        }, 20);
      }, [dartsThrown, winner, animatingDart, players, currentPlayerIndex]);

      const handleTouchEnd = useCallback((e) => {
        e.preventDefault();
        if (powerIntervalRef.current) {
          clearInterval(powerIntervalRef.current);
          powerIntervalRef.current = null;
        }
        if (isPowerCharging) {
          setIsPowerCharging(false);
          throwDart();
          // Delayed power reset to show where user stopped, then reset
          powerResetTimeoutRef.current = setTimeout(() => {
            setPower(0);
            powerResetTimeoutRef.current = null;
          }, 500);
        }
      }, [isPowerCharging, throwDart]);

      const handleTouchCancel = useCallback((e) => {
        e.preventDefault();
        // Clean up interval when touch is interrupted (scroll, notification, etc.)
        if (powerIntervalRef.current) {
          clearInterval(powerIntervalRef.current);
          powerIntervalRef.current = null;
        }
        // Reset charging state without throwing dart
        if (isPowerCharging) {
          setIsPowerCharging(false);
          setPower(0);
        }
      }, [isPowerCharging]);

      useEffect(() => {
        return () => {
          if (powerIntervalRef.current) clearInterval(powerIntervalRef.current);
          if (powerResetTimeoutRef.current) clearTimeout(powerResetTimeoutRef.current);
          if (matchmakingIntervalRef.current) clearInterval(matchmakingIntervalRef.current);
        };
      }, []);

      useEffect(() => {
        const currentPlayer = players[currentPlayerIndex];
        if (currentPlayer && CHECKOUT_SUGGESTIONS[currentPlayer.score]) {
          setCheckout(CHECKOUT_SUGGESTIONS[currentPlayer.score]);
          setIsCheckoutPosition(true);
        } else {
          setCheckout(null);
          // Also check for simple double finishes (2-40, even numbers)
          if (currentPlayer && currentPlayer.score >= 2 && currentPlayer.score <= 40 && currentPlayer.score % 2 === 0) {
            setIsCheckoutPosition(true);
          } else {
            setIsCheckoutPosition(false);
          }
        }
      }, [players, currentPlayerIndex]);

      // Wobble mechanics: Apply aim wobble for pressure moments
      useEffect(() => {
        const currentPlayer = players[currentPlayerIndex];
        if (!currentPlayer || currentPlayer.isAI) return; // Only for human players

        // Condition 1: Expert mode (81%+) and 2 T20s hit in a row (180 attempt)
        const twoT20sHit = currentTurnThrows.length === 2 &&
                          currentTurnThrows[0].score === 20 && currentTurnThrows[0].multiplier === 3 &&
                          currentTurnThrows[1].score === 20 && currentTurnThrows[1].multiplier === 3;
        const wobbleFor180 = skillLevel >= 81 && twoT20sHit && dartsThrown === 2;

        // Condition 2: Intermediate/Expert (41%+) aiming at winning double (final dart to win leg)
        const aimingAt = calculateScore(aimPosition.x, aimPosition.y);
        const isAimingAtWinningDouble = isCheckoutPosition && aimingAt.multiplier === 2 && aimingAt.score === currentPlayer.score;
        const wobbleForWinningDart = skillLevel >= 41 && isAimingAtWinningDouble && !isPowerCharging;

        // Apply wobble if either condition is met
        if (wobbleFor180 || wobbleForWinningDart) {
          // Apply continuous wobble
          const wobbleInterval = setInterval(() => {
            const wobbleAmount = 8; // pixels of wobble
            setAimWobble({
              x: (Math.random() - 0.5) * wobbleAmount,
              y: (Math.random() - 0.5) * wobbleAmount
            });
          }, 50); // Update every 50ms for smooth wobble

          return () => clearInterval(wobbleInterval);
        } else {
          // No wobble - reset
          setAimWobble({ x: 0, y: 0 });
        }
      }, [skillLevel, currentTurnThrows, dartsThrown, isPowerCharging, players, currentPlayerIndex, aimPosition, isCheckoutPosition, calculateScore]);

      // Online multiplayer cleanup: Handle disconnection and cleanup
      useEffect(() => {
        return () => {
          // Cleanup when component unmounts or leaves online mode
          if (gameRoomRef.current) {
            gameRoomRef.current.off();
          }
          if (myAuthId && database && onlineMode) {
            database.ref('matchmaking_queue').child(myAuthId).remove();
          }
        };
      }, [onlineMode, myAuthId, database]);

      useEffect(() => {
        const currentPlayer = players[currentPlayerIndex];
        if (currentPlayer && currentPlayer.isAI && gameState === 'playing' && !winner && !animatingDart && dartsThrown < 3) {
          const aiThrowDelay = setTimeout(() => {
            const target = getAITarget(currentPlayer.aiDifficulty, currentPlayer.score);
            const aiAccuracy = getAIAccuracy(currentPlayer.aiDifficulty);
            playSound('throw');

            // Calculate final position based on AI accuracy percentage
            let finalPosition;
            // AI uses its own accuracy to determine hit chance, not affected by human skill level
            const hitChance = aiAccuracy / 100;
            const isAccurateThrow = Math.random() < hitChance;

            if (isAccurateThrow) {
              // Accurate throw - hit near target with minimal deviation
              const minorDeviation = (100 - aiAccuracy) * 0.3; // Small deviation based on accuracy
              const angle = Math.random() * Math.PI * 2;
              const offset = Math.random() * minorDeviation;
              finalPosition = {
                x: target.x + Math.cos(angle) * offset,
                y: target.y + Math.sin(angle) * offset
              };
            } else {
              // Inaccurate throw - apply randomness
              const skillFactor = (100 - aiAccuracy) / 100;
              const randomness = 30 + (skillFactor * 50); // 30-80 pixels of deviation
              const angle = Math.random() * Math.PI * 2;
              const offset = Math.random() * randomness;

              finalPosition = {
                x: target.x + Math.cos(angle) * offset,
                y: target.y + Math.sin(angle) * offset
              };
            }

            const result = calculateScore(finalPosition.x, finalPosition.y);

            // Note: AI throws do NOT increment triplesHit as that affects human player's
            // perfect zone difficulty, and should only be affected by human throws

            setAnimatingDart({ start: { x: CENTER, y: BOARD_SIZE + 50 }, end: finalPosition });

            setTimeout(() => {
              setAnimatingDart(null);
              setDartPositions(prev => [...prev, finalPosition]);

              const newScore = currentPlayer.score - result.score;

              // Check for 180 FIRST (before any sounds or popups)
              const newTurnScore = currentTurnScore + result.score;
              const is180 = newTurnScore === 180 && dartsThrown + 1 === 3;

              if (is180) {
                playSound('180');
                setShowScorePopup({ score: 180, label: '180!!!', position: finalPosition });
                setTimeout(() => setShowScorePopup(null), 2000);
              } else {
                // Play regular hit sounds only if NOT a 180
                if (result.score === 50) playSound('bullseye');
                else if (result.score > 0) playSound('hit');

                setShowScorePopup({ ...result, position: finalPosition });
                setTimeout(() => setShowScorePopup(null), 1000);
              }

              if (newScore < 0 || newScore === 1 || (newScore === 0 && result.multiplier !== 2)) {
                playSound('bust');
                setShowScorePopup({ score: 'BUST!', label: 'BUST!', position: finalPosition });
                // Set dartsThrown to 3 to prevent AI useEffect from re-triggering before nextPlayer
                setDartsThrown(3);
                setTimeout(() => {
                  setShowScorePopup(null);
                  nextPlayer(true);
                }, 1500);
                return;
              }

              if (newScore === 0 && result.multiplier === 2) {
                const newPlayers = [...players];
                newPlayers[currentPlayerIndex] = { ...currentPlayer, score: 0 };
                setPlayers(newPlayers);
                updateStats(currentPlayerIndex, result);

                // Calculate final dart count including this winning dart
                const finalDartCount = (legDartsThrown[currentPlayerIndex] || 0) + 1;

                // Increment leg darts before checking for nine-darter
                setLegDartsThrown(prev => {
                  const newLegDarts = [...prev];
                  newLegDarts[currentPlayerIndex] = finalDartCount;
                  return newLegDarts;
                });

                setWinner(currentPlayer); // Set temporary leg winner for display
                handleLegWin(currentPlayerIndex, finalDartCount);
                return;
              }

              const newPlayers = [...players];
              newPlayers[currentPlayerIndex] = { ...currentPlayer, score: newScore };
              setPlayers(newPlayers);

              setCurrentTurnScore(prev => prev + result.score);
              setThrowHistory(prev => [...prev, { player: currentPlayerIndex, ...result, remaining: newScore }]);
              setDartsThrown(prev => prev + 1);
              setLegDartsThrown(prev => {
                const newLegDarts = [...prev];
                newLegDarts[currentPlayerIndex] = (newLegDarts[currentPlayerIndex] || 0) + 1;
                return newLegDarts;
              });
              updateStats(currentPlayerIndex, result);

              if (dartsThrown + 1 >= 3) {
                setTimeout(() => nextPlayer(false), 1000);
              }
            }, 300);
          }, 800);

          return () => clearTimeout(aiThrowDelay);
        }
      }, [players, currentPlayerIndex, gameState, winner, animatingDart, dartsThrown, getAITarget, calculateScore, playSound, updateStats, nextPlayer, legDartsThrown, handleLegWin, currentTurnScore]);

      const startGame = () => {
        const newPlayers = Array.from({ length: playerSetup.count }, (_, i) => ({
          name: playerSetup.names[i] || `Player ${i + 1}`,
          score: playerSetup.gameMode,
          isAI: playerSetup.aiPlayers[i] || false,
          aiDifficulty: playerSetup.aiDifficulty[i] || null,
          flag: playerSetup.flags[i] || 'ğŸ´ó §ó ¢ó ¥ó ®ó §ó ¿'
        }));
        setPlayers(newPlayers);
        setCurrentPlayerIndex(0);
        setDartsThrown(0);
        setCurrentTurnScore(0);
        setThrowHistory([]);
        setDartPositions([]);
        setGameStats({});
        setWinner(null);
        setMatchWinner(null);
        setTriplesHit(0);
        setIsCheckoutPosition(false);
        setLegScores(new Array(playerSetup.count).fill(0));
        setSetScores(new Array(playerSetup.count).fill(0));
        setLegDartsThrown(new Array(playerSetup.count).fill(0));
        setGameState('playing');
      };

      const resetGame = () => {
        // If in online mode, use leaveOnlineGame to properly clean up Firebase
        if (onlineMode) {
          leaveOnlineGame();
          return;
        }
        setGameState('menu');
        setWinner(null);
      };

      // ============================================
      // AUTH FUNCTIONS
      // ============================================

      // Update currentUser when auth state changes
      useEffect(() => {
        if (auth) {
          const unsubscribe = auth.onAuthStateChanged((user) => {
            if (user) {
              // Try to get photo from providerData (Facebook, Google, etc.)
              let photoURL = user.photoURL;
              if (!photoURL && user.providerData && user.providerData.length > 0) {
                const provider = user.providerData[0];
                photoURL = provider.photoURL;
                // For Facebook, construct a reliable photo URL using the provider UID
                if (provider.providerId === 'facebook.com' && provider.uid) {
                  photoURL = `https://graph.facebook.com/${provider.uid}/picture?type=large`;
                }
              }
              setCurrentUser({
                uid: user.uid,
                displayName: user.displayName || (user.providerData && user.providerData[0]?.displayName),
                email: user.email || (user.providerData && user.providerData[0]?.email),
                photoURL: photoURL,
                isAnonymous: user.isAnonymous
              });
            } else {
              setCurrentUser(null);
            }
          });
          return () => unsubscribe();
        }
      }, []);

      // Sign in with Google
      const signInWithGoogle = async () => {
        try {
          const provider = new firebase.auth.GoogleAuthProvider();
          const result = await auth.signInWithPopup(provider);
          setShowLoginModal(false);
          console.log('Signed in with Google:', result.user.displayName);
        } catch (error) {
          console.error('Google sign-in error:', error);
          alert('Failed to sign in with Google. Please try again.');
        }
      };

      // Sign in with Facebook
      const signInWithFacebook = async () => {
        try {
          const provider = new firebase.auth.FacebookAuthProvider();
          const result = await auth.signInWithPopup(provider);
          setShowLoginModal(false);
          console.log('Signed in with Facebook:', result.user.displayName);
        } catch (error) {
          console.error('Facebook sign-in error:', error);
          if (error.code === 'auth/account-exists-with-different-credential') {
            alert('An account already exists with the same email. Please sign in with Google instead.');
          } else {
            alert('Failed to sign in with Facebook. Please try again.');
          }
        }
      };

      // Sign in with Apple
      const signInWithApple = async () => {
        try {
          const provider = new firebase.auth.OAuthProvider('apple.com');
          provider.addScope('email');
          provider.addScope('name');
          const result = await auth.signInWithPopup(provider);
          setShowLoginModal(false);
          console.log('Signed in with Apple:', result.user.displayName);
        } catch (error) {
          console.error('Apple sign-in error:', error);
          alert('Failed to sign in with Apple. Please try again.');
        }
      };

      // Sign out
      const handleSignOut = async () => {
        try {
          await auth.signOut();
          // Sign back in anonymously
          await auth.signInAnonymously();
          console.log('Signed out, now anonymous');
        } catch (error) {
          console.error('Sign out error:', error);
        }
      };

      // Practice Mode Functions
      const enterPracticeMode = () => {
        setPracticeMode('selecting'); // Show skill selection screen
      };

      const startPracticeSession = (skill) => {
        setPracticeSkillLevel(skill);
        setPracticeMode('active');
        setGameState('playing');

        // Reset practice stats
        setPracticeStats({
          dartsThrown: 0,
          t20: 0,
          t19: 0,
          t18: 0,
          bulls: 0,
          singleBull: 0,
          triples: 0,
          doubles: 0,
          totalScore: 0
        });

        // Reset game-related states
        setDartPositions([]);
        setTriplesHit(0);
        setCurrentTurnThrows([]);
        setAimWobble({ x: 0, y: 0 });
      };

      const exitPracticeMode = () => {
        setPracticeMode(false);
        setPracticeSkillLevel(null);
        setGameState('menu');
        setDartPositions([]);
      };

      // Achievements Functions
      const unlockAchievement = useCallback((achievementId) => {
        // Check if already unlocked
        if (unlockedAchievements.includes(achievementId)) return;

        const achievement = ACHIEVEMENTS_DATA.find(a => a.id === achievementId);
        if (!achievement) return;

        // Add to unlocked list
        const newUnlocked = [...unlockedAchievements, achievementId];
        setUnlockedAchievements(newUnlocked);

        try {
          localStorage.setItem('quikdarts_achievements', JSON.stringify(newUnlocked));
        } catch (error) {
          console.error('Failed to save achievements to localStorage:', error);
        }

        // Show popup (timeout cleanup handled by useEffect)
        setAchievementPopup(achievement);
        setTimeout(() => setAchievementPopup(null), 4000);
      }, [unlockedAchievements]);

      const checkAchievements = useCallback((stats) => {
        // First game
        if (stats.totalGamesPlayed >= 1) {
          unlockAchievement('first_game');
        }

        // First win
        if (stats.totalGamesWon >= 1) {
          unlockAchievement('first_win');
        }

        // 180 achievements
        if (stats.total180s >= 1) {
          unlockAchievement('first_180');
        }
        if (stats.total180s >= 10) {
          unlockAchievement('ten_180s');
        }
        if (stats.total180s >= 50) {
          unlockAchievement('fifty_180s');
        }

        // Bulls achievements
        if (stats.totalBulls >= 1) {
          unlockAchievement('first_bull');
        }
        if (stats.totalBulls >= 50) {
          unlockAchievement('fifty_bulls');
        }
        if (stats.totalBulls >= 100) {
          unlockAchievement('hundred_bulls');
        }

        // Winning streaks
        if (stats.totalGamesWon >= 5) {
          unlockAchievement('five_wins');
        }
        if (stats.totalGamesWon >= 20) {
          unlockAchievement('twenty_wins');
        }
        if (stats.totalGamesWon >= 50) {
          unlockAchievement('fifty_wins');
        }

        // Online achievements
        if (stats.totalOnlineGames >= 1) {
          unlockAchievement('first_online');
        }
        if (stats.totalOnlineWins >= 1) {
          unlockAchievement('first_online_win');
        }
        if (stats.totalOnlineWins >= 10) {
          unlockAchievement('ten_online_wins');
        }
        if (stats.totalOnlineWins >= 50) {
          unlockAchievement('fifty_online_wins');
        }

        // Checkout achievements
        if (stats.highestCheckout >= 100) {
          unlockAchievement('big_checkout');
        }
        if (stats.highestCheckout >= 150) {
          unlockAchievement('huge_checkout');
        }

        // Triples achievements
        if (stats.totalTriples >= 50) {
          unlockAchievement('fifty_triples');
        }
        if (stats.totalTriples >= 200) {
          unlockAchievement('two_hundred_triples');
        }
      }, [unlockAchievement]);

      const updateAchievementStats = useCallback((update) => {
        setAchievementStats(prev => {
          const newStats = { ...prev, ...update };

          try {
            localStorage.setItem('quikdarts_stats', JSON.stringify(newStats));
          } catch (error) {
            console.error('Failed to save achievement stats to localStorage:', error);
          }

          checkAchievements(newStats);
          return newStats;
        });
      }, [checkAchievements]);

      // Update weekly challenge stats and check for completion
      const updateWeeklyChallengeStats = useCallback((update) => {
        setWeeklyChallenge(prev => {
          // Check if we need to reset for a new week
          const currentWeek = getCurrentWeekNumber();
          if (prev.weekNumber !== currentWeek) {
            // New week, reset everything but keep completed challenges history
            const activeChallenge = getActiveTimeLimitedAchievement();
            const newData = {
              weekNumber: currentWeek,
              challengeId: activeChallenge?.id,
              stats: { ...update },
              completed: false,
              completedChallenges: prev.completedChallenges || []
            };
            try {
              localStorage.setItem('quikdarts_weekly_challenge', JSON.stringify(newData));
            } catch (error) {
              console.error('Failed to save weekly challenge:', error);
            }
            return newData;
          }

          // Same week, update stats
          const newStats = { ...prev.stats };
          Object.keys(update).forEach(key => {
            newStats[key] = (newStats[key] || 0) + (update[key] || 0);
          });

          // Check if challenge is now completed
          const activeChallenge = getActiveTimeLimitedAchievement();
          let completed = prev.completed;
          let completedChallenges = [...(prev.completedChallenges || [])];

          if (activeChallenge && !completed) {
            const current = newStats[activeChallenge.statKey] || 0;
            if (current >= activeChallenge.target) {
              completed = true;
              if (!completedChallenges.includes(activeChallenge.id)) {
                completedChallenges.push(activeChallenge.id);
              }
              // Sync completion to Firebase for global tracking (requires auth)
              if (database && currentAuthUser) {
                try {
                  database.ref('weekly_completions/' + activeChallenge.id).transaction(count => (count || 0) + 1);
                } catch (error) {
                  console.error('Failed to sync weekly completion to Firebase:', error);
                }
              }
            }
          }

          const newData = {
            ...prev,
            stats: newStats,
            completed,
            completedChallenges
          };

          try {
            localStorage.setItem('quikdarts_weekly_challenge', JSON.stringify(newData));
          } catch (error) {
            console.error('Failed to save weekly challenge:', error);
          }

          return newData;
        });
      }, []);

      // Update daily challenge stats and check for completions
      const updateDailyChallengeStats = useCallback((update) => {
        setDailyChallengeData(prev => {
          const today = getTodayString();
          if (prev.date !== today) {
            // Reset for new day, then apply the update
            const newData = createDefaultDailyChallengeData(today);
            Object.keys(update).forEach(key => {
              newData.stats[key] = (newData.stats[key] || 0) + (update[key] || 0);
            });
            try {
              localStorage.setItem('quikdarts_daily_challenges', JSON.stringify(newData));
            } catch (error) {
              console.error('Failed to save daily challenges:', error);
            }
            return newData;
          }

          const newStats = { ...prev.stats };
          Object.keys(update).forEach(key => {
            newStats[key] = (newStats[key] || 0) + (update[key] || 0);
          });

          const newCompleted = [...prev.completedChallenges];
          prev.challenges.forEach(challenge => {
            if (!newCompleted.includes(challenge.id)) {
              const current = newStats[challenge.statKey] || 0;
              if (current >= challenge.target) {
                newCompleted.push(challenge.id);
              }
            }
          });

          const newData = { ...prev, stats: newStats, completedChallenges: newCompleted };
          try {
            localStorage.setItem('quikdarts_daily_challenges', JSON.stringify(newData));
          } catch (error) {
            console.error('Failed to save daily challenges:', error);
          }
          return newData;
        });
      }, []);

      // Update countdown timer every minute
      useEffect(() => {
        const interval = setInterval(() => {
          setTimeUntilReset(getTimeUntilWeeklyReset());
        }, 60000); // Update every minute
        return () => clearInterval(interval);
      }, []);

      // Auto-hide achievement popup after 4 seconds with proper cleanup
      useEffect(() => {
        if (achievementPopup) {
          const timeoutId = setTimeout(() => {
            setAchievementPopup(null);
          }, 4000);

          // Cleanup function to clear timeout if component unmounts or popup changes
          return () => clearTimeout(timeoutId);
        }
      }, [achievementPopup]);

      const getRarityColor = (rarity) => {
        switch (rarity) {
          case 'common': return '#95a5a6';
          case 'uncommon': return '#27ae60';
          case 'rare': return '#3498db';
          case 'epic': return '#9b59b6';
          case 'legendary': return '#f39c12';
          case 'mythic': return '#e74c3c';
          default: return '#95a5a6';
        }
      };

      // Get rarity-based card styles for unlocked achievements
      const getRarityCardStyle = (rarity, isUnlocked) => {
        if (!isUnlocked) return {};
        const color = getRarityColor(rarity);

        switch (rarity) {
          case 'common':
            return {
              border: `1px solid ${color}30`,
              boxShadow: 'none'
            };
          case 'uncommon':
            return {
              border: `1px solid ${color}50`,
              boxShadow: `0 0 10px ${color}20`
            };
          case 'rare':
            return {
              border: `2px solid ${color}60`,
              boxShadow: `0 0 15px ${color}30`,
              animation: 'rareShimmer 3s ease-in-out infinite'
            };
          case 'epic':
            return {
              border: `2px solid ${color}70`,
              boxShadow: `0 0 20px ${color}40, inset 0 0 30px ${color}10`,
              animation: 'epicGlow 2s ease-in-out infinite'
            };
          case 'legendary':
            return {
              border: `2px solid ${color}`,
              boxShadow: `0 0 25px ${color}50, 0 0 50px ${color}20`,
              animation: 'legendaryPulse 2s ease-in-out infinite',
              background: `linear-gradient(135deg, ${COLORS.backgroundCard}, ${color}15)`
            };
          case 'mythic':
            return {
              border: `3px solid ${color}`,
              boxShadow: `0 0 30px ${color}60, 0 0 60px ${color}30, inset 0 0 40px ${color}10`,
              animation: 'mythicGlow 1.5s ease-in-out infinite',
              background: `linear-gradient(135deg, ${COLORS.backgroundCard}, ${color}20)`
            };
          default:
            return {};
        }
      };

      // Get achievement progress for trackable achievements
      const getAchievementProgress = (achievement, stats) => {
        if (!achievement.statKey || !achievement.target) {
          return null; // One-time achievement, no progress tracking
        }
        const current = stats[achievement.statKey] || 0;
        const target = achievement.target;
        // For threshold achievements (like checkout), show as percentage toward goal
        if (achievement.isThreshold) {
          const progress = Math.min(current / target, 1);
          return { current, target, progress, isThreshold: true };
        }
        // For cumulative achievements
        const progress = Math.min(current / target, 1);
        return { current, target, progress, isThreshold: false };
      };

      const renderDartboard = () => {
        const segments = [];
        const theme = currentTheme;
        const colors = currentThemeColors;
        const effects = theme.effects;

        // Calculate neon glow intensity for pulse animation
        const glowIntensity = effects.pulseAnimation ? 0.6 + 0.4 * Math.sin(neonPulsePhase) : 1;

        // Add SVG gradients and textures for 3D effects
        segments.push(
          <defs key="gradients">
            {/* Radial gradient for board lighting (brighter in center) */}
            {effects.useBoardLighting && (
              <radialGradient id="boardLighting" cx="50%" cy="45%">
                <stop offset="0%" stopColor="rgba(255,255,255,0.15)" />
                <stop offset="60%" stopColor="rgba(255,255,255,0.05)" />
                <stop offset="100%" stopColor="rgba(0,0,0,0.1)" />
              </radialGradient>
            )}
            {/* Gradient for raised bullseye */}
            <radialGradient id="bullGradient" cx="40%" cy="40%">
              <stop offset="0%" stopColor="rgba(255,255,255,0.3)" />
              <stop offset="70%" stopColor="rgba(0,0,0,0)" />
              <stop offset="100%" stopColor="rgba(0,0,0,0.3)" />
            </radialGradient>
            {/* Chrome effect for outer ring */}
            {effects.useChromeGradient && (
              <linearGradient id="chromeGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stopColor="#f0f0f0" />
                <stop offset="15%" stopColor="#ffffff" />
                <stop offset="30%" stopColor={colors.chromeRing} />
                <stop offset="50%" stopColor="#e8e8e8" />
                <stop offset="70%" stopColor="#a0a0a0" />
                <stop offset="85%" stopColor="#d0d0d0" />
                <stop offset="100%" stopColor="#b0b0b0" />
              </linearGradient>
            )}
            {/* Neon glow filter for neon theme */}
            {effects.glowEffect && (
              <filter id="neonGlow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation={3 * glowIntensity} result="coloredBlur" />
                <feMerge>
                  <feMergeNode in="coloredBlur" />
                  <feMergeNode in="SourceGraphic" />
                </feMerge>
              </filter>
            )}
            {/* Gold metallic gradient for Gold Elite theme */}
            {effects.useMetallicSheen && (
              <linearGradient id="goldGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stopColor="#ffd700" />
                <stop offset="25%" stopColor="#ffed4a" />
                <stop offset="50%" stopColor="#ffd700" />
                <stop offset="75%" stopColor="#b8860b" />
                <stop offset="100%" stopColor="#ffd700" />
              </linearGradient>
            )}
            {/* Sisal/Cork texture pattern for board segments */}
            {effects.useSisalTexture && (
              <pattern id="sisalTexture" x="0" y="0" width="4" height="4" patternUnits="userSpaceOnUse">
                <rect width="4" height="4" fill="rgba(0,0,0,0)" />
                <circle cx="1" cy="1" r="0.3" fill="rgba(0,0,0,0.08)" />
                <circle cx="3" cy="2" r="0.3" fill="rgba(0,0,0,0.06)" />
                <circle cx="2" cy="3" r="0.3" fill="rgba(0,0,0,0.07)" />
                <circle cx="0.5" cy="3.5" r="0.2" fill="rgba(255,255,255,0.03)" />
                <circle cx="3.5" cy="0.5" r="0.2" fill="rgba(255,255,255,0.03)" />
              </pattern>
            )}
            {/* Wood grain pattern for outer ring */}
            {effects.useWoodGrain && (
              <pattern id="woodGrain" x="0" y="0" width="20" height="100" patternUnits="userSpaceOnUse" patternTransform="rotate(90)">
                <rect width="20" height="100" fill="rgba(80,60,40,0.1)" />
                <path d="M 0 10 Q 5 15, 10 10 T 20 10" stroke="rgba(60,40,20,0.15)" strokeWidth="0.5" fill="none" />
                <path d="M 0 30 Q 5 28, 10 30 T 20 30" stroke="rgba(60,40,20,0.1)" strokeWidth="0.3" fill="none" />
                <path d="M 0 50 Q 5 55, 10 50 T 20 50" stroke="rgba(60,40,20,0.12)" strokeWidth="0.4" fill="none" />
                <path d="M 0 70 Q 5 68, 10 70 T 20 70" stroke="rgba(60,40,20,0.1)" strokeWidth="0.3" fill="none" />
                <path d="M 0 90 Q 5 92, 10 90 T 20 90" stroke="rgba(60,40,20,0.08)" strokeWidth="0.3" fill="none" />
              </pattern>
            )}
          </defs>
        );

        // Number ring background (radius matches iOS: radius - 4*scale for parity)
        segments.push(
          <circle key="number-ring-bg" cx={CENTER} cy={CENTER} r={DOUBLE_OUTER + 24} fill={colors.numberRing} />
        );

        // Chrome/themed outer ring
        if (effects.useChromeGradient) {
          segments.push(
            <circle key="chrome-ring" cx={CENTER} cy={CENTER} r={DOUBLE_OUTER + 8} fill="url(#chromeGradient)" />,
            effects.useWoodGrain && <circle key="chrome-wood" cx={CENTER} cy={CENTER} r={DOUBLE_OUTER + 8} fill="url(#woodGrain)" opacity="0.3" />,
            <circle key="chrome-ring-inner" cx={CENTER} cy={CENTER} r={DOUBLE_OUTER + 2} fill={colors.boardBackground} />
          );
        } else {
          segments.push(
            <circle key="chrome-ring" cx={CENTER} cy={CENTER} r={DOUBLE_OUTER + 8} fill={colors.chromeRing} />,
            <circle key="chrome-ring-inner" cx={CENTER} cy={CENTER} r={DOUBLE_OUTER + 2} fill={colors.boardBackground} />
          );
        }

        for (let i = 0; i < 20; i++) {
          const startAngle = (i * 18 - 99) * (Math.PI / 180);
          const endAngle = ((i + 1) * 18 - 99) * (Math.PI / 180);

          const createArc = (innerR, outerR) => {
            const x1 = CENTER + innerR * Math.cos(startAngle);
            const y1 = CENTER + innerR * Math.sin(startAngle);
            const x2 = CENTER + outerR * Math.cos(startAngle);
            const y2 = CENTER + outerR * Math.sin(startAngle);
            const x3 = CENTER + outerR * Math.cos(endAngle);
            const y3 = CENTER + outerR * Math.sin(endAngle);
            const x4 = CENTER + innerR * Math.cos(endAngle);
            const y4 = CENTER + innerR * Math.sin(endAngle);

            return `M ${x1} ${y1} L ${x2} ${y2} A ${outerR} ${outerR} 0 0 1 ${x3} ${y3} L ${x4} ${y4} A ${innerR} ${innerR} 0 0 0 ${x1} ${y1}`;
          };

          // Use theme colors
          const baseColor = i % 2 === 0 ? colors.segmentPrimary : colors.segmentSecondary;
          const doubleColor = i % 2 === 0 ? colors.doubleTripleEven : colors.doubleTripleOdd;
          const tripleColor = i % 2 === 0 ? colors.doubleTripleEven : colors.doubleTripleOdd;

          // Add subtle shadow to each segment for depth (if shadow intensity > 0)
          const shadowOffset = effects.shadowIntensity > 0 ? 0.5 : 0;
          const shadowOpacity = effects.shadowIntensity;

          if (shadowOpacity > 0) {
            segments.push(
              <path key={`shadow-outer-${i}`} d={createArc(TRIPLE_OUTER, DOUBLE_INNER)} fill={`rgba(0,0,0,${shadowOpacity})`} transform={`translate(${shadowOffset}, ${shadowOffset})`} />,
              <path key={`shadow-double-${i}`} d={createArc(DOUBLE_INNER, DOUBLE_OUTER)} fill={`rgba(0,0,0,${shadowOpacity})`} transform={`translate(${shadowOffset}, ${shadowOffset})`} />,
              <path key={`shadow-inner-${i}`} d={createArc(OUTER_BULL, TRIPLE_INNER)} fill={`rgba(0,0,0,${shadowOpacity})`} transform={`translate(${shadowOffset}, ${shadowOffset})`} />,
              <path key={`shadow-triple-${i}`} d={createArc(TRIPLE_INNER, TRIPLE_OUTER)} fill={`rgba(0,0,0,${shadowOpacity})`} transform={`translate(${shadowOffset}, ${shadowOffset})`} />
            );
          }

          // Main segments (fill only - wires drawn separately via spider overlay for iOS parity)
          segments.push(
            <path key={`outer-${i}`} d={createArc(TRIPLE_OUTER, DOUBLE_INNER)} fill={baseColor} />,
            <path key={`double-${i}`} d={createArc(DOUBLE_INNER, DOUBLE_OUTER)} fill={doubleColor} />,
            <path key={`inner-${i}`} d={createArc(OUTER_BULL, TRIPLE_INNER)} fill={baseColor} />,
            <path key={`triple-${i}`} d={createArc(TRIPLE_INNER, TRIPLE_OUTER)} fill={tripleColor} />
          );

          // Add texture overlay if enabled
          if (effects.useSisalTexture) {
            segments.push(
              <path key={`texture-outer-${i}`} d={createArc(TRIPLE_OUTER, DOUBLE_INNER)} fill="url(#sisalTexture)" stroke="none" />,
              <path key={`texture-double-${i}`} d={createArc(DOUBLE_INNER, DOUBLE_OUTER)} fill="url(#sisalTexture)" stroke="none" />,
              <path key={`texture-inner-${i}`} d={createArc(OUTER_BULL, TRIPLE_INNER)} fill="url(#sisalTexture)" stroke="none" />,
              <path key={`texture-triple-${i}`} d={createArc(TRIPLE_INNER, TRIPLE_OUTER)} fill="url(#sisalTexture)" stroke="none" />
            );
          }

          // Wire highlights (if not in stealth mode or neon mode)
          if (!effects.glowEffect && effects.shadowIntensity > 0.1) {
            const wireHighlightOffset = -0.3;
            segments.push(
              <path key={`wire-highlight-${i}`} d={createArc(TRIPLE_OUTER, DOUBLE_INNER)} fill="none" stroke={colors.wireHighlight} strokeWidth="0.5" transform={`translate(0, ${wireHighlightOffset})`} />,
              <path key={`wire-highlight-double-${i}`} d={createArc(DOUBLE_INNER, DOUBLE_OUTER)} fill="none" stroke={colors.wireHighlight} strokeWidth="0.5" transform={`translate(0, ${wireHighlightOffset})`} />,
              <path key={`wire-highlight-inner-${i}`} d={createArc(OUTER_BULL, TRIPLE_INNER)} fill="none" stroke={colors.wireHighlight} strokeWidth="0.5" transform={`translate(0, ${wireHighlightOffset})`} />,
              <path key={`wire-highlight-triple-${i}`} d={createArc(TRIPLE_INNER, TRIPLE_OUTER)} fill="none" stroke={colors.wireHighlight} strokeWidth="0.5" transform={`translate(0, ${wireHighlightOffset})`} />
            );
          }

        }

        // Bulls with raised 3D effect and texture
        const bullShadowOpacity = effects.shadowIntensity > 0 ? effects.shadowIntensity : 0;

        segments.push(
          // Outer bull shadow
          bullShadowOpacity > 0 && <circle key="outer-bull-shadow" cx={CENTER + 1} cy={CENTER + 1} r={OUTER_BULL} fill={`rgba(0,0,0,${bullShadowOpacity})`} />,
          // Outer bull (wire drawn via ring overlay at OUTER_BULL radius)
          <circle key="outer-bull" cx={CENTER} cy={CENTER} r={OUTER_BULL} fill={colors.outerBull} style={effects.glowEffect ? { filter: 'url(#neonGlow)' } : {}} />,
          // Outer bull texture
          effects.useSisalTexture && <circle key="outer-bull-texture" cx={CENTER} cy={CENTER} r={OUTER_BULL} fill="url(#sisalTexture)" stroke="none" />,
          // Outer bull highlight for raised effect
          !effects.glowEffect && effects.shadowIntensity > 0.1 && <circle key="outer-bull-highlight" cx={CENTER} cy={CENTER} r={OUTER_BULL} fill="url(#bullGradient)" />,

          // Inner bull shadow
          bullShadowOpacity > 0 && <circle key="inner-bull-shadow" cx={CENTER + 1} cy={CENTER + 1} r={INNER_BULL} fill={`rgba(0,0,0,${bullShadowOpacity + 0.1})`} />,
          // Inner bull (wire drawn via ring overlay at INNER_BULL radius)
          <circle key="inner-bull" cx={CENTER} cy={CENTER} r={INNER_BULL} fill={colors.innerBull} style={effects.glowEffect ? { filter: 'url(#neonGlow)' } : {}} />,
          // Inner bull texture
          effects.useSisalTexture && <circle key="inner-bull-texture" cx={CENTER} cy={CENTER} r={INNER_BULL} fill="url(#sisalTexture)" stroke="none" />,
          // Inner bull highlight for shine
          !effects.glowEffect && effects.shadowIntensity > 0.1 && <ellipse key="inner-bull-shine" cx={CENTER - 2} cy={CENTER - 2} rx={INNER_BULL * 0.4} ry={INNER_BULL * 0.3} fill="rgba(255,255,255,0.4)" />
        );

        // Spider wire overlay - 20 radial spokes + 5 concentric ring circles
        // This matches iOS DartboardView exactly for pixel-perfect cross-platform consistency
        // Draw radial spoke wires from outer bull to double outer (on segment boundaries)
        for (let i = 0; i < 20; i++) {
          const angle = (i * 18 - 99) * (Math.PI / 180);
          const x1 = CENTER + OUTER_BULL * Math.cos(angle);
          const y1 = CENTER + OUTER_BULL * Math.sin(angle);
          const x2 = CENTER + DOUBLE_OUTER * Math.cos(angle);
          const y2 = CENTER + DOUBLE_OUTER * Math.sin(angle);

          segments.push(
            <line key={`spider-wire-${i}`} x1={x1} y1={y1} x2={x2} y2={y2} stroke={colors.wireColor} strokeWidth={effects.wireWidth} />
          );
        }

        // Draw concentric ring wires at all scoring boundaries
        [INNER_BULL, OUTER_BULL, TRIPLE_INNER, TRIPLE_OUTER, DOUBLE_INNER, DOUBLE_OUTER].forEach((radius, idx) => {
          segments.push(
            <circle key={`ring-wire-${idx}`} cx={CENTER} cy={CENTER} r={radius} fill="none" stroke={colors.wireColor} strokeWidth={effects.wireWidth} />
          );
        });

        // Neon glow overlay for wire segments
        if (effects.glowEffect && colors.neonPrimary) {
          // Draw glowing wire overlay
          for (let i = 0; i < 20; i++) {
            const startAngle = (i * 18 - 99) * (Math.PI / 180);
            const midAngle = ((i * 18 + 9) - 99) * (Math.PI / 180);

            // Radial wire from bull to double
            const x1 = CENTER + OUTER_BULL * Math.cos(startAngle);
            const y1 = CENTER + OUTER_BULL * Math.sin(startAngle);
            const x2 = CENTER + DOUBLE_OUTER * Math.cos(startAngle);
            const y2 = CENTER + DOUBLE_OUTER * Math.sin(startAngle);

            segments.push(
              <line key={`neon-wire-${i}`} x1={x1} y1={y1} x2={x2} y2={y2} stroke={colors.neonPrimary} strokeWidth={effects.wireWidth} style={{ filter: 'url(#neonGlow)', opacity: glowIntensity }} />
            );
          }

          // Ring wires with glow
          [OUTER_BULL, TRIPLE_INNER, TRIPLE_OUTER, DOUBLE_INNER, DOUBLE_OUTER].forEach((radius, idx) => {
            segments.push(
              <circle key={`neon-ring-${idx}`} cx={CENTER} cy={CENTER} r={radius} fill="none" stroke={colors.neonPrimary} strokeWidth={effects.wireWidth * 0.8} style={{ filter: 'url(#neonGlow)', opacity: glowIntensity }} />
            );
          });
        }

        // Overall radial lighting effect
        if (effects.useBoardLighting) {
          segments.push(
            <circle key="board-lighting" cx={CENTER} cy={CENTER} r={DOUBLE_OUTER + 2} fill="url(#boardLighting)" pointerEvents="none" />
          );
        }

        // Metallic sheen overlay for Gold Elite
        if (effects.useMetallicSheen && colors.metallicSheen) {
          segments.push(
            <circle key="metallic-sheen" cx={CENTER} cy={CENTER} r={DOUBLE_OUTER + 2} fill={colors.metallicSheen} pointerEvents="none" />
          );
        }

        // Numbers - rendered LAST to ensure they appear on top of all other elements
        const textStyle = effects.glowEffect ? { fontFamily: "'Oswald', sans-serif", filter: 'url(#neonGlow)' } : { fontFamily: "'Oswald', sans-serif" };
        const numberRadius = DOUBLE_OUTER + 16; // Position numbers between chrome ring and number ring edge

        for (let i = 0; i < 20; i++) {
          const textAngle = (i * 18 - 90) * (Math.PI / 180);
          const textX = CENTER + numberRadius * Math.cos(textAngle);
          const textY = CENTER + numberRadius * Math.sin(textAngle);

          // Text shadow (if enabled)
          if (effects.shadowIntensity > 0) {
            segments.push(
              <text key={`text-shadow-${i}`} x={textX + 0.5} y={textY + 0.5} fill="rgba(0,0,0,0.5)" fontSize="16" fontWeight="bold" textAnchor="middle" dominantBaseline="middle" style={{ fontFamily: "'Oswald', sans-serif" }}>
                {SEGMENTS[i]}
              </text>
            );
          }
          // Number text
          segments.push(
            <text key={`text-${i}`} x={textX} y={textY} fill={colors.numberText} fontSize="16" fontWeight="bold" textAnchor="middle" dominantBaseline="middle" style={textStyle}>
              {SEGMENTS[i]}
            </text>
          );
        }

        return segments.filter(Boolean); // Remove any false/null elements from conditional rendering
      };

      const renderDart = (position, index) => (
        <g key={index} transform={`translate(${position.x}, ${position.y})`}>
          <ellipse cx="0" cy="2" rx="4" ry="2" fill="rgba(0,0,0,0.3)" />
          <line x1="0" y1="-15" x2="0" y2="5" stroke="#c0c0c0" strokeWidth="2" />
          <polygon points="-4,-15 4,-15 0,-25" fill="#c41e3a" />
          <circle cx="0" cy="0" r="3" fill="#ffd700" />
          <polygon points="-6,5 6,5 0,-2" fill="#1a1a2e" />
        </g>
      );

      // Practice mode skill selection screen
      if (practiceMode === 'selecting') {
        return (
          <div style={{ minHeight: '100vh', background: COLORS.background, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: '20px' }}>
            {/* Background gradient */}
            <div style={{
              position: 'fixed',
              inset: 0,
              background: `radial-gradient(ellipse at 30% 20%, ${COLORS.primary}40 0%, transparent 50%), radial-gradient(ellipse at 70% 80%, ${COLORS.accent}20 0%, transparent 40%), linear-gradient(180deg, ${COLORS.background} 0%, ${COLORS.backgroundLight} 100%)`,
              zIndex: 0
            }} />

            <div style={{
              background: COLORS.backgroundCard,
              borderRadius: '16px',
              padding: '48px 40px',
              border: '1px solid rgba(255, 255, 255, 0.05)',
              boxShadow: '0 25px 60px rgba(0, 0, 0, 0.5)',
              maxWidth: '420px',
              textAlign: 'center',
              width: '100%',
              position: 'relative',
              zIndex: 1
            }}>
              <div style={{ marginBottom: '24px' }}>
                <TargetIcon size={48} color={COLORS.accent} />
              </div>
              <h2 style={{ color: COLORS.text, fontSize: '1.75rem', marginBottom: '8px', fontWeight: '700' }}>Practice Mode</h2>
              <p style={{ color: COLORS.textMuted, fontSize: '1rem', marginBottom: '32px' }}>Select your skill level to begin</p>

              <div style={{ display: 'flex', flexDirection: 'column', gap: '12px', marginBottom: '24px' }}>
                <button
                  className="btn"
                  onClick={() => startPracticeSession(30)}
                  style={{
                    width: '100%',
                    padding: '16px 24px',
                    background: 'linear-gradient(135deg, #2D8A2D, #1f6b1f)',
                    color: '#fff',
                    border: 'none',
                    borderRadius: '10px',
                    cursor: 'pointer',
                    fontSize: '1rem',
                    fontWeight: '600',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    gap: '12px',
                    transition: 'all 0.2s ease'
                  }}
                >
                  <div style={{ width: '10px', height: '10px', borderRadius: '50%', background: '#4ade80' }} />
                  Beginner
                </button>

                <button
                  className="btn"
                  onClick={() => startPracticeSession(60)}
                  style={{
                    width: '100%',
                    padding: '16px 24px',
                    background: 'linear-gradient(135deg, #D4A03A, #B8862E)',
                    color: COLORS.textDark,
                    border: 'none',
                    borderRadius: '10px',
                    cursor: 'pointer',
                    fontSize: '1rem',
                    fontWeight: '600',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    gap: '12px',
                    transition: 'all 0.2s ease'
                  }}
                >
                  <div style={{ width: '10px', height: '10px', borderRadius: '50%', background: '#fcd34d' }} />
                  Intermediate
                </button>

                <button
                  className="btn"
                  onClick={() => startPracticeSession(90)}
                  style={{
                    width: '100%',
                    padding: '16px 24px',
                    background: 'linear-gradient(135deg, #C92A2A, #a82222)',
                    color: '#fff',
                    border: 'none',
                    borderRadius: '10px',
                    cursor: 'pointer',
                    fontSize: '1rem',
                    fontWeight: '600',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    gap: '12px',
                    transition: 'all 0.2s ease'
                  }}
                >
                  <div style={{ width: '10px', height: '10px', borderRadius: '50%', background: '#f87171' }} />
                  Expert
                </button>
              </div>

              <button
                className="btn btn-ghost"
                onClick={exitPracticeMode}
                style={{
                  width: '100%',
                  padding: '14px 24px',
                  fontSize: '0.9rem'
                }}
              >
                Back to Menu
              </button>
            </div>
          </div>
        );
      }

      // Matchmaking screen - check FIRST before menu
      if (matchmakingState === 'searching' || matchmakingState === 'found') {
        return (
          <div style={{ minHeight: '100vh', background: COLORS.background, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: '20px', fontFamily: "'Inter', sans-serif", position: 'relative' }}>
            <div style={{ position: 'absolute', inset: 0, background: `radial-gradient(ellipse at 30% 20%, ${COLORS.primary}40 0%, transparent 50%), radial-gradient(ellipse at 70% 80%, ${COLORS.accent}20 0%, transparent 40%)`, zIndex: 0, pointerEvents: 'none' }} />
            <div style={{ background: COLORS.backgroundCard, borderRadius: '16px', padding: '60px 40px', backdropFilter: 'blur(10px)', border: `1px solid ${COLORS.accent}30`, maxWidth: '500px', textAlign: 'center', position: 'relative', zIndex: 1 }}>
              {matchmakingState === 'searching' && (
                <>
                  <div style={{ fontSize: '64px', marginBottom: '30px', animation: 'spin 2s linear infinite' }}>ğŸŒ</div>
                  <h2 style={{ color: COLORS.accent, fontSize: '28px', marginBottom: '20px', letterSpacing: '2px', fontWeight: '700' }}>FINDING OPPONENT...</h2>
                  <p style={{ color: COLORS.textMuted, fontSize: '15px', marginBottom: '40px' }}>Searching for players worldwide</p>
                  <div style={{ display: 'flex', gap: '10px', justifyContent: 'center', marginBottom: '30px' }}>
                    <div style={{ width: '12px', height: '12px', borderRadius: '50%', background: COLORS.primaryLight, animation: 'pulse 1.5s ease-in-out infinite' }}></div>
                    <div style={{ width: '12px', height: '12px', borderRadius: '50%', background: COLORS.primaryLight, animation: 'pulse 1.5s ease-in-out infinite 0.2s' }}></div>
                    <div style={{ width: '12px', height: '12px', borderRadius: '50%', background: COLORS.primaryLight, animation: 'pulse 1.5s ease-in-out infinite 0.4s' }}></div>
                  </div>
                  <button onClick={cancelMatchmaking} style={{ padding: '15px 40px', background: 'rgba(255, 255, 255, 0.05)', color: COLORS.text, border: `1px solid ${COLORS.accent}40`, borderRadius: '10px', fontSize: '14px', fontWeight: '600', cursor: 'pointer', fontFamily: "'Inter', sans-serif", letterSpacing: '1px' }}>CANCEL</button>
                </>
              )}

              {matchmakingState === 'found' && (
                <>
                  <div style={{ fontSize: '64px', marginBottom: '30px' }}>âœ“</div>
                  <h2 style={{ color: COLORS.success, fontSize: '28px', marginBottom: '20px', letterSpacing: '2px', fontWeight: '700' }}>OPPONENT FOUND!</h2>
                  <div style={{ background: 'rgba(255, 255, 255, 0.03)', padding: '20px', borderRadius: '10px', marginBottom: '20px', border: '1px solid rgba(255, 255, 255, 0.05)' }}>
                    <div style={{ fontSize: '40px', marginBottom: '10px' }}>{opponentFlag}</div>
                    <div style={{ color: COLORS.accent, fontSize: '22px', fontWeight: '600' }}>{opponentName}</div>
                  </div>
                  <p style={{ color: COLORS.textMuted, fontSize: '15px' }}>Starting game...</p>
                </>
              )}
            </div>

            <style>{`
              @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
              }
              @keyframes pulse {
                0%, 100% { opacity: 0.3; transform: scale(0.8); }
                50% { opacity: 1; transform: scale(1.2); }
              }
            `}</style>
          </div>
        );
      }

      // Login Modal
      if (showLoginModal) {
        return (
          <div style={{
            position: 'fixed',
            inset: 0,
            background: 'rgba(0, 0, 0, 0.8)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000,
            padding: '20px'
          }} onClick={() => setShowLoginModal(false)}>
            <div style={{
              background: COLORS.backgroundCard,
              borderRadius: '16px',
              padding: '32px',
              maxWidth: '400px',
              width: '100%',
              position: 'relative',
              border: '1px solid rgba(255, 255, 255, 0.1)'
            }} onClick={(e) => e.stopPropagation()}>
              {/* Close button */}
              <button onClick={() => setShowLoginModal(false)} style={{
                position: 'absolute',
                top: '16px',
                right: '16px',
                background: 'none',
                border: 'none',
                color: COLORS.textMuted,
                cursor: 'pointer',
                padding: '4px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center'
              }} aria-label="Close">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                  <line x1="18" y1="6" x2="6" y2="18"></line>
                  <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
              </button>

              {/* Header */}
              <h2 style={{
                color: COLORS.text,
                fontSize: '1.5rem',
                fontWeight: '700',
                textAlign: 'center',
                marginBottom: '24px',
                textTransform: 'uppercase',
                letterSpacing: '2px'
              }}>Login</h2>

              {/* Sign in buttons */}
              <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                {/* Facebook */}
                <button onClick={signInWithFacebook} style={{
                  width: '100%',
                  padding: '14px 20px',
                  borderRadius: '8px',
                  border: 'none',
                  background: '#1877F2',
                  color: 'white',
                  fontSize: '1rem',
                  fontWeight: '600',
                  cursor: 'pointer',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '12px',
                  fontFamily: 'var(--font-primary)'
                }}>
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/>
                  </svg>
                  Sign in with Facebook
                </button>

                {/* Google */}
                <button onClick={signInWithGoogle} style={{
                  width: '100%',
                  padding: '14px 20px',
                  borderRadius: '8px',
                  border: '1px solid rgba(255, 255, 255, 0.2)',
                  background: 'white',
                  color: '#333',
                  fontSize: '1rem',
                  fontWeight: '600',
                  cursor: 'pointer',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '12px',
                  fontFamily: 'var(--font-primary)'
                }}>
                  <svg width="20" height="20" viewBox="0 0 24 24">
                    <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                    <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                    <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                    <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                  </svg>
                  Sign in with Google
                </button>
              </div>

              {/* Divider */}
              <div style={{
                display: 'flex',
                alignItems: 'center',
                margin: '24px 0',
                gap: '12px'
              }}>
                <div style={{ flex: 1, height: '1px', background: 'rgba(255, 255, 255, 0.1)' }}></div>
                <span style={{ color: COLORS.textMuted, fontSize: '0.85rem' }}>OR</span>
                <div style={{ flex: 1, height: '1px', background: 'rgba(255, 255, 255, 0.1)' }}></div>
              </div>

              {/* Continue as guest */}
              <button onClick={() => setShowLoginModal(false)} style={{
                width: '100%',
                padding: '14px 20px',
                borderRadius: '8px',
                border: '1px solid rgba(255, 255, 255, 0.1)',
                background: 'transparent',
                color: COLORS.textMuted,
                fontSize: '0.95rem',
                cursor: 'pointer',
                fontFamily: 'var(--font-primary)'
              }}>
                Continue as Guest
              </button>

              {/* Info text */}
              <p style={{
                color: COLORS.textMuted,
                fontSize: '0.8rem',
                textAlign: 'center',
                marginTop: '16px',
                lineHeight: '1.5'
              }}>
                Sign in to save your progress, track stats, and compete on leaderboards.
              </p>
            </div>
          </div>
        );
      }

      // Achievements Gallery - check BEFORE menu
      if (showAchievements) {
        return (
          <div style={{ minHeight: '100vh', background: COLORS.background, display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '80px 20px 40px' }}>
            {/* Background gradient */}
            <div style={{
              position: 'fixed',
              inset: 0,
              background: `radial-gradient(ellipse at 30% 20%, ${COLORS.primary}40 0%, transparent 50%), radial-gradient(ellipse at 70% 80%, ${COLORS.accent}20 0%, transparent 40%), linear-gradient(180deg, ${COLORS.background} 0%, ${COLORS.backgroundLight} 100%)`,
              zIndex: 0
            }} />

            <div style={{ maxWidth: '1000px', width: '100%', position: 'relative', zIndex: 1 }}>
              {/* Header */}
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '32px' }}>
                <div>
                  <h1 style={{ fontSize: 'clamp(1.75rem, 4vw, 2.5rem)', fontWeight: '700', color: COLORS.text, margin: 0 }}>Achievements</h1>
                  <p style={{ color: COLORS.textMuted, fontSize: '1rem', marginTop: '4px' }}>Track your progress and unlock rewards</p>
                </div>
                <button className="btn btn-ghost" onClick={() => setShowAchievements(false)} style={{ padding: '12px 24px' }}>Back</button>
              </div>

              {/* Progress Card */}
              <div style={{
                background: COLORS.backgroundCard,
                borderRadius: '12px',
                padding: '24px',
                marginBottom: '32px',
                border: '1px solid rgba(255, 255, 255, 0.05)'
              }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                  <span style={{ color: COLORS.textMuted, fontSize: '0.9rem' }}>Progress</span>
                  <span style={{ color: COLORS.accent, fontSize: '1rem', fontWeight: '600' }}>{unlockedAchievements.length} / {ACHIEVEMENTS_DATA.length}</span>
                </div>
                <div style={{ background: 'rgba(255, 255, 255, 0.1)', borderRadius: '8px', height: '8px', overflow: 'hidden' }}>
                  <div style={{ background: `linear-gradient(90deg, ${COLORS.accent}, ${COLORS.accentLight})`, height: '100%', width: `${(unlockedAchievements.length / ACHIEVEMENTS_DATA.length) * 100}%`, transition: 'width 0.5s', borderRadius: '8px' }}></div>
                </div>
              </div>

              {/* Weekly Challenge Section */}
              {(() => {
                const activeChallenge = getActiveTimeLimitedAchievement();
                if (!activeChallenge) return null;
                const current = weeklyChallenge.stats[activeChallenge.statKey] || 0;
                const progress = Math.min(current / activeChallenge.target, 1);
                const isCompleted = weeklyChallenge.completed;
                return (
                  <div style={{
                    background: `linear-gradient(135deg, ${COLORS.backgroundCard}, rgba(155, 89, 182, 0.1))`,
                    borderRadius: '12px',
                    padding: '24px',
                    marginBottom: '32px',
                    border: `1px solid ${isCompleted ? '#27ae60' : '#9b59b6'}40`,
                    position: 'relative',
                    overflow: 'hidden'
                  }}>
                    {/* Time badge */}
                    <div style={{
                      position: 'absolute',
                      top: '16px',
                      right: '16px',
                      background: 'rgba(155, 89, 182, 0.2)',
                      borderRadius: '20px',
                      padding: '6px 12px',
                      display: 'flex',
                      alignItems: 'center',
                      gap: '6px'
                    }}>
                      <span style={{ fontSize: '0.75rem', color: '#9b59b6' }}>Ends in</span>
                      <span style={{ fontSize: '0.85rem', fontWeight: '600', color: COLORS.text }}>{formatTimeRemaining(timeUntilReset)}</span>
                    </div>

                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '8px' }}>
                      <span style={{ fontSize: '0.7rem', fontWeight: '600', textTransform: 'uppercase', letterSpacing: '1px', color: '#9b59b6' }}>Weekly Challenge</span>
                      {isCompleted && <span style={{ fontSize: '0.7rem', fontWeight: '600', color: '#27ae60', background: 'rgba(39, 174, 96, 0.2)', padding: '2px 8px', borderRadius: '4px' }}>Completed!</span>}
                    </div>

                    <div style={{ display: 'flex', alignItems: 'center', gap: '16px', marginBottom: '16px' }}>
                      <div style={{
                        fontSize: '40px',
                        background: isCompleted ? 'rgba(39, 174, 96, 0.2)' : 'rgba(155, 89, 182, 0.2)',
                        borderRadius: '12px',
                        padding: '12px',
                        filter: isCompleted ? 'none' : 'none'
                      }}>
                        {isCompleted ? 'âœ…' : activeChallenge.icon}
                      </div>
                      <div>
                        <h3 style={{ color: COLORS.text, fontSize: '1.25rem', fontWeight: '600', margin: 0 }}>{activeChallenge.name}</h3>
                        <p style={{ color: COLORS.textMuted, fontSize: '0.9rem', margin: '4px 0 0 0' }}>{activeChallenge.description}</p>
                      </div>
                    </div>

                    {/* Progress bar */}
                    <div style={{ marginBottom: '12px' }}>
                      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                        <span style={{ color: COLORS.textMuted, fontSize: '0.85rem' }}>{current} / {activeChallenge.target}</span>
                        <span style={{ color: isCompleted ? '#27ae60' : '#9b59b6', fontSize: '0.85rem', fontWeight: '600' }}>{Math.round(progress * 100)}%</span>
                      </div>
                      <div style={{ background: 'rgba(255, 255, 255, 0.1)', borderRadius: '6px', height: '10px', overflow: 'hidden' }}>
                        <div style={{
                          background: isCompleted ? 'linear-gradient(90deg, #27ae60, #2ecc71)' : 'linear-gradient(90deg, #9b59b6, #8e44ad)',
                          height: '100%',
                          width: `${progress * 100}%`,
                          borderRadius: '6px',
                          transition: 'width 0.5s ease'
                        }} />
                      </div>
                    </div>

                    {/* Reward info */}
                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                      <span style={{ color: COLORS.textMuted, fontSize: '0.8rem' }}>Reward:</span>
                      <span style={{ color: '#f39c12', fontSize: '0.8rem', fontWeight: '600' }}>{activeChallenge.reward}</span>
                    </div>
                  </div>
                );
              })()}

              {/* Daily Challenges Section */}
              <div style={{
                background: COLORS.backgroundCard,
                borderRadius: '12px',
                padding: '24px',
                marginBottom: '32px',
                border: `1px solid ${COLORS.accent}30`
              }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '16px' }}>
                  <div>
                    <h2 style={{ color: COLORS.text, fontSize: '1.25rem', fontWeight: '600', margin: 0 }}>Daily Challenges</h2>
                    <p style={{ color: COLORS.textMuted, fontSize: '0.85rem', margin: '4px 0 0 0' }}>Complete challenges to earn rewards. Resets at midnight.</p>
                  </div>
                  <div style={{ background: `${COLORS.accent}20`, borderRadius: '8px', padding: '8px 12px', color: COLORS.accent, fontSize: '0.85rem', fontWeight: '600' }}>
                    {dailyChallengeData.completedChallenges.length} / {dailyChallengeData.challenges.length} Complete
                  </div>
                </div>
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))', gap: '12px' }}>
                  {dailyChallengeData.challenges.map(challenge => {
                    const isCompleted = dailyChallengeData.completedChallenges.includes(challenge.id);
                    const current = dailyChallengeData.stats[challenge.statKey] || 0;
                    const progress = Math.min(current / challenge.target, 1);
                    return (
                      <div key={challenge.id} style={{
                        background: isCompleted ? `${COLORS.success}15` : 'rgba(255, 255, 255, 0.03)',
                        borderRadius: '10px',
                        padding: '16px',
                        border: isCompleted ? `1px solid ${COLORS.success}40` : '1px solid rgba(255, 255, 255, 0.05)'
                      }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '12px', marginBottom: '12px' }}>
                          <div style={{ fontSize: '24px', background: isCompleted ? `${COLORS.success}20` : 'rgba(255, 255, 255, 0.05)', borderRadius: '8px', padding: '8px' }}>
                            {isCompleted ? 'âœ…' : challenge.icon}
                          </div>
                          <div style={{ flex: 1 }}>
                            <div style={{ color: COLORS.text, fontSize: '0.95rem', fontWeight: '600' }}>{challenge.name}</div>
                            <div style={{ color: COLORS.textMuted, fontSize: '0.8rem' }}>{challenge.description}</div>
                          </div>
                          <span style={{ fontSize: '0.65rem', fontWeight: '600', textTransform: 'uppercase', color: DIFFICULTY_COLORS[challenge.difficulty], background: `${DIFFICULTY_COLORS[challenge.difficulty]}20`, padding: '4px 8px', borderRadius: '4px' }}>
                            {challenge.difficulty}
                          </span>
                        </div>
                        <div style={{ marginBottom: '8px' }}>
                          <div style={{ background: 'rgba(255, 255, 255, 0.1)', borderRadius: '4px', height: '6px', overflow: 'hidden' }}>
                            <div style={{ background: isCompleted ? COLORS.success : `linear-gradient(90deg, ${DIFFICULTY_COLORS[challenge.difficulty]}, ${DIFFICULTY_COLORS[challenge.difficulty]}aa)`, height: '100%', width: `${progress * 100}%`, borderRadius: '4px' }} />
                          </div>
                        </div>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                          <span style={{ color: COLORS.textMuted, fontSize: '0.75rem' }}>{current} / {challenge.target}</span>
                          {isCompleted && <span style={{ color: COLORS.success, fontSize: '0.75rem', fontWeight: '600' }}>Complete!</span>}
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>

              {/* Almost There Section - Achievements at 70-95% */}
              {(() => {
                const almostThereAchievements = ACHIEVEMENTS_DATA.filter(achievement => {
                  if (unlockedAchievements.includes(achievement.id)) return false;
                  const progress = getAchievementProgress(achievement, achievementStats);
                  return progress && progress.progress >= 0.7 && progress.progress < 1;
                });

                if (almostThereAchievements.length === 0) return null;

                return (
                  <div style={{ marginBottom: '32px' }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '16px' }}>
                      <span style={{ fontSize: '1.25rem' }}>ğŸ”¥</span>
                      <h2 style={{ color: COLORS.accent, fontSize: '1.1rem', fontWeight: '600', margin: 0 }}>Almost There!</h2>
                    </div>
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '12px' }}>
                      {almostThereAchievements.map(achievement => {
                        const progressData = getAchievementProgress(achievement, achievementStats);
                        const remaining = progressData.target - progressData.current;
                        return (
                          <div key={`almost-${achievement.id}`} style={{
                            background: `linear-gradient(135deg, ${COLORS.backgroundCard}, ${COLORS.accent}10)`,
                            border: `1px solid ${COLORS.accent}40`,
                            borderRadius: '12px',
                            padding: '16px',
                            animation: 'almostTherePulse 2s ease-in-out infinite'
                          }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                              <div style={{ fontSize: '28px' }}>{achievement.icon}</div>
                              <div style={{ flex: 1 }}>
                                <div style={{ color: COLORS.text, fontSize: '0.95rem', fontWeight: '600', marginBottom: '4px' }}>
                                  {achievement.name}
                                </div>
                                <div style={{ color: COLORS.accent, fontSize: '0.8rem', fontWeight: '500' }}>
                                  {progressData.isThreshold
                                    ? `Need ${progressData.target}+ (Current best: ${progressData.current})`
                                    : `Only ${remaining} more to go!`}
                                </div>
                                {/* Mini progress bar */}
                                <div style={{
                                  background: 'rgba(255, 255, 255, 0.1)',
                                  borderRadius: '3px',
                                  height: '4px',
                                  marginTop: '8px',
                                  overflow: 'hidden'
                                }}>
                                  <div style={{
                                    background: `linear-gradient(90deg, ${COLORS.accent}, ${COLORS.accentLight})`,
                                    height: '100%',
                                    width: `${progressData.progress * 100}%`,
                                    borderRadius: '3px'
                                  }} />
                                </div>
                              </div>
                              <div style={{ color: COLORS.accent, fontSize: '1.1rem', fontWeight: '700' }}>
                                {Math.round(progressData.progress * 100)}%
                              </div>
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                );
              })()}

              {/* Achievements Grid */}
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '16px' }}>
                {ACHIEVEMENTS_DATA.map(achievement => {
                  const isUnlocked = unlockedAchievements.includes(achievement.id);
                  const progressData = !isUnlocked ? getAchievementProgress(achievement, achievementStats) : null;
                  const rarityStyle = getRarityCardStyle(achievement.rarity, isUnlocked);
                  return (
                    <div key={achievement.id} style={{
                      background: COLORS.backgroundCard,
                      border: '1px solid rgba(255, 255, 255, 0.05)',
                      borderRadius: '12px',
                      padding: '20px',
                      opacity: isUnlocked ? 1 : (progressData && progressData.progress > 0 ? 0.8 : 0.6),
                      transition: 'all 0.3s ease',
                      position: 'relative',
                      overflow: 'hidden',
                      ...rarityStyle
                    }}>
                      <div style={{ display: 'flex', alignItems: 'flex-start', gap: '16px' }}>
                        <div style={{
                          fontSize: '32px',
                          filter: isUnlocked ? 'none' : 'grayscale(100%)',
                          background: isUnlocked ? `${getRarityColor(achievement.rarity)}20` : 'rgba(255, 255, 255, 0.05)',
                          borderRadius: '10px',
                          padding: '10px',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center'
                        }}>
                          {achievement.icon}
                        </div>
                        <div style={{ flex: 1 }}>
                          <div style={{ color: isUnlocked ? COLORS.text : COLORS.textMuted, fontSize: '1rem', fontWeight: '600', marginBottom: '4px' }}>
                            {achievement.name}
                          </div>
                          <div style={{ color: isUnlocked ? COLORS.textMuted : 'rgba(139, 148, 158, 0.6)', fontSize: '0.85rem', marginBottom: '12px', lineHeight: '1.4' }}>
                            {achievement.description}
                          </div>

                          {/* Progress Bar for locked trackable achievements */}
                          {!isUnlocked && progressData && (
                            <div style={{ marginBottom: '12px' }}>
                              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '6px' }}>
                                <span style={{ color: progressData.progress >= 0.7 ? COLORS.accent : COLORS.textMuted, fontSize: '0.75rem', fontWeight: '600' }}>
                                  {progressData.isThreshold
                                    ? `Best: ${progressData.current}`
                                    : `${progressData.current} / ${progressData.target}`}
                                </span>
                                <span style={{ color: progressData.progress >= 0.7 ? COLORS.accent : COLORS.textMuted, fontSize: '0.75rem' }}>
                                  {Math.round(progressData.progress * 100)}%
                                </span>
                              </div>
                              <div style={{
                                background: 'rgba(255, 255, 255, 0.1)',
                                borderRadius: '4px',
                                height: '6px',
                                overflow: 'hidden'
                              }}>
                                <div style={{
                                  background: progressData.progress >= 0.7
                                    ? `linear-gradient(90deg, ${COLORS.accent}, ${COLORS.accentLight})`
                                    : 'linear-gradient(90deg, #4a5568, #718096)',
                                  height: '100%',
                                  width: `${progressData.progress * 100}%`,
                                  borderRadius: '4px',
                                  transition: 'width 0.5s ease'
                                }} />
                              </div>
                            </div>
                          )}

                          <div style={{ display: 'flex', gap: '8px', alignItems: 'center', flexWrap: 'wrap' }}>
                            <span style={{
                              color: isUnlocked ? getRarityColor(achievement.rarity) : COLORS.textMuted,
                              fontSize: '0.7rem',
                              fontWeight: '600',
                              textTransform: 'uppercase',
                              letterSpacing: '0.5px',
                              background: isUnlocked ? `${getRarityColor(achievement.rarity)}20` : 'rgba(255, 255, 255, 0.05)',
                              borderRadius: '4px',
                              padding: '4px 8px'
                            }}>
                              {achievement.rarity}
                            </span>
                            <span style={{
                              color: achievement.mode === 'online' ? '#60a5fa' : COLORS.accent,
                              fontSize: '0.7rem',
                              fontWeight: '600',
                              textTransform: 'uppercase',
                              letterSpacing: '0.5px',
                              background: achievement.mode === 'online' ? 'rgba(96, 165, 250, 0.15)' : `${COLORS.accent}20`,
                              borderRadius: '4px',
                              padding: '4px 8px'
                            }}>
                              {achievement.mode === 'online' ? 'Online' : 'Offline'}
                            </span>
                            {isUnlocked ? (
                              <span style={{
                                color: COLORS.success,
                                fontSize: '0.7rem',
                                fontWeight: '600',
                                background: 'rgba(45, 138, 45, 0.15)',
                                borderRadius: '4px',
                                padding: '4px 8px',
                                marginLeft: 'auto'
                              }}>
                                Unlocked
                              </span>
                            ) : (
                              <span style={{
                                color: COLORS.textMuted,
                                fontSize: '0.7rem',
                                fontWeight: '600',
                                background: 'rgba(255, 255, 255, 0.05)',
                                borderRadius: '4px',
                                padding: '4px 8px',
                                marginLeft: 'auto'
                              }}>
                                Locked
                              </span>
                            )}
                          </div>
                        </div>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          </div>
        );
      }

      // ============================================
      // NAVIGATION COMPONENT
      // ============================================
      const Navigation = ({ onNavigate, currentPage }) => (
        <nav className="nav" role="navigation" aria-label="Main navigation">
          <div className="nav-container">
            <a href="#" className="nav-logo" onClick={(e) => { e.preventDefault(); onNavigate('landing'); }}>
              QUIK DARTS
            </a>
            <ul className="nav-links">
              <li><a href="#" className="nav-link" onClick={(e) => { e.preventDefault(); onNavigate('landing'); }}>Home</a></li>
              <li><a href="#" className="nav-link" onClick={(e) => { e.preventDefault(); onNavigate('menu'); }}>Play</a></li>
              <li><a href="#" className="nav-link" onClick={(e) => { e.preventDefault(); enterPracticeMode(); }}>Practice</a></li>
              <li><a href="#" className="nav-link" onClick={(e) => { e.preventDefault(); setShowAchievements(true); }}>Achievements</a></li>
              <li><a href="#" className="nav-link" onClick={(e) => { e.preventDefault(); onNavigate('howToPlay'); }}>How to Play</a></li>
              <li><button className="nav-cta" onClick={() => onNavigate('menu')}>Play Now</button></li>
              <li>
                {currentUser && !currentUser.isAnonymous ? (
                  <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                    {currentUser.photoURL ? (
                      <img
                        src={currentUser.photoURL}
                        alt={currentUser.displayName || 'Profile'}
                        style={{ width: '36px', height: '36px', borderRadius: '50%', border: `2px solid ${COLORS.accent}` }}
                        referrerPolicy="no-referrer"
                        onError={(e) => { e.target.style.display = 'none'; e.target.nextSibling.style.display = 'flex'; }}
                      />
                    ) : null}
                    <div style={{
                      width: '36px',
                      height: '36px',
                      borderRadius: '50%',
                      background: `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})`,
                      display: currentUser.photoURL ? 'none' : 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      color: COLORS.textDark,
                      fontWeight: '700',
                      fontSize: '16px',
                      border: `2px solid ${COLORS.accentLight}`
                    }}>
                      {(currentUser.displayName || currentUser.email || 'U')[0].toUpperCase()}
                    </div>
                    <button onClick={handleSignOut} style={{
                      background: 'none',
                      border: '1px solid rgba(255,255,255,0.2)',
                      color: COLORS.textMuted,
                      padding: '6px 12px',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      fontSize: '0.8rem',
                      fontFamily: 'var(--font-primary)'
                    }}>Sign Out</button>
                  </div>
                ) : (
                  <button onClick={() => setShowLoginModal(true)} style={{
                    background: 'none',
                    border: '1px solid rgba(255,255,255,0.3)',
                    color: COLORS.text,
                    padding: '8px 16px',
                    borderRadius: '6px',
                    cursor: 'pointer',
                    fontSize: '0.9rem',
                    fontWeight: '500',
                    fontFamily: 'var(--font-primary)'
                  }}>Login</button>
                )}
              </li>
            </ul>
            <button className="nav-hamburger" onClick={() => setMobileMenuOpen(!mobileMenuOpen)} aria-label="Toggle menu" aria-expanded={mobileMenuOpen}>
              {mobileMenuOpen ? <CloseIcon /> : <MenuIcon />}
            </button>
          </div>
          <div className={`nav-mobile ${mobileMenuOpen ? 'open' : ''}`}>
            <ul className="nav-mobile-links">
              <li><a href="#" className="nav-link" onClick={(e) => { e.preventDefault(); onNavigate('landing'); setMobileMenuOpen(false); }}>Home</a></li>
              <li><a href="#" className="nav-link" onClick={(e) => { e.preventDefault(); onNavigate('menu'); setMobileMenuOpen(false); }}>Play</a></li>
              <li><a href="#" className="nav-link" onClick={(e) => { e.preventDefault(); onNavigate('howToPlay'); setMobileMenuOpen(false); }}>How to Play</a></li>
              <li><a href="#" className="nav-link" onClick={(e) => { e.preventDefault(); setShowAchievements(true); setMobileMenuOpen(false); }}>Achievements</a></li>
              <li><button className="btn btn-primary" style={{ width: '100%', marginTop: '8px' }} onClick={() => { onNavigate('menu'); setMobileMenuOpen(false); }}>Play Now</button></li>
              <li>
                {currentUser && !currentUser.isAnonymous ? (
                  <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginTop: '12px', padding: '12px', background: 'rgba(255,255,255,0.05)', borderRadius: '8px' }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                      {currentUser.photoURL ? (
                        <img src={currentUser.photoURL} alt="" style={{ width: '36px', height: '36px', borderRadius: '50%' }} />
                      ) : (
                        <div style={{ width: '36px', height: '36px', borderRadius: '50%', background: COLORS.accent, display: 'flex', alignItems: 'center', justifyContent: 'center', color: COLORS.textDark, fontWeight: '600' }}>
                          {(currentUser.displayName || currentUser.email || 'U')[0].toUpperCase()}
                        </div>
                      )}
                      <span style={{ color: COLORS.text, fontSize: '0.9rem' }}>{currentUser.displayName || currentUser.email || 'User'}</span>
                    </div>
                    <button onClick={() => { handleSignOut(); setMobileMenuOpen(false); }} style={{
                      background: 'none',
                      border: '1px solid rgba(255,255,255,0.2)',
                      color: COLORS.textMuted,
                      padding: '6px 12px',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      fontSize: '0.8rem',
                      fontFamily: 'var(--font-primary)'
                    }}>Sign Out</button>
                  </div>
                ) : (
                  <button onClick={() => { setShowLoginModal(true); setMobileMenuOpen(false); }} className="btn btn-secondary" style={{ width: '100%', marginTop: '8px' }}>Login</button>
                )}
              </li>
            </ul>
          </div>
        </nav>
      );

      // ============================================
      // FOOTER COMPONENT
      // ============================================
      const Footer = ({ onNavigate }) => (
        <footer className="footer" role="contentinfo">
          <div className="footer-container">
            <div className="footer-content">
              <div className="footer-brand">
                <h3>Quik Darts</h3>
                <p>Championship-style online darts.<br />Play anywhere, anytime.</p>
              </div>
              <div className="footer-links">
                <div className="footer-links-group">
                  <h4>Play</h4>
                  <ul>
                    <li><a href="#" onClick={(e) => { e.preventDefault(); onNavigate('menu'); }}>Start Game</a></li>
                    <li><a href="#" onClick={(e) => { e.preventDefault(); onNavigate('menu'); }}>Practice Mode</a></li>
                    <li><a href="#" onClick={(e) => { e.preventDefault(); onNavigate('menu'); }}>Online Match</a></li>
                  </ul>
                </div>
                <div className="footer-links-group">
                  <h4>Learn</h4>
                  <ul>
                    <li><a href="#" onClick={(e) => { e.preventDefault(); onNavigate('howToPlay'); }}>How to Play</a></li>
                    <li><a href="#" onClick={(e) => { e.preventDefault(); onNavigate('howToPlay'); }}>Scoring Rules</a></li>
                    <li><a href="#" onClick={(e) => { e.preventDefault(); onNavigate('howToPlay'); }}>Tips & Strategy</a></li>
                  </ul>
                </div>
              </div>
            </div>
            <div className="footer-bottom">
              <p>Made with <span role="img" aria-label="dart">ğŸ¯</span> | v1.0 Championship Edition</p>
            </div>
          </div>
        </footer>
      );

      // ============================================
      // LANDING PAGE
      // ============================================
      if (gameState === 'landing') {
        return (
          <div style={{ minHeight: '100vh', background: COLORS.background }}>
            <Navigation onNavigate={setGameState} currentPage="landing" />

            {/* Hero Section */}
            <section style={{
              minHeight: '100vh',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              padding: '100px 24px 60px',
              position: 'relative',
              overflow: 'hidden'
            }}>
              {/* Background gradient */}
              <div style={{
                position: 'absolute',
                inset: 0,
                background: `radial-gradient(ellipse at 30% 20%, ${COLORS.primary}40 0%, transparent 50%), radial-gradient(ellipse at 70% 80%, ${COLORS.accent}20 0%, transparent 40%), linear-gradient(180deg, ${COLORS.background} 0%, ${COLORS.backgroundLight} 100%)`,
                zIndex: 0
              }} />


              <div style={{ maxWidth: '1200px', width: '100%', display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', gap: '60px', alignItems: 'center', zIndex: 2, position: 'relative' }}>
                {/* Text Content */}
                <div className="animate-fade-in">
                  <div style={{ display: 'inline-block', background: `${COLORS.accent}20`, color: COLORS.accent, padding: '8px 16px', borderRadius: '20px', fontSize: '0.85rem', fontWeight: '600', marginBottom: '24px' }}>
                    No Download Required
                  </div>
                  <h1 style={{ color: COLORS.text, marginBottom: '16px', fontWeight: '800' }}>
                    Quik Darts
                    <span style={{ display: 'block', color: COLORS.accent, fontSize: '0.5em', fontWeight: '600', letterSpacing: '3px', marginTop: '8px' }}>CHAMPIONSHIP EDITION</span>
                  </h1>
                  <p style={{ color: COLORS.textMuted, fontSize: '1.25rem', marginBottom: '32px', maxWidth: '500px', lineHeight: '1.7' }}>
                    Championship-style online darts. Play solo, challenge friends, or compete online. Experience realistic 501 gameplay right in your browser.
                  </p>
                </div>

                {/* Game Setup Card */}
                <div className="animate-fade-in animate-delay-2" style={{
                  background: COLORS.backgroundCard,
                  borderRadius: '16px',
                  padding: '32px',
                  border: '1px solid rgba(255, 255, 255, 0.05)',
                  boxShadow: '0 25px 60px rgba(0, 0, 0, 0.5)',
                  width: '100%',
                  maxWidth: '420px'
                }}>
                  {/* Main action buttons - 2x2 Grid */}
                  <div style={{
                    display: 'grid',
                    gridTemplateColumns: 'repeat(2, 1fr)',
                    gap: '12px',
                    marginBottom: '24px'
                  }}>
                    <button className="btn btn-primary" onClick={startGame} style={{
                      padding: '20px 16px',
                      fontSize: '0.95rem',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      justifyContent: 'center',
                      gap: '8px',
                      borderRadius: '12px',
                      minHeight: '90px'
                    }}><DartIcon size={24} color={COLORS.textDark} />Start Game</button>

                    <button className="btn btn-secondary" onClick={startMatchmaking} style={{
                      padding: '20px 16px',
                      fontSize: '0.95rem',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      justifyContent: 'center',
                      gap: '8px',
                      borderRadius: '12px',
                      minHeight: '90px'
                    }}><GlobeIcon size={24} color={COLORS.text} />Play Online</button>

                    <button className="btn btn-ghost" onClick={enterPracticeMode} style={{
                      padding: '20px 16px',
                      fontSize: '0.95rem',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      justifyContent: 'center',
                      gap: '8px',
                      borderRadius: '12px',
                      minHeight: '90px'
                    }}><TargetIcon size={24} color={COLORS.text} />Practice Mode</button>

                    <button className="btn btn-ghost" onClick={() => setShowAchievements(true)} style={{
                      padding: '20px 16px',
                      fontSize: '0.95rem',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      justifyContent: 'center',
                      gap: '8px',
                      borderRadius: '12px',
                      minHeight: '90px',
                      color: COLORS.accent,
                      borderColor: `${COLORS.accent}40`
                    }}><TrophyIcon size={24} color={COLORS.accent} />Achievements</button>
                  </div>

                  {/* Divider */}
                  <div style={{ height: '1px', background: `linear-gradient(90deg, transparent, ${COLORS.accent}30, transparent)`, marginBottom: '24px' }} />

                  {/* Game Mode */}
                  <div style={{ marginBottom: '20px' }}>
                    <label style={{ color: COLORS.textMuted, fontSize: '0.75rem', letterSpacing: '2px', display: 'block', marginBottom: '10px', fontWeight: '600', textTransform: 'uppercase' }}>Game Mode</label>
                    <div style={{ display: 'flex', gap: '8px' }}>
                      {[301, 501].map(mode => (
                        <button key={mode} onClick={() => setPlayerSetup(prev => ({ ...prev, gameMode: mode }))} style={{ flex: 1, padding: '12px', fontSize: '1rem', fontWeight: '600', background: playerSetup.gameMode === mode ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})` : 'rgba(255, 255, 255, 0.03)', color: playerSetup.gameMode === mode ? COLORS.textDark : COLORS.textMuted, border: playerSetup.gameMode === mode ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '6px', cursor: 'pointer' }}>{mode}</button>
                      ))}
                    </div>
                  </div>

                  {/* Legs Per Set */}
                  <div style={{ marginBottom: '20px' }}>
                    <label style={{ color: COLORS.textMuted, fontSize: '0.75rem', letterSpacing: '2px', display: 'block', marginBottom: '10px', fontWeight: '600', textTransform: 'uppercase' }}>Legs Per Set</label>
                    <div style={{ display: 'flex', gap: '8px' }}>
                      {[1, 3, 5, 7].map(legs => (
                        <button key={legs} onClick={() => setPlayerSetup(prev => ({ ...prev, legsPerSet: legs }))} style={{ flex: 1, padding: '12px', fontSize: '1rem', fontWeight: '600', background: playerSetup.legsPerSet === legs ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})` : 'rgba(255, 255, 255, 0.03)', color: playerSetup.legsPerSet === legs ? COLORS.textDark : COLORS.textMuted, border: playerSetup.legsPerSet === legs ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '6px', cursor: 'pointer' }}>{legs}</button>
                      ))}
                    </div>
                  </div>

                  {/* Sets To Win */}
                  <div style={{ marginBottom: '20px' }}>
                    <label style={{ color: COLORS.textMuted, fontSize: '0.75rem', letterSpacing: '2px', display: 'block', marginBottom: '10px', fontWeight: '600', textTransform: 'uppercase' }}>Sets To Win</label>
                    <div style={{ display: 'flex', gap: '8px' }}>
                      {[1, 3, 5, 7].map(sets => (
                        <button key={sets} onClick={() => setPlayerSetup(prev => ({ ...prev, setsToWin: sets }))} style={{ flex: 1, padding: '12px', fontSize: '1rem', fontWeight: '600', background: playerSetup.setsToWin === sets ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})` : 'rgba(255, 255, 255, 0.03)', color: playerSetup.setsToWin === sets ? COLORS.textDark : COLORS.textMuted, border: playerSetup.setsToWin === sets ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '6px', cursor: 'pointer' }}>{sets}</button>
                      ))}
                    </div>
                  </div>

                  {/* Players */}
                  <div style={{ marginBottom: '20px' }}>
                    <label style={{ color: COLORS.textMuted, fontSize: '0.75rem', letterSpacing: '2px', display: 'block', marginBottom: '10px', fontWeight: '600', textTransform: 'uppercase' }}>Players</label>
                    <div style={{ display: 'flex', gap: '8px' }}>
                      {[1, 2, 3, 4].map(num => (
                        <button key={num} onClick={() => setPlayerSetup(prev => ({ ...prev, count: num }))} style={{ flex: 1, padding: '12px', fontSize: '1rem', fontWeight: '600', background: playerSetup.count === num ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})` : 'rgba(255, 255, 255, 0.03)', color: playerSetup.count === num ? COLORS.textDark : COLORS.textMuted, border: playerSetup.count === num ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '6px', cursor: 'pointer' }}>{num}</button>
                      ))}
                    </div>
                  </div>

                  {/* Player Setup */}
                  {Array.from({ length: playerSetup.count }).map((_, i) => (
                    <div key={i} style={{ marginBottom: '12px', background: 'rgba(0, 0, 0, 0.3)', padding: '14px', borderRadius: '8px', border: '1px solid rgba(255, 255, 255, 0.05)' }}>
                      <input
                        type="text"
                        id={`local-player-name-${i}`}
                        name={`local-player-name-${i}`}
                        aria-label={`Player ${i + 1} name`}
                        value={playerSetup.names[i]}
                        onChange={(e) => {
                          const newNames = [...playerSetup.names];
                          newNames[i] = sanitizeName(e.target.value);
                          setPlayerSetup(prev => ({ ...prev, names: newNames }));
                        }}
                        placeholder={`Player ${i + 1}`}
                        maxLength={20}
                        style={{ width: '100%', padding: '11px 14px', fontSize: '14px', background: 'rgba(255, 255, 255, 0.05)', border: '1px solid rgba(255, 255, 255, 0.1)', borderRadius: '6px', color: 'rgba(255, 255, 255, 0.9)', outline: 'none', boxSizing: 'border-box', marginBottom: '10px' }}
                      />
                      <div>
                        <label htmlFor={`local-player-flag-${i}`} style={{ color: 'rgba(255, 255, 255, 0.4)', fontSize: '10px', letterSpacing: '2px', display: 'block', marginBottom: '6px' }}>NATIONALITY</label>
                        <select id={`local-player-flag-${i}`} name={`local-player-flag-${i}`} value={playerSetup.flags[i]} onChange={(e) => { const newFlags = [...playerSetup.flags]; newFlags[i] = e.target.value; setPlayerSetup(prev => ({ ...prev, flags: newFlags })); }} style={{ width: '100%', padding: '10px 12px', fontSize: '14px', background: 'rgba(255, 255, 255, 0.05)', border: '1px solid rgba(255, 255, 255, 0.1)', borderRadius: '6px', color: 'rgba(255, 255, 255, 0.9)', outline: 'none', cursor: 'pointer', boxSizing: 'border-box' }}>
                          {COUNTRIES.map(country => (
                            <option key={country.name} value={country.flag} style={{ background: '#1a1a1a', color: '#fff' }}>
                              {country.flag} {country.name}
                            </option>
                          ))}
                        </select>
                      </div>

                      {i > 0 && playerSetup.count > 1 && (
                        <>
                          <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginTop: '10px', marginBottom: playerSetup.aiPlayers[i] ? '10px' : '0' }}>
                            <span style={{ color: 'rgba(255, 255, 255, 0.4)', fontSize: '10px', letterSpacing: '2px' }}>AI OPPONENT</span>
                            <button onClick={() => {
                              const newAiPlayers = [...playerSetup.aiPlayers];
                              newAiPlayers[i] = !newAiPlayers[i];
                              const newAiDifficulty = [...playerSetup.aiDifficulty];
                              if (newAiPlayers[i] && !newAiDifficulty[i]) newAiDifficulty[i] = AI_DIFFICULTIES.INTERMEDIATE.key;
                              setPlayerSetup(prev => ({ ...prev, aiPlayers: newAiPlayers, aiDifficulty: newAiDifficulty }));
                            }} style={{ padding: '5px 14px', background: playerSetup.aiPlayers[i] ? 'linear-gradient(180deg, #2d8a2d, #1f6b1f)' : 'rgba(255, 255, 255, 0.05)', color: playerSetup.aiPlayers[i] ? '#fff' : 'rgba(255, 255, 255, 0.4)', border: playerSetup.aiPlayers[i] ? 'none' : '1px solid rgba(255, 255, 255, 0.1)', borderRadius: '4px', cursor: 'pointer', fontSize: '11px', fontWeight: '600', letterSpacing: '1px' }}>
                              {playerSetup.aiPlayers[i] ? 'ON' : 'OFF'}
                            </button>
                          </div>

                          {playerSetup.aiPlayers[i] && (
                            <div>
                              <label style={{ color: 'rgba(255, 255, 255, 0.4)', fontSize: '10px', letterSpacing: '2px', display: 'block', marginBottom: '6px' }}>DIFFICULTY</label>
                              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '5px' }}>
                                {Object.values(AI_DIFFICULTIES).map(d => (
                                  <button key={d.key} onClick={() => {
                                    const newAiDifficulty = [...playerSetup.aiDifficulty];
                                    newAiDifficulty[i] = d.key;
                                    setPlayerSetup(prev => ({ ...prev, aiDifficulty: newAiDifficulty }));
                                  }} style={{ padding: '7px 4px', fontSize: '10px', fontWeight: '600', background: playerSetup.aiDifficulty[i] === d.key ? 'linear-gradient(180deg, #c9a227 0%, #a68b1f 100%)' : 'rgba(255, 255, 255, 0.03)', color: playerSetup.aiDifficulty[i] === d.key ? '#0a0a0f' : 'rgba(255, 255, 255, 0.4)', border: playerSetup.aiDifficulty[i] === d.key ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '4px', cursor: 'pointer', textTransform: 'uppercase', letterSpacing: '0.5px' }}>
                                    {d.label.slice(0, 3).toUpperCase()}
                                  </button>
                                ))}
                              </div>
                            </div>
                          )}
                        </>
                      )}
                    </div>
                  ))}

                  {/* Divider */}
                  <div style={{ height: '1px', background: `linear-gradient(90deg, transparent, ${COLORS.accent}30, transparent)`, margin: '20px 0' }} />

                  {/* Skill Level */}
                  <div style={{ marginBottom: '20px' }}>
                    <label style={{ color: COLORS.textMuted, fontSize: '0.75rem', letterSpacing: '2px', display: 'block', marginBottom: '10px', fontWeight: '600', textTransform: 'uppercase' }}>Skill Level</label>
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '8px' }}>
                      <button onClick={() => setSkillLevel(30)} style={{ padding: '12px 8px', background: skillLevel <= 40 ? 'linear-gradient(135deg, #2d8a2d, #1f6b1f)' : 'rgba(255, 255, 255, 0.03)', color: skillLevel <= 40 ? '#fff' : COLORS.textMuted, border: skillLevel <= 40 ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '6px', cursor: 'pointer', fontSize: '0.75rem', fontWeight: '600' }}>
                        <div style={{ width: '8px', height: '8px', borderRadius: '50%', background: skillLevel <= 40 ? '#90EE90' : 'rgba(144, 238, 144, 0.4)', margin: '0 auto 6px' }} />
                        BEGINNER
                      </button>
                      <button onClick={() => setSkillLevel(60)} style={{ padding: '12px 8px', background: skillLevel >= 41 && skillLevel <= 80 ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})` : 'rgba(255, 255, 255, 0.03)', color: skillLevel >= 41 && skillLevel <= 80 ? COLORS.textDark : COLORS.textMuted, border: skillLevel >= 41 && skillLevel <= 80 ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '6px', cursor: 'pointer', fontSize: '0.75rem', fontWeight: '600' }}>
                        <div style={{ width: '8px', height: '8px', borderRadius: '50%', background: skillLevel >= 41 && skillLevel <= 80 ? COLORS.textDark : 'rgba(255, 193, 7, 0.4)', margin: '0 auto 6px' }} />
                        INTERMEDIATE
                      </button>
                      <button onClick={() => setSkillLevel(90)} style={{ padding: '12px 8px', background: skillLevel >= 81 ? 'linear-gradient(135deg, #a61c1c, #8a1717)' : 'rgba(255, 255, 255, 0.03)', color: skillLevel >= 81 ? '#fff' : COLORS.textMuted, border: skillLevel >= 81 ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '6px', cursor: 'pointer', fontSize: '0.75rem', fontWeight: '600' }}>
                        <div style={{ width: '8px', height: '8px', borderRadius: '50%', background: skillLevel >= 81 ? '#ff6b6b' : 'rgba(255, 107, 107, 0.4)', margin: '0 auto 6px' }} />
                        EXPERT
                      </button>
                    </div>
                  </div>

                  {/* Sound */}
                  <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '12px 0' }}>
                    <span style={{ color: COLORS.textMuted, fontSize: '0.75rem', letterSpacing: '2px', fontWeight: '600' }}>SOUND</span>
                    <button onClick={() => setSoundEnabled(!soundEnabled)} style={{ padding: '6px 16px', background: soundEnabled ? 'linear-gradient(135deg, #2d8a2d, #1f6b1f)' : 'rgba(255, 255, 255, 0.05)', color: soundEnabled ? '#fff' : COLORS.textMuted, border: soundEnabled ? 'none' : '1px solid rgba(255, 255, 255, 0.1)', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem', fontWeight: '600' }}>{soundEnabled ? 'ON' : 'OFF'}</button>
                  </div>
                </div>
              </div>
            </section>

            {/* Features Section */}
            <section style={{ padding: '80px 24px', background: COLORS.backgroundLight }}>
              <div style={{ maxWidth: '1200px', margin: '0 auto' }}>
                <h2 style={{ textAlign: 'center', color: COLORS.text, marginBottom: '16px' }}>Why Play Quik Darts?</h2>
                <p style={{ textAlign: 'center', color: COLORS.textMuted, marginBottom: '48px', maxWidth: '600px', margin: '0 auto 48px' }}>
                  Experience the thrill of competitive darts with features designed for players of all skill levels.
                </p>
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))', gap: '24px' }}>
                  {[
                    { icon: <TargetIcon size={32} color={COLORS.accent} />, title: 'Realistic Gameplay', desc: 'Authentic 501 rules with double-out finish. Power meter and aim wobble simulate real darts.' },
                    { icon: <GlobeIcon size={32} color={COLORS.accent} />, title: 'Play Online', desc: 'Challenge players worldwide in real-time matches. No account required to get started.' },
                    { icon: <UsersIcon size={32} color={COLORS.accent} />, title: 'Local Multiplayer', desc: 'Play with up to 4 players on the same device. Perfect for game night with friends.' },
                    { icon: <TrophyIcon size={32} color={COLORS.accent} />, title: 'Track Progress', desc: 'Earn achievements, track your stats, and climb the leaderboards.' }
                  ].map((feature, i) => (
                    <div key={i} style={{
                      background: COLORS.backgroundCard,
                      padding: '32px',
                      borderRadius: '12px',
                      border: `1px solid rgba(255,255,255,0.05)`
                    }}>
                      <div style={{ marginBottom: '16px' }}>{feature.icon}</div>
                      <h3 style={{ color: COLORS.text, fontSize: '1.25rem', marginBottom: '8px' }}>{feature.title}</h3>
                      <p style={{ color: COLORS.textMuted, fontSize: '0.95rem', lineHeight: '1.6' }}>{feature.desc}</p>
                    </div>
                  ))}
                </div>
              </div>
            </section>

            {/* CTA Section */}
            <section style={{ padding: '80px 24px', background: COLORS.background, textAlign: 'center' }}>
              <h2 style={{ color: COLORS.text, marginBottom: '16px' }}>Ready to Play?</h2>
              <p style={{ color: COLORS.textMuted, marginBottom: '32px', maxWidth: '500px', margin: '0 auto 32px' }}>
                Jump into a game now. No downloads, no sign-ups, just darts.
              </p>
              <button className="btn btn-primary" onClick={() => setGameState('menu')} style={{ fontSize: '1.1rem', padding: '16px 40px' }}>
                <PlayIcon /> Start Playing
              </button>
            </section>

            <Footer onNavigate={setGameState} />
          </div>
        );
      }

      // ============================================
      // HOW TO PLAY PAGE
      // ============================================
      if (gameState === 'howToPlay') {
        return (
          <div style={{ minHeight: '100vh', background: COLORS.background }}>
            <Navigation onNavigate={setGameState} currentPage="howToPlay" />

            <main style={{ paddingTop: '100px', paddingBottom: '80px' }}>
              <div style={{ maxWidth: '800px', margin: '0 auto', padding: '0 24px' }}>
                <h1 style={{ color: COLORS.text, marginBottom: '16px' }}>How to Play</h1>
                <p style={{ color: COLORS.textMuted, fontSize: '1.1rem', marginBottom: '48px' }}>
                  Learn the basics of Quik Darts and become a champion.
                </p>

                {/* Section: Basic Rules */}
                <section style={{ marginBottom: '48px' }}>
                  <h2 style={{ color: COLORS.accent, fontSize: '1.5rem', marginBottom: '16px', display: 'flex', alignItems: 'center', gap: '12px' }}>
                    <span style={{ background: COLORS.accent, color: COLORS.textDark, width: '32px', height: '32px', borderRadius: '50%', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '1rem', fontWeight: '700' }}>1</span>
                    Basic 501 Rules
                  </h2>
                  <div style={{ background: COLORS.backgroundCard, padding: '24px', borderRadius: '12px', border: '1px solid rgba(255,255,255,0.05)' }}>
                    <ul style={{ color: COLORS.textMuted, lineHeight: '1.8', paddingLeft: '20px' }}>
                      <li>Each player starts with <strong style={{ color: COLORS.text }}>501 points</strong></li>
                      <li>Throw 3 darts per turn to reduce your score</li>
                      <li>Score is subtracted from your total after each turn</li>
                      <li>You must finish exactly on <strong style={{ color: COLORS.text }}>0 points</strong></li>
                      <li>The final dart must land on a <strong style={{ color: COLORS.accent }}>double</strong> (outer ring) or the bullseye</li>
                      <li>If you go below 0 or hit exactly 1, your turn is "bust" and your score resets</li>
                    </ul>
                  </div>
                </section>

                {/* Section: Scoring */}
                <section style={{ marginBottom: '48px' }}>
                  <h2 style={{ color: COLORS.accent, fontSize: '1.5rem', marginBottom: '16px', display: 'flex', alignItems: 'center', gap: '12px' }}>
                    <span style={{ background: COLORS.accent, color: COLORS.textDark, width: '32px', height: '32px', borderRadius: '50%', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '1rem', fontWeight: '700' }}>2</span>
                    Dartboard Scoring
                  </h2>
                  <div style={{ background: COLORS.backgroundCard, padding: '24px', borderRadius: '12px', border: '1px solid rgba(255,255,255,0.05)' }}>
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '16px' }}>
                      <div style={{ padding: '16px', background: 'rgba(0,0,0,0.2)', borderRadius: '8px' }}>
                        <h4 style={{ color: COLORS.text, marginBottom: '8px' }}>Single (Main Bed)</h4>
                        <p style={{ color: COLORS.textMuted, fontSize: '0.9rem' }}>Face value of the number (1-20)</p>
                      </div>
                      <div style={{ padding: '16px', background: 'rgba(0,0,0,0.2)', borderRadius: '8px' }}>
                        <h4 style={{ color: COLORS.text, marginBottom: '8px' }}>Double (Outer Ring)</h4>
                        <p style={{ color: COLORS.textMuted, fontSize: '0.9rem' }}>2x the number value</p>
                      </div>
                      <div style={{ padding: '16px', background: 'rgba(0,0,0,0.2)', borderRadius: '8px' }}>
                        <h4 style={{ color: COLORS.text, marginBottom: '8px' }}>Triple (Inner Ring)</h4>
                        <p style={{ color: COLORS.textMuted, fontSize: '0.9rem' }}>3x the number value</p>
                      </div>
                      <div style={{ padding: '16px', background: 'rgba(0,0,0,0.2)', borderRadius: '8px' }}>
                        <h4 style={{ color: COLORS.text, marginBottom: '8px' }}>Bullseye</h4>
                        <p style={{ color: COLORS.textMuted, fontSize: '0.9rem' }}>Outer: 25 | Inner: 50 (double)</p>
                      </div>
                    </div>
                  </div>
                </section>

                {/* Section: Controls */}
                <section style={{ marginBottom: '48px' }}>
                  <h2 style={{ color: COLORS.accent, fontSize: '1.5rem', marginBottom: '16px', display: 'flex', alignItems: 'center', gap: '12px' }}>
                    <span style={{ background: COLORS.accent, color: COLORS.textDark, width: '32px', height: '32px', borderRadius: '50%', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '1rem', fontWeight: '700' }}>3</span>
                    How to Throw
                  </h2>
                  <div style={{ background: COLORS.backgroundCard, padding: '24px', borderRadius: '12px', border: '1px solid rgba(255,255,255,0.05)' }}>
                    <ol style={{ color: COLORS.textMuted, lineHeight: '2', paddingLeft: '20px' }}>
                      <li><strong style={{ color: COLORS.text }}>Aim:</strong> Move your mouse/finger to position your aim on the dartboard</li>
                      <li><strong style={{ color: COLORS.text }}>Charge:</strong> Press and hold the mouse button or tap and hold to charge power</li>
                      <li><strong style={{ color: COLORS.text }}>Release:</strong> Let go when the power meter is in the green zone (40-60%) for best accuracy</li>
                      <li><strong style={{ color: COLORS.text }}>Wobble:</strong> Your aim naturally wobbles - this simulates real throwing variance</li>
                    </ol>
                    <div style={{ marginTop: '16px', padding: '16px', background: `${COLORS.accent}15`, borderRadius: '8px', borderLeft: `3px solid ${COLORS.accent}` }}>
                      <p style={{ color: COLORS.text, fontSize: '0.9rem', margin: 0 }}>
                        <strong>Pro Tip:</strong> Higher skill levels reduce wobble. Practice to improve your accuracy!
                      </p>
                    </div>
                  </div>
                </section>

                {/* Section: Game Modes */}
                <section style={{ marginBottom: '48px' }}>
                  <h2 style={{ color: COLORS.accent, fontSize: '1.5rem', marginBottom: '16px', display: 'flex', alignItems: 'center', gap: '12px' }}>
                    <span style={{ background: COLORS.accent, color: COLORS.textDark, width: '32px', height: '32px', borderRadius: '50%', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '1rem', fontWeight: '700' }}>4</span>
                    Game Modes
                  </h2>
                  <div style={{ display: 'grid', gap: '16px' }}>
                    {[
                      { title: 'Local Play', desc: '1-4 players on the same device. Add AI opponents for extra challenge.' },
                      { title: 'Online Match', desc: 'Play against real opponents worldwide. Get matched instantly.' },
                      { title: 'Practice Mode', desc: 'Hone your skills with unlimited throws. No pressure, just practice.' }
                    ].map((mode, i) => (
                      <div key={i} style={{ background: COLORS.backgroundCard, padding: '20px', borderRadius: '12px', border: '1px solid rgba(255,255,255,0.05)' }}>
                        <h4 style={{ color: COLORS.text, marginBottom: '8px' }}>{mode.title}</h4>
                        <p style={{ color: COLORS.textMuted, fontSize: '0.95rem', margin: 0 }}>{mode.desc}</p>
                      </div>
                    ))}
                  </div>
                </section>

                <div style={{ textAlign: 'center', marginTop: '48px' }}>
                  <button className="btn btn-primary" onClick={() => setGameState('menu')} style={{ fontSize: '1.1rem', padding: '16px 40px' }}>
                    <PlayIcon /> Start Playing
                  </button>
                </div>
              </div>
            </main>

            <Footer onNavigate={setGameState} />
          </div>
        );
      }

      // ============================================
      // GAME SETUP MENU
      // ============================================
      if (gameState === 'menu') {
        return (
          <div style={{ minHeight: '100vh', background: COLORS.background }}>
            <Navigation onNavigate={setGameState} currentPage="menu" />

            <main style={{
              minHeight: '100vh',
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
              justifyContent: 'center',
              padding: '100px 20px 40px',
              position: 'relative'
            }}>
              {/* Background accent */}
              <div style={{
                position: 'absolute',
                inset: 0,
                background: `radial-gradient(ellipse at 50% 0%, ${COLORS.primary}30 0%, transparent 50%), radial-gradient(ellipse at 80% 100%, ${COLORS.accent}15 0%, transparent 40%)`,
                zIndex: 0
              }} />

            {/* Decorative dartboard silhouette */}
            <div style={{
              position: 'absolute',
              right: '-150px',
              top: '50%',
              transform: 'translateY(-50%)',
              width: '500px',
              height: '500px',
              opacity: 0.03,
              zIndex: 1,
              background: 'radial-gradient(circle, #fff 0%, #fff 8%, transparent 8%, transparent 15%, #fff 15%, #fff 20%, transparent 20%, transparent 45%, #fff 45%, #fff 48%, transparent 48%, transparent 85%, #fff 85%, #fff 90%, transparent 90%)',
              borderRadius: '50%'
            }} />

            {/* Title section */}
            <div style={{ textAlign: 'center', marginBottom: '40px', zIndex: 2, position: 'relative' }}>
              <h1 style={{
                fontSize: 'clamp(36px, 10vw, 56px)',
                fontWeight: '800',
                margin: '0',
                color: COLORS.text
              }}>Game Setup</h1>
              <p style={{ color: COLORS.textMuted, marginTop: '8px' }}>Configure your match settings</p>
            </div>

            {/* Main content card */}
            <div style={{
              background: COLORS.backgroundCard,
              borderRadius: '16px',
              padding: '32px',
              border: '1px solid rgba(255, 255, 255, 0.05)',
              boxShadow: '0 25px 60px rgba(0, 0, 0, 0.5)',
              width: '100%',
              maxWidth: '480px',
              zIndex: 2,
              position: 'relative'
            }}>
              {/* Main action buttons - 2x2 Grid */}
              <div style={{
                display: 'grid',
                gridTemplateColumns: 'repeat(2, 1fr)',
                gap: '12px',
                marginBottom: '24px'
              }}>
                <button className="btn btn-primary" onClick={startGame} style={{
                  padding: '20px 16px',
                  fontSize: '0.95rem',
                  display: 'flex',
                  flexDirection: 'column',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '8px',
                  borderRadius: '12px',
                  minHeight: '90px'
                }}><DartIcon size={24} color={COLORS.textDark} />Start Game</button>

                <button className="btn btn-secondary" onClick={startMatchmaking} style={{
                  padding: '20px 16px',
                  fontSize: '0.95rem',
                  display: 'flex',
                  flexDirection: 'column',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '8px',
                  borderRadius: '12px',
                  minHeight: '90px'
                }}><GlobeIcon size={24} color={COLORS.text} />Play Online</button>

                <button className="btn btn-ghost" onClick={enterPracticeMode} style={{
                  padding: '20px 16px',
                  fontSize: '0.95rem',
                  display: 'flex',
                  flexDirection: 'column',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '8px',
                  borderRadius: '12px',
                  minHeight: '90px'
                }}><TargetIcon size={24} color={COLORS.text} />Practice Mode</button>

                <button className="btn btn-ghost" onClick={() => setShowAchievements(true)} style={{
                  padding: '20px 16px',
                  fontSize: '0.95rem',
                  display: 'flex',
                  flexDirection: 'column',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '8px',
                  borderRadius: '12px',
                  minHeight: '90px',
                  color: COLORS.accent,
                  borderColor: `${COLORS.accent}40`
                }}><TrophyIcon size={24} color={COLORS.accent} />Achievements</button>
              </div>

              {/* Divider */}
              <div style={{ height: '1px', background: `linear-gradient(90deg, transparent, ${COLORS.accent}30, transparent)`, marginBottom: '24px' }} />

              <div style={{ marginBottom: '20px' }}>
                <label style={{ color: COLORS.textMuted, fontSize: '0.75rem', letterSpacing: '2px', display: 'block', marginBottom: '10px', fontWeight: '600', textTransform: 'uppercase' }}>Game Mode</label>
                <div style={{ display: 'flex', gap: '8px' }}>
                  {[301, 501].map(mode => (
                    <button key={mode} onClick={() => setPlayerSetup(prev => ({ ...prev, gameMode: mode }))} style={{ flex: 1, padding: '12px', fontSize: '1rem', fontWeight: '600', background: playerSetup.gameMode === mode ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})` : 'rgba(255, 255, 255, 0.03)', color: playerSetup.gameMode === mode ? COLORS.textDark : COLORS.textMuted, border: playerSetup.gameMode === mode ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '6px', cursor: 'pointer', fontFamily: 'var(--font-primary)' }}>{mode}</button>
                  ))}
                </div>
              </div>

              <div style={{ marginBottom: '22px' }}>
                <label style={{ color: 'rgba(201, 162, 39, 0.8)', fontSize: '11px', letterSpacing: '3px', display: 'block', marginBottom: '10px', fontWeight: '500' }}>LEGS PER SET</label>
                <div style={{ display: 'flex', gap: '8px' }}>
                  {[1, 3, 5, 7].map(legs => (
                    <button key={legs} onClick={() => setPlayerSetup(prev => ({ ...prev, legsPerSet: legs }))} style={{ flex: 1, padding: '14px', fontSize: '18px', fontWeight: '600', background: playerSetup.legsPerSet === legs ? 'linear-gradient(180deg, #c9a227 0%, #a68b1f 100%)' : 'rgba(255, 255, 255, 0.03)', color: playerSetup.legsPerSet === legs ? '#0a0a0f' : 'rgba(255, 255, 255, 0.5)', border: playerSetup.legsPerSet === legs ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '6px', cursor: 'pointer', fontFamily: "'Oswald', sans-serif", boxShadow: playerSetup.legsPerSet === legs ? 'inset 0 1px 0 rgba(255, 255, 255, 0.3)' : 'none' }}>{legs}</button>
                  ))}
                </div>
              </div>

              <div style={{ marginBottom: '22px' }}>
                <label style={{ color: 'rgba(201, 162, 39, 0.8)', fontSize: '11px', letterSpacing: '3px', display: 'block', marginBottom: '10px', fontWeight: '500' }}>SETS TO WIN</label>
                <div style={{ display: 'flex', gap: '8px' }}>
                  {[1, 3, 5, 7].map(sets => (
                    <button key={sets} onClick={() => setPlayerSetup(prev => ({ ...prev, setsToWin: sets }))} style={{ flex: 1, padding: '14px', fontSize: '18px', fontWeight: '600', background: playerSetup.setsToWin === sets ? 'linear-gradient(180deg, #c9a227 0%, #a68b1f 100%)' : 'rgba(255, 255, 255, 0.03)', color: playerSetup.setsToWin === sets ? '#0a0a0f' : 'rgba(255, 255, 255, 0.5)', border: playerSetup.setsToWin === sets ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '6px', cursor: 'pointer', fontFamily: "'Oswald', sans-serif", boxShadow: playerSetup.setsToWin === sets ? 'inset 0 1px 0 rgba(255, 255, 255, 0.3)' : 'none' }}>{sets}</button>
                  ))}
                </div>
              </div>

              <div style={{ marginBottom: '22px' }}>
                <label style={{ color: 'rgba(201, 162, 39, 0.8)', fontSize: '11px', letterSpacing: '3px', display: 'block', marginBottom: '10px', fontWeight: '500' }}>PLAYERS</label>
                <div style={{ display: 'flex', gap: '8px' }}>
                  {[1, 2, 3, 4].map(num => (
                    <button key={num} onClick={() => setPlayerSetup(prev => ({ ...prev, count: num }))} style={{ flex: 1, padding: '14px', fontSize: '18px', fontWeight: '600', background: playerSetup.count === num ? 'linear-gradient(180deg, #c9a227 0%, #a68b1f 100%)' : 'rgba(255, 255, 255, 0.03)', color: playerSetup.count === num ? '#0a0a0f' : 'rgba(255, 255, 255, 0.5)', border: playerSetup.count === num ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '6px', cursor: 'pointer', fontFamily: "'Oswald', sans-serif", boxShadow: playerSetup.count === num ? 'inset 0 1px 0 rgba(255, 255, 255, 0.3)' : 'none' }}>{num}</button>
                  ))}
                </div>
              </div>
              
              {Array.from({ length: playerSetup.count }).map((_, i) => (
                <div key={i} style={{ marginBottom: '12px', background: 'rgba(0, 0, 0, 0.3)', padding: '14px', borderRadius: '8px', border: '1px solid rgba(255, 255, 255, 0.05)' }}>
                  <input
                    type="text"
                    id={`online-player-name-${i}`}
                    name={`online-player-name-${i}`}
                    aria-label={`Player ${i + 1} name`}
                    value={playerSetup.names[i]}
                    onChange={(e) => {
                      const newNames = [...playerSetup.names];
                      newNames[i] = sanitizeName(e.target.value);
                      setPlayerSetup(prev => ({ ...prev, names: newNames }));
                    }}
                    placeholder={`Player ${i + 1}`}
                    maxLength={20}
                    style={{ width: '100%', padding: '11px 14px', fontSize: '14px', background: 'rgba(255, 255, 255, 0.05)', border: '1px solid rgba(255, 255, 255, 0.1)', borderRadius: '6px', color: 'rgba(255, 255, 255, 0.9)', outline: 'none', fontFamily: "'Roboto Mono', monospace", boxSizing: 'border-box', marginBottom: '10px' }}
                  />

                  <div style={{ marginBottom: '10px' }}>
                    <label htmlFor={`online-player-flag-${i}`} style={{ color: 'rgba(255, 255, 255, 0.4)', fontSize: '10px', letterSpacing: '2px', display: 'block', marginBottom: '6px' }}>NATIONALITY</label>
                    <select id={`online-player-flag-${i}`} name={`online-player-flag-${i}`} value={playerSetup.flags[i]} onChange={(e) => { const newFlags = [...playerSetup.flags]; newFlags[i] = e.target.value; setPlayerSetup(prev => ({ ...prev, flags: newFlags })); }} style={{ width: '100%', padding: '10px 12px', fontSize: '14px', background: 'rgba(255, 255, 255, 0.05)', border: '1px solid rgba(255, 255, 255, 0.1)', borderRadius: '6px', color: 'rgba(255, 255, 255, 0.9)', outline: 'none', fontFamily: "'Roboto Mono', monospace", cursor: 'pointer', boxSizing: 'border-box' }}>
                      {COUNTRIES.map(country => (
                        <option key={country.name} value={country.flag} style={{ background: '#1a1a1a', color: '#fff' }}>
                          {country.flag} {country.name}
                        </option>
                      ))}
                    </select>
                  </div>

                  {i > 0 && playerSetup.count > 1 && (
                    <>
                      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: playerSetup.aiPlayers[i] ? '10px' : '0' }}>
                        <span style={{ color: 'rgba(255, 255, 255, 0.4)', fontSize: '10px', letterSpacing: '2px' }}>AI OPPONENT</span>
                        <button onClick={() => {
                          const newAiPlayers = [...playerSetup.aiPlayers];
                          newAiPlayers[i] = !newAiPlayers[i];
                          const newAiDifficulty = [...playerSetup.aiDifficulty];
                          if (newAiPlayers[i] && !newAiDifficulty[i]) newAiDifficulty[i] = AI_DIFFICULTIES.INTERMEDIATE.key;
                          setPlayerSetup(prev => ({ ...prev, aiPlayers: newAiPlayers, aiDifficulty: newAiDifficulty }));
                        }} style={{ padding: '5px 14px', background: playerSetup.aiPlayers[i] ? 'linear-gradient(180deg, #2d8a2d, #1f6b1f)' : 'rgba(255, 255, 255, 0.05)', color: playerSetup.aiPlayers[i] ? '#fff' : 'rgba(255, 255, 255, 0.4)', border: playerSetup.aiPlayers[i] ? 'none' : '1px solid rgba(255, 255, 255, 0.1)', borderRadius: '4px', cursor: 'pointer', fontFamily: "'Oswald', sans-serif", fontSize: '11px', fontWeight: '600', letterSpacing: '1px' }}>
                          {playerSetup.aiPlayers[i] ? 'ON' : 'OFF'}
                        </button>
                      </div>

                      {playerSetup.aiPlayers[i] && (
                        <div>
                          <label style={{ color: 'rgba(255, 255, 255, 0.4)', fontSize: '10px', letterSpacing: '2px', display: 'block', marginBottom: '6px' }}>DIFFICULTY</label>
                          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '5px' }}>
                            {Object.values(AI_DIFFICULTIES).map(d => (
                              <button key={d.key} onClick={() => {
                                const newAiDifficulty = [...playerSetup.aiDifficulty];
                                newAiDifficulty[i] = d.key;
                                setPlayerSetup(prev => ({ ...prev, aiDifficulty: newAiDifficulty }));
                              }} style={{ padding: '7px 4px', fontSize: '10px', fontWeight: '600', background: playerSetup.aiDifficulty[i] === d.key ? 'linear-gradient(180deg, #c9a227 0%, #a68b1f 100%)' : 'rgba(255, 255, 255, 0.03)', color: playerSetup.aiDifficulty[i] === d.key ? '#0a0a0f' : 'rgba(255, 255, 255, 0.4)', border: playerSetup.aiDifficulty[i] === d.key ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '4px', cursor: 'pointer', fontFamily: "'Oswald', sans-serif", textTransform: 'uppercase', letterSpacing: '0.5px' }}>
                                {d.label.slice(0, 3).toUpperCase()}
                              </button>
                            ))}
                          </div>
                        </div>
                      )}
                    </>
                  )}
                </div>
              ))}
              
              {/* Divider */}
              <div style={{ height: '1px', background: 'linear-gradient(90deg, transparent, rgba(201, 162, 39, 0.2), transparent)', margin: '20px 0' }} />

              <div style={{ marginBottom: '20px' }}>
                <label style={{ color: 'rgba(201, 162, 39, 0.8)', fontSize: '11px', letterSpacing: '3px', display: 'block', marginBottom: '10px', fontWeight: '500' }}>SKILL LEVEL</label>
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '8px' }}>
                  <button
                    onClick={() => setSkillLevel(30)}
                    style={{
                      padding: '14px 8px',
                      background: skillLevel <= 40 ? 'linear-gradient(180deg, #2d8a2d, #1f6b1f)' : 'rgba(255, 255, 255, 0.03)',
                      color: skillLevel <= 40 ? '#fff' : 'rgba(255, 255, 255, 0.5)',
                      border: skillLevel <= 40 ? 'none' : '1px solid rgba(255, 255, 255, 0.08)',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      fontFamily: "'Oswald', sans-serif",
                      fontSize: '12px',
                      fontWeight: '600',
                      letterSpacing: '1px',
                      boxShadow: skillLevel <= 40 ? 'inset 0 1px 0 rgba(255, 255, 255, 0.2)' : 'none'
                    }}
                  >
                    <div style={{ width: '8px', height: '8px', borderRadius: '50%', background: skillLevel <= 40 ? '#90EE90' : 'rgba(144, 238, 144, 0.4)', margin: '0 auto 6px' }} />
                    BEGINNER
                  </button>
                  <button
                    onClick={() => setSkillLevel(60)}
                    style={{
                      padding: '14px 8px',
                      background: skillLevel >= 41 && skillLevel <= 80 ? 'linear-gradient(180deg, #c9a227, #a68b1f)' : 'rgba(255, 255, 255, 0.03)',
                      color: skillLevel >= 41 && skillLevel <= 80 ? '#0a0a0f' : 'rgba(255, 255, 255, 0.5)',
                      border: skillLevel >= 41 && skillLevel <= 80 ? 'none' : '1px solid rgba(255, 255, 255, 0.08)',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      fontFamily: "'Oswald', sans-serif",
                      fontSize: '12px',
                      fontWeight: '600',
                      letterSpacing: '1px',
                      boxShadow: skillLevel >= 41 && skillLevel <= 80 ? 'inset 0 1px 0 rgba(255, 255, 255, 0.3)' : 'none'
                    }}
                  >
                    <div style={{ width: '8px', height: '8px', borderRadius: '50%', background: skillLevel >= 41 && skillLevel <= 80 ? '#0a0a0f' : 'rgba(255, 193, 7, 0.4)', margin: '0 auto 6px' }} />
                    INTERMEDIATE
                  </button>
                  <button
                    onClick={() => setSkillLevel(90)}
                    style={{
                      padding: '14px 8px',
                      background: skillLevel >= 81 ? 'linear-gradient(180deg, #a61c1c, #8a1717)' : 'rgba(255, 255, 255, 0.03)',
                      color: skillLevel >= 81 ? '#fff' : 'rgba(255, 255, 255, 0.5)',
                      border: skillLevel >= 81 ? 'none' : '1px solid rgba(255, 255, 255, 0.08)',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      fontFamily: "'Oswald', sans-serif",
                      fontSize: '12px',
                      fontWeight: '600',
                      letterSpacing: '1px',
                      boxShadow: skillLevel >= 81 ? 'inset 0 1px 0 rgba(255, 255, 255, 0.2)' : 'none'
                    }}
                  >
                    <div style={{ width: '8px', height: '8px', borderRadius: '50%', background: skillLevel >= 81 ? '#ff6b6b' : 'rgba(255, 107, 107, 0.4)', margin: '0 auto 6px' }} />
                    EXPERT
                  </button>
                </div>
              </div>

              <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '12px 0' }}>
                <span style={{ color: 'rgba(255, 255, 255, 0.5)', fontSize: '12px', letterSpacing: '2px' }}>SOUND</span>
                <button onClick={() => setSoundEnabled(!soundEnabled)} style={{ padding: '6px 16px', background: soundEnabled ? 'linear-gradient(180deg, #2d8a2d, #1f6b1f)' : 'rgba(255, 255, 255, 0.05)', color: soundEnabled ? '#fff' : 'rgba(255, 255, 255, 0.4)', border: soundEnabled ? 'none' : '1px solid rgba(255, 255, 255, 0.1)', borderRadius: '4px', cursor: 'pointer', fontFamily: "'Oswald', sans-serif", fontSize: '12px', fontWeight: '600', letterSpacing: '1px' }}>{soundEnabled ? 'ON' : 'OFF'}</button>
              </div>
            </div>

            <p style={{ color: COLORS.textMuted, marginTop: '24px', fontSize: '0.85rem', zIndex: 2, position: 'relative' }}>Hold to charge power â€¢ Release to throw</p>
            </main>

            <Footer onNavigate={setGameState} />
          </div>
        );
      }

      return (
        <div style={{ minHeight: '100vh', background: COLORS.background, padding: '20px', fontFamily: "'Inter', sans-serif", position: 'relative' }}>
          {/* Background gradient matching home screen */}
          <div style={{ position: 'absolute', inset: 0, background: `radial-gradient(ellipse at 30% 20%, ${COLORS.primary}40 0%, transparent 50%), radial-gradient(ellipse at 70% 80%, ${COLORS.accent}20 0%, transparent 40%)`, zIndex: 0, pointerEvents: 'none' }} />
          <div className="game-layout" style={{ display: 'flex', flexWrap: 'wrap', gap: '30px', maxWidth: '1400px', margin: '0 auto', justifyContent: 'center', position: 'relative', zIndex: 1 }}>
            {/* Scoreboard or Practice Stats */}
            <div className="game-scoreboard" style={{ background: COLORS.backgroundCard, borderRadius: '16px', padding: '25px', minWidth: '280px', backdropFilter: 'blur(10px)', border: practiceMode === 'active' ? `1px solid ${COLORS.primary}50` : `1px solid ${COLORS.accent}30` }}>
              {practiceMode === 'active' ? (
                <>
                  <h2 style={{ color: COLORS.primary, margin: '0 0 20px 0', letterSpacing: '2px', fontSize: '16px', fontWeight: '700', display: 'flex', alignItems: 'center', gap: '10px' }}>
                    <span>ğŸ¯</span> PRACTICE MODE
                  </h2>

                  <div style={{ background: `${COLORS.primary}15`, borderRadius: '10px', padding: '15px', marginBottom: '20px', border: `1px solid ${COLORS.primary}30` }}>
                    <div style={{ color: COLORS.textMuted, fontSize: '11px', letterSpacing: '1px', marginBottom: '5px' }}>SKILL LEVEL</div>
                    <div style={{ color: COLORS.text, fontSize: '16px', fontWeight: '600' }}>
                      {practiceSkillLevel <= 40 && 'ğŸŸ¢ BEGINNER'}
                      {practiceSkillLevel > 40 && practiceSkillLevel <= 80 && 'ğŸŸ¡ INTERMEDIATE'}
                      {practiceSkillLevel > 80 && 'ğŸ”´ EXPERT'}
                    </div>
                  </div>

                  <div style={{ background: 'rgba(255, 255, 255, 0.03)', borderRadius: '10px', padding: '15px', marginBottom: '15px', border: '1px solid rgba(255, 255, 255, 0.05)' }}>
                    <div style={{ color: COLORS.accent, fontSize: '11px', letterSpacing: '2px', marginBottom: '10px', fontWeight: '600' }}>SESSION STATS</div>
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px', fontSize: '14px' }}>
                      <div>
                        <div style={{ color: COLORS.textMuted, fontSize: '11px' }}>Darts Thrown</div>
                        <div style={{ fontSize: '20px', fontWeight: '600', color: COLORS.text }}>{practiceStats.dartsThrown}</div>
                      </div>
                      <div>
                        <div style={{ color: COLORS.textMuted, fontSize: '11px' }}>Total Score</div>
                        <div style={{ fontSize: '20px', fontWeight: '600', color: COLORS.text }}>{practiceStats.totalScore}</div>
                      </div>
                      <div>
                        <div style={{ color: COLORS.textMuted, fontSize: '11px' }}>Average</div>
                        <div style={{ fontSize: '20px', fontWeight: '600', color: COLORS.success }}>
                          {practiceStats.dartsThrown > 0 ? (practiceStats.totalScore / practiceStats.dartsThrown).toFixed(1) : '0.0'}
                        </div>
                      </div>
                      <div>
                        <div style={{ color: COLORS.textMuted, fontSize: '11px' }}>Bulls</div>
                        <div style={{ fontSize: '20px', fontWeight: '600', color: COLORS.error }}>{practiceStats.bulls}</div>
                      </div>
                    </div>
                  </div>

                  <div style={{ background: 'rgba(255, 255, 255, 0.03)', borderRadius: '10px', padding: '15px', marginBottom: '20px', border: '1px solid rgba(255, 255, 255, 0.05)' }}>
                    <div style={{ color: COLORS.accent, fontSize: '11px', letterSpacing: '2px', marginBottom: '10px', fontWeight: '600' }}>ACCURACY</div>
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px', fontSize: '14px' }}>
                      <div>
                        <div style={{ color: COLORS.textMuted, fontSize: '11px' }}>Triples</div>
                        <div style={{ fontSize: '18px', fontWeight: '600', color: COLORS.text }}>{practiceStats.triples}</div>
                      </div>
                      <div>
                        <div style={{ color: COLORS.textMuted, fontSize: '11px' }}>Doubles</div>
                        <div style={{ fontSize: '18px', fontWeight: '600', color: COLORS.text }}>{practiceStats.doubles}</div>
                      </div>
                      <div>
                        <div style={{ color: COLORS.textMuted, fontSize: '11px' }}>T20</div>
                        <div style={{ fontSize: '18px', fontWeight: '600', color: COLORS.success }}>{practiceStats.t20}</div>
                      </div>
                      <div>
                        <div style={{ color: COLORS.textMuted, fontSize: '11px' }}>T19</div>
                        <div style={{ fontSize: '18px', fontWeight: '600', color: COLORS.text }}>{practiceStats.t19}</div>
                      </div>
                    </div>
                  </div>

                  <button
                    onClick={exitPracticeMode}
                    style={{
                      width: '100%',
                      padding: '15px',
                      background: `linear-gradient(135deg, ${COLORS.error}, #e74c3c)`,
                      color: COLORS.text,
                      border: 'none',
                      borderRadius: '10px',
                      fontSize: '14px',
                      fontWeight: '600',
                      cursor: 'pointer',
                      fontFamily: "'Inter', sans-serif",
                      letterSpacing: '1px',
                      textTransform: 'uppercase'
                    }}
                  >
                    Exit Practice
                  </button>
                </>
              ) : (
                <>
                  <h2 style={{ color: COLORS.accent, margin: '0 0 20px 0', letterSpacing: '2px', fontSize: '16px', fontWeight: '700' }}>SCOREBOARD</h2>

                  {players.map((player, index) => (
                <div key={index} style={{ background: currentPlayerIndex === index ? `linear-gradient(135deg, ${COLORS.accent}20, ${COLORS.accent}10)` : 'rgba(255, 255, 255, 0.03)', borderRadius: '12px', padding: '20px', marginBottom: '15px', border: currentPlayerIndex === index ? `2px solid ${COLORS.accent}` : '1px solid rgba(255, 255, 255, 0.08)' }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '5px' }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                      <span style={{ fontSize: '20px' }}>{player.flag}</span>
                      <span style={{ color: COLORS.text, fontSize: '15px', fontWeight: '500' }}>{player.name}</span>
                      {player.isAI && <span style={{ background: `${COLORS.primary}40`, color: COLORS.primaryLight, padding: '2px 8px', borderRadius: '10px', fontSize: '10px', fontWeight: '600', letterSpacing: '1px' }}>AI</span>}
                    </div>
                    {currentPlayerIndex === index && <span style={{ color: COLORS.accent, fontSize: '11px', fontWeight: '600' }}>â–¶ THROWING</span>}
                  </div>
                  {player.isAI && <div style={{ fontSize: '10px', color: COLORS.primaryLight, marginBottom: '5px', textTransform: 'uppercase', fontWeight: '500' }}>{player.aiDifficulty}</div>}
                  <div style={{ fontSize: '48px', fontWeight: '700', color: player.score <= 170 ? COLORS.success : COLORS.text, textAlign: 'center', margin: '10px 0', fontFamily: "'Roboto Mono', monospace" }}>{player.score}</div>
                  {gameStats[index] && <div style={{ fontSize: '12px', color: COLORS.textMuted, textAlign: 'center' }}>Avg: {gameStats[index].averagePerDart} per dart</div>}
                  {(playerSetup.legsPerSet > 1 || playerSetup.setsToWin > 1) && (
                    <div style={{ fontSize: '11px', color: COLORS.accent, textAlign: 'center', marginTop: '8px', letterSpacing: '1px' }}>
                      Sets: {setScores[index] || 0} | Legs: {legScores[index] || 0}
                    </div>
                  )}
                </div>
              ))}
              
              {checkout && (
                <div style={{ background: `linear-gradient(135deg, ${COLORS.success}20, ${COLORS.success}10)`, borderRadius: '10px', padding: '15px', marginTop: '20px', border: `1px solid ${COLORS.success}40` }}>
                  <div style={{ color: COLORS.success, fontSize: '11px', letterSpacing: '2px', marginBottom: '5px', fontWeight: '600' }}>CHECKOUT</div>
                  <div style={{ color: COLORS.text, fontSize: '18px', fontWeight: '600' }}>{checkout}</div>
                </div>
              )}

              {onlineMode && (
                <div style={{ marginTop: '20px', padding: '15px', background: `linear-gradient(135deg, ${COLORS.primary}30, ${COLORS.primary}20)`, borderRadius: '10px', border: `2px solid ${COLORS.primaryLight}` }}>
                  <div style={{ color: COLORS.primaryLight, fontSize: '11px', fontWeight: '600', letterSpacing: '2px', marginBottom: '8px' }}>ğŸŒ ONLINE MATCH</div>
                  <div style={{ color: currentPlayerIndex === playerId ? COLORS.success : COLORS.accent, fontSize: '15px', fontWeight: '700', letterSpacing: '1px' }}>
                    {currentPlayerIndex === playerId ? 'â–¶ YOUR TURN' : 'â¸ OPPONENT\'S TURN'}
                  </div>
                </div>
              )}

              <div style={{ marginTop: '20px', padding: '15px', background: 'rgba(255, 255, 255, 0.03)', borderRadius: '10px', border: '1px solid rgba(255, 255, 255, 0.05)' }}>
                <div style={{ color: COLORS.textMuted, fontSize: '11px', marginBottom: '5px', letterSpacing: '1px' }}>TURN SCORE</div>
                <div style={{ color: COLORS.accent, fontSize: '32px', fontWeight: '700', fontFamily: "'Roboto Mono', monospace" }}>{currentTurnScore}</div>
                <div style={{ color: COLORS.textMuted, fontSize: '14px', marginTop: '5px' }}>Darts: {'ğŸ¯'.repeat(dartsThrown)}{'â—‹'.repeat(3 - dartsThrown)}</div>
              </div>

              <div style={{ marginTop: '20px', display: 'flex', gap: '10px' }}>
                <button onClick={() => setShowStats(true)} style={{ flex: 1, padding: '12px', background: 'rgba(255, 255, 255, 0.05)', color: COLORS.text, border: '1px solid rgba(255, 255, 255, 0.1)', borderRadius: '10px', cursor: 'pointer', fontFamily: "'Inter', sans-serif", fontSize: '13px', fontWeight: '500' }}>STATS</button>
                <button onClick={onlineMode ? leaveOnlineGame : resetGame} style={{ flex: 1, padding: '12px', background: `${COLORS.error}30`, color: COLORS.text, border: 'none', borderRadius: '10px', cursor: 'pointer', fontFamily: "'Inter', sans-serif", fontSize: '13px', fontWeight: '500' }}>{onlineMode ? 'LEAVE' : 'MENU'}</button>
              </div>
                </>
              )}
            </div>
            
            {/* Dartboard */}
            <div className="game-dartboard" style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
              <div ref={boardRef} onMouseMove={handleMouseMove} onMouseDown={handleMouseDown} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} onTouchMove={handleTouchMove} onTouchStart={handleTouchStart} onTouchEnd={handleTouchEnd} onTouchCancel={handleTouchCancel} style={{ width: `min(${BOARD_SIZE}px, 85vw)`, height: `min(${BOARD_SIZE}px, 85vw)`, borderRadius: '50%', cursor: isPowerCharging ? 'grabbing' : 'crosshair', boxShadow: '0 0 60px rgba(0, 0, 0, 0.8), inset 0 0 30px rgba(0, 0, 0, 0.5)', position: 'relative', userSelect: 'none' }}>
                <svg viewBox={`0 0 ${BOARD_SIZE} ${BOARD_SIZE}`} style={{ width: '100%', height: '100%', filter: 'drop-shadow(0 0 10px rgba(0,0,0,0.5))' }}>
                  <defs><radialGradient id="boardGradient" cx="50%" cy="50%" r="50%"><stop offset="0%" stopColor={COLORS.backgroundCard} /><stop offset="100%" stopColor={COLORS.background} /></radialGradient></defs>
                  <circle cx={CENTER} cy={CENTER} r={CENTER - 5} fill="url(#boardGradient)" stroke="none" strokeWidth="0" />
                  {renderDartboard()}
                  
                  {!isPowerCharging && !animatingDart && (
                    <g>
                      {/* Apply wobble offset for expert mode 180 challenge */}
                      <circle cx={aimPosition.x + aimWobble.x} cy={aimPosition.y + aimWobble.y} r="15" fill="none" stroke={`${COLORS.accent}80`} strokeWidth="2" strokeDasharray="5,5" />
                      <line x1={aimPosition.x + aimWobble.x - 20} y1={aimPosition.y + aimWobble.y} x2={aimPosition.x + aimWobble.x + 20} y2={aimPosition.y + aimWobble.y} stroke={`${COLORS.accent}80`} strokeWidth="1" />
                      <line x1={aimPosition.x + aimWobble.x} y1={aimPosition.y + aimWobble.y - 20} x2={aimPosition.x + aimWobble.x} y2={aimPosition.y + aimWobble.y + 20} stroke={`${COLORS.accent}80`} strokeWidth="1" />
                    </g>
                  )}
                  
                  {dartPositions.map((pos, i) => renderDart(pos, i))}
                  {animatingDart && <g style={{ animation: 'throwDart 0.3s ease-out forwards' }}>{renderDart(animatingDart.end, 'animating')}</g>}
                </svg>
                
                {showScorePopup && (
                  <div style={{
                    position: 'absolute',
                    left: showScorePopup.position.x,
                    top: showScorePopup.position.y - 40,
                    transform: 'translateX(-50%)',
                    background: showScorePopup.label === '180!!!' ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentLight})` : showScorePopup.label === 'BUST!' ? COLORS.error : showScorePopup.score === 50 ? COLORS.accent : COLORS.success,
                    color: (showScorePopup.score === 50 || showScorePopup.label === '180!!!') ? COLORS.background : COLORS.text,
                    padding: showScorePopup.label === '180!!!' ? '12px 24px' : '8px 16px',
                    borderRadius: '20px',
                    fontSize: showScorePopup.label === '180!!!' ? '32px' : '20px',
                    fontWeight: '700',
                    animation: 'popUp 0.5s ease-out',
                    pointerEvents: 'none',
                    zIndex: 10,
                    boxShadow: showScorePopup.label === '180!!!' ? `0 0 30px ${COLORS.accent}CC` : 'none'
                  }}>{showScorePopup.label}</div>
                )}
              </div>

              {/* Achievement Unlock Popup - Enhanced */}
              {achievementPopup && (
                <div style={{
                  position: 'fixed',
                  top: '50%',
                  left: '50%',
                  transform: 'translate(-50%, -50%)',
                  background: 'linear-gradient(135deg, rgba(0, 0, 0, 0.98), rgba(20, 20, 40, 0.98))',
                  border: `3px solid ${getRarityColor(achievementPopup.rarity)}`,
                  borderRadius: '20px',
                  padding: '32px',
                  minWidth: '340px',
                  maxWidth: '420px',
                  boxShadow: `0 20px 60px ${getRarityColor(achievementPopup.rarity)}60, 0 0 40px ${getRarityColor(achievementPopup.rarity)}30, inset 0 0 60px ${getRarityColor(achievementPopup.rarity)}10`,
                  animation: 'achievementUnlock 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275)',
                  zIndex: 1000,
                  textAlign: 'center'
                }}>
                  {/* Confetti for legendary/mythic */}
                  {(achievementPopup.rarity === 'legendary' || achievementPopup.rarity === 'mythic') && (
                    <>
                      {[...Array(12)].map((_, i) => (
                        <div key={i} style={{
                          position: 'absolute',
                          width: '8px',
                          height: '8px',
                          background: getRarityColor(achievementPopup.rarity),
                          borderRadius: '50%',
                          top: '50%',
                          left: '50%',
                          animation: `confetti${i % 4} 1s ease-out forwards`,
                          animationDelay: `${i * 0.05}s`
                        }} />
                      ))}
                    </>
                  )}

                  {/* Header */}
                  <div style={{
                    color: getRarityColor(achievementPopup.rarity),
                    fontSize: '0.75rem',
                    fontWeight: '700',
                    letterSpacing: '3px',
                    marginBottom: '16px',
                    textTransform: 'uppercase'
                  }}>
                    ğŸ† Achievement Unlocked
                  </div>

                  {/* Icon with glow */}
                  <div style={{
                    fontSize: '64px',
                    marginBottom: '16px',
                    filter: `drop-shadow(0 0 20px ${getRarityColor(achievementPopup.rarity)})`,
                    animation: 'iconBounce 0.5s ease-out 0.3s'
                  }}>
                    {achievementPopup.icon}
                  </div>

                  {/* Name */}
                  <div style={{
                    color: '#fff',
                    fontSize: '1.5rem',
                    fontWeight: '700',
                    marginBottom: '8px',
                    textShadow: `0 0 20px ${getRarityColor(achievementPopup.rarity)}80`
                  }}>
                    {achievementPopup.name}
                  </div>

                  {/* Description */}
                  <div style={{
                    color: COLORS.textMuted,
                    fontSize: '0.9rem',
                    marginBottom: '16px',
                    lineHeight: '1.4'
                  }}>
                    {achievementPopup.description}
                  </div>

                  {/* Rarity Badge */}
                  <div style={{
                    display: 'inline-block',
                    color: getRarityColor(achievementPopup.rarity),
                    fontSize: '0.7rem',
                    fontWeight: '700',
                    letterSpacing: '2px',
                    textTransform: 'uppercase',
                    background: `${getRarityColor(achievementPopup.rarity)}20`,
                    border: `1px solid ${getRarityColor(achievementPopup.rarity)}`,
                    borderRadius: '20px',
                    padding: '6px 16px'
                  }}>
                    {achievementPopup.rarity}
                  </div>

                  {/* Next Achievement Teaser */}
                  {(() => {
                    // Find next achievement in same category
                    const currentIndex = ACHIEVEMENTS_DATA.findIndex(a => a.id === achievementPopup.id);
                    const nextAchievement = ACHIEVEMENTS_DATA[currentIndex + 1];
                    if (nextAchievement && nextAchievement.statKey === achievementPopup.statKey) {
                      return (
                        <div style={{
                          marginTop: '20px',
                          padding: '12px',
                          background: 'rgba(255, 255, 255, 0.05)',
                          borderRadius: '10px',
                          fontSize: '0.8rem'
                        }}>
                          <div style={{ color: COLORS.textMuted, marginBottom: '4px' }}>Next Target:</div>
                          <div style={{ color: COLORS.text, fontWeight: '600' }}>
                            {nextAchievement.icon} {nextAchievement.name}
                          </div>
                        </div>
                      );
                    }
                    return null;
                  })()}
                </div>
              )}

              {/* Backdrop overlay for achievement popup */}
              {achievementPopup && (
                <div style={{
                  position: 'fixed',
                  inset: 0,
                  background: 'rgba(0, 0, 0, 0.7)',
                  zIndex: 999,
                  animation: 'fadeIn 0.3s ease-out'
                }} />
              )}
              
              <div style={{ width: `min(${BOARD_SIZE}px, 85vw)`, marginTop: '20px' }}>
                <div style={{ background: 'rgba(255, 255, 255, 0.05)', borderRadius: '10px', height: '30px', overflow: 'hidden', position: 'relative', border: '1px solid rgba(255, 255, 255, 0.08)' }}>
                  {(() => {
                    // Check if player is aiming at the winning double
                    const currentPlayer = players[currentPlayerIndex];
                    const aimingAt = currentPlayer ? calculateScore(aimPosition.x, aimPosition.y) : { multiplier: 0, score: 0 };
                    const isAimingAtWinningDouble = isCheckoutPosition && aimingAt.multiplier === 2 && aimingAt.score === currentPlayer?.score;

                    // Calculate perfect zone width
                    // Beginner mode (40% or below): constant 10% zone, no shrinking
                    // Intermediate (41-80%): shrinks by 2.5% for each perfect hit
                    // Expert (81%+): shrinks by 3% for each perfect hit
                    // Aiming at winning double: ultra-small 2% zone
                    let perfectZoneWidth;
                    if (skillLevel <= 40) {
                      // Beginner mode - constant 10% zone, no shrinking
                      perfectZoneWidth = 10;
                    } else {
                      // Normal mode - shrinking zones
                      if (isAimingAtWinningDouble) {
                        perfectZoneWidth = 2; // Ultra-small zone for winning double
                      } else {
                        const baseZoneWidth = 10;
                        const shrinkRate = (onlineMode || skillLevel >= 81) ? 3 : 2.5; // 3% for online/expert, 2.5% for intermediate
                        perfectZoneWidth = Math.max(baseZoneWidth - (triplesHit * shrinkRate), 4);
                      }
                    }

                    const perfectZoneLeft = 50 - (perfectZoneWidth / 2);
                    const perfectZoneRight = 50 + (perfectZoneWidth / 2);
                    const isInPerfectZone = power > perfectZoneLeft && power < perfectZoneRight;
                    return (
                      <>
                        <div style={{ height: '100%', width: `${power}%`, background: isInPerfectZone ? 'linear-gradient(90deg, #228b22, #32cd32)' : `linear-gradient(90deg, ${COLORS.error}, #e74c3c)`, transition: isPowerCharging ? 'none' : 'width 0.2s', borderRadius: '10px' }} />
                        <div style={{ position: 'absolute', left: '50%', top: 0, bottom: 0, width: '4px', marginLeft: '-2px', background: COLORS.accent, opacity: 0.5 }} />
                        <div style={{ position: 'absolute', left: `${perfectZoneLeft}%`, top: 0, bottom: 0, width: `${perfectZoneWidth}%`, background: 'rgba(50, 205, 50, 0.25)', borderRadius: '5px' }} />
                      </>
                    );
                  })()}
                </div>
                <div style={{ display: 'flex', justifyContent: 'space-between', color: COLORS.textMuted, fontSize: '11px', marginTop: '5px' }}>
                  <span>WEAK</span>
                  <span style={{ color: isCheckoutPosition ? COLORS.accent : COLORS.success, fontWeight: isCheckoutPosition ? '700' : 'normal' }}>
                    {(() => {
                      if (skillLevel <= 40) {
                        return isCheckoutPosition ? 'CHECKOUT!' : 'PERFECT';
                      }
                      const shrinkRate = (onlineMode || skillLevel >= 81) ? 3 : 2.5;
                      const totalShrink = triplesHit > 0 ? triplesHit * shrinkRate : 0;
                      return isCheckoutPosition
                        ? `CHECKOUT! ${totalShrink > 0 ? `(-${totalShrink}%)` : ''}`
                        : `PERFECT ${totalShrink > 0 ? `(-${totalShrink}%)` : ''}`;
                    })()}
                  </span>
                  <span>STRONG</span>
                </div>
              </div>

              <p style={{ color: COLORS.textMuted, marginTop: '15px', fontSize: '13px', textAlign: 'center' }}>{isPowerCharging ? 'Release to throw!' : 'Click and hold to charge, release to throw'}</p>
            </div>
            
            {/* History */}
            <div className="game-history" style={{ background: COLORS.backgroundCard, borderRadius: '16px', padding: '25px', minWidth: '200px', maxHeight: '500px', overflowY: 'auto', backdropFilter: 'blur(10px)', border: `1px solid ${COLORS.accent}30` }}>
              <h2 style={{ color: COLORS.accent, margin: '0 0 20px 0', letterSpacing: '2px', fontSize: '16px', fontWeight: '700' }}>HISTORY</h2>
              {throwHistory.slice(-15).reverse().map((throw_, index) => (
                <div key={index} style={{ display: 'flex', justifyContent: 'space-between', padding: '10px', background: 'rgba(255, 255, 255, 0.03)', borderRadius: '8px', marginBottom: '8px', fontSize: '13px', border: '1px solid rgba(255, 255, 255, 0.05)' }}>
                  <span style={{ color: COLORS.textMuted }}>{players[throw_.player]?.name}</span>
                  <span style={{ color: throw_.multiplier === 3 ? COLORS.accent : throw_.multiplier === 2 ? COLORS.success : COLORS.text, fontWeight: '600' }}>{throw_.label}</span>
                </div>
              ))}
              {throwHistory.length === 0 && <p style={{ color: COLORS.textMuted, textAlign: 'center', fontSize: '13px' }}>No throws yet</p>}
            </div>
          </div>

          {/* Nine-Darter Star Celebration */}
          {showNineDarter && (
            <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, zIndex: 200, pointerEvents: 'none', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
              {/* Background glow effect */}
              <div style={{
                position: 'absolute',
                top: '50%',
                left: '50%',
                transform: 'translate(-50%, -50%)',
                width: '400px',
                height: '400px',
                background: 'radial-gradient(circle, rgba(255,215,0,0.3) 0%, rgba(255,215,0,0) 70%)',
                animation: 'pulseGlow 2s ease-in-out infinite',
                borderRadius: '50%'
              }} />

              {/* Sparkle particles */}
              {[...Array(20)].map((_, i) => (
                <div key={i} style={{
                  position: 'absolute',
                  top: '50%',
                  left: '50%',
                  width: '6px',
                  height: '6px',
                  background: '#ffd700',
                  borderRadius: '50%',
                  boxShadow: '0 0 10px #ffd700',
                  animation: `sparkle${i % 4} 2s ease-out infinite`,
                  animationDelay: `${i * 0.1}s`,
                  opacity: 0
                }} />
              ))}

              {/* Star container with epic animation */}
              <div style={{
                position: 'relative',
                animation: 'epicStarEntry 6s cubic-bezier(0.34, 1.56, 0.64, 1)',
                transformOrigin: 'center center'
              }}>
                <svg width="250" height="250" viewBox="0 0 200 200" style={{
                  filter: 'drop-shadow(0 0 20px rgba(255,215,0,0.8)) drop-shadow(0 0 40px rgba(255,215,0,0.4))',
                  animation: 'starGlowSequence 6s cubic-bezier(0.34, 1.56, 0.64, 1)'
                }}>
                  <defs>
                    {/* Gold gradient for star */}
                    <radialGradient id="starGradient">
                      <stop offset="0%" stopColor="#ffed4a" />
                      <stop offset="50%" stopColor="#ffd700" />
                      <stop offset="100%" stopColor="#daa520" />
                    </radialGradient>

                    {/* Inner glow gradient */}
                    <radialGradient id="starInnerGlow">
                      <stop offset="0%" stopColor="#fff" stopOpacity="0.8" />
                      <stop offset="50%" stopColor="#ffd700" stopOpacity="0.4" />
                      <stop offset="100%" stopColor="#ffd700" stopOpacity="0" />
                    </radialGradient>
                  </defs>

                  {/* Outer glow circles (pulsing) */}
                  <circle cx="100" cy="100" r="70" fill="url(#starInnerGlow)" opacity="0.6" style={{ animation: 'starPulse 2s ease-in-out infinite' }} />
                  <circle cx="100" cy="100" r="50" fill="url(#starInnerGlow)" opacity="0.4" style={{ animation: 'starPulse 2s ease-in-out infinite 0.3s' }} />

                  {/* Main 5-pointed star */}
                  <path
                    d="M 100 20 L 115 70 L 170 75 L 125 110 L 140 165 L 100 135 L 60 165 L 75 110 L 30 75 L 85 70 Z"
                    fill="url(#starGradient)"
                    stroke="#daa520"
                    strokeWidth="3"
                    style={{ animation: 'starRotate 4s linear infinite 2s' }}
                  />

                  {/* Inner star for depth */}
                  <path
                    d="M 100 40 L 110 80 L 150 85 L 118 108 L 127 148 L 100 125 L 73 148 L 82 108 L 50 85 L 90 80 Z"
                    fill="#ffed4a"
                    opacity="0.7"
                    style={{ animation: 'starRotate 4s linear infinite 2s' }}
                  />

                  {/* Center brilliant point */}
                  <circle cx="100" cy="100" r="15" fill="#fff" opacity="0.9" style={{ animation: 'starTwinkle 1.5s ease-in-out infinite' }} />
                  <circle cx="100" cy="100" r="8" fill="#ffed4a" style={{ animation: 'starTwinkle 1.5s ease-in-out infinite 0.2s' }} />
                </svg>

                {/* Epic text */}
                <div style={{
                  position: 'absolute',
                  top: '-80px',
                  left: '50%',
                  transform: 'translateX(-50%)',
                  fontSize: '64px',
                  fontWeight: '900',
                  color: '#ffd700',
                  textShadow: '0 0 30px rgba(255,215,0,1), 0 0 60px rgba(255,215,0,0.8), 0 4px 10px rgba(0,0,0,0.5)',
                  whiteSpace: 'nowrap',
                  fontFamily: "'Oswald', sans-serif",
                  letterSpacing: '4px',
                  animation: 'textPulse 2s ease-in-out infinite 3s',
                  opacity: 0,
                  animationFillMode: 'forwards'
                }}>
                  NINE DARTER!!!
                </div>

                {/* Subtitle */}
                <div style={{
                  position: 'absolute',
                  bottom: '-60px',
                  left: '50%',
                  transform: 'translateX(-50%)',
                  fontSize: '24px',
                  fontWeight: '600',
                  color: '#ffed4a',
                  textShadow: '0 0 20px rgba(255,215,0,0.8)',
                  whiteSpace: 'nowrap',
                  fontFamily: "'Oswald', sans-serif",
                  letterSpacing: '2px',
                  animation: 'textPulse 2s ease-in-out infinite 3.5s',
                  opacity: 0,
                  animationFillMode: 'forwards'
                }}>
                  LEGENDARY!
                </div>
              </div>
            </div>
          )}

          {/* Stats Modal */}
          {showStats && (
            <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0, 0, 0, 0.8)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 100 }} onClick={() => setShowStats(false)}>
              <div style={{ background: COLORS.backgroundCard, borderRadius: '16px', padding: '30px', maxWidth: '600px', width: '90%', border: `1px solid ${COLORS.accent}30` }} onClick={e => e.stopPropagation()}>
                <h2 style={{ color: COLORS.accent, margin: '0 0 25px 0', letterSpacing: '2px', fontSize: '18px', fontWeight: '700' }}>GAME STATISTICS</h2>
                {players.map((player, index) => (
                  <div key={index} style={{ background: 'rgba(255, 255, 255, 0.03)', borderRadius: '12px', padding: '20px', marginBottom: '15px', border: '1px solid rgba(255, 255, 255, 0.05)' }}>
                    <h3 style={{ color: COLORS.text, margin: '0 0 15px 0', fontSize: '16px', fontWeight: '600' }}>{player.name}</h3>
                    {gameStats[index] ? (
                      <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '15px' }}>
                        <div style={{ textAlign: 'center' }}><div style={{ color: COLORS.accent, fontSize: '24px', fontWeight: '700' }}>{gameStats[index].throws}</div><div style={{ color: COLORS.textMuted, fontSize: '12px' }}>Throws</div></div>
                        <div style={{ textAlign: 'center' }}><div style={{ color: COLORS.accent, fontSize: '24px', fontWeight: '700' }}>{gameStats[index].averagePerDart}</div><div style={{ color: COLORS.textMuted, fontSize: '12px' }}>Avg/Dart</div></div>
                        <div style={{ textAlign: 'center' }}><div style={{ color: COLORS.accent, fontSize: '24px', fontWeight: '700' }}>{gameStats[index].highestThrow}</div><div style={{ color: COLORS.textMuted, fontSize: '12px' }}>Best</div></div>
                        <div style={{ textAlign: 'center' }}><div style={{ color: COLORS.success, fontSize: '24px', fontWeight: '700' }}>{gameStats[index].triples}</div><div style={{ color: COLORS.textMuted, fontSize: '12px' }}>Triples</div></div>
                        <div style={{ textAlign: 'center' }}><div style={{ color: COLORS.primaryLight, fontSize: '24px', fontWeight: '700' }}>{gameStats[index].doubles}</div><div style={{ color: COLORS.textMuted, fontSize: '12px' }}>Doubles</div></div>
                        <div style={{ textAlign: 'center' }}><div style={{ color: COLORS.error, fontSize: '24px', fontWeight: '700' }}>{gameStats[index].bullseyes}</div><div style={{ color: COLORS.textMuted, fontSize: '12px' }}>Bullseyes</div></div>
                      </div>
                    ) : <p style={{ color: COLORS.textMuted, margin: 0 }}>No stats yet</p>}
                  </div>
                ))}
                <button onClick={() => setShowStats(false)} style={{ width: '100%', padding: '15px', background: `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentLight})`, color: COLORS.background, border: 'none', borderRadius: '10px', fontSize: '14px', fontWeight: '600', cursor: 'pointer', fontFamily: "'Inter', sans-serif" }}>CLOSE</button>
              </div>
            </div>
          )}

          {/* Winner Modal */}
          {winner && (
            <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0, 0, 0, 0.9)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 100 }}>
              <div style={{ textAlign: 'center', animation: 'fadeIn 0.5s ease-out' }}>
                <div style={{ fontSize: '100px', marginBottom: '20px' }}>{matchWinner ? 'ğŸ†' : 'âœ“'}</div>
                <h1 style={{ fontSize: '42px', color: COLORS.accent, margin: '0 0 10px 0', textShadow: `0 0 30px ${COLORS.accent}80`, fontWeight: '700' }}>{winner.name} {matchWinner ? 'WINS THE MATCH!' : 'WINS THE LEG!'}</h1>
                <p style={{ color: COLORS.textMuted, fontSize: '18px', marginBottom: '30px' }}>{matchWinner ? 'Match Complete - Champion Crowned!' : 'Next leg starting soon...'}</p>
                {matchWinner && (
                  <div style={{ display: 'flex', gap: '15px', justifyContent: 'center' }}>
                    <button onClick={startGame} style={{ padding: '15px 40px', background: `linear-gradient(135deg, ${COLORS.primary}, ${COLORS.primaryLight})`, color: COLORS.text, border: 'none', borderRadius: '10px', fontSize: '16px', fontWeight: '600', cursor: 'pointer', fontFamily: "'Inter', sans-serif" }}>PLAY AGAIN</button>
                    <button onClick={resetGame} style={{ padding: '15px 40px', background: 'rgba(255, 255, 255, 0.05)', color: COLORS.text, border: '1px solid rgba(255, 255, 255, 0.1)', borderRadius: '10px', fontSize: '16px', fontWeight: '600', cursor: 'pointer', fontFamily: "'Inter', sans-serif" }}>MAIN MENU</button>
                  </div>
                )}
              </div>
            </div>
          )}
          
          <style>{`
            @keyframes popUp { 0% { transform: translateX(-50%) scale(0.5); opacity: 0; } 50% { transform: translateX(-50%) scale(1.2); } 100% { transform: translateX(-50%) scale(1); opacity: 1; } }
            @keyframes fadeIn { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
            @keyframes throwDart { from { opacity: 0; transform: translateY(50px); } to { opacity: 1; transform: translateY(0); } }
            @keyframes slideInRight { 0% { transform: translateX(400px); opacity: 0; } 100% { transform: translateX(0); opacity: 1; } }

            /* Epic Nine-Darter Star Animations */
            @keyframes epicStarEntry {
              0% { transform: scale(0.3) translateY(100px); opacity: 0; }
              15% { transform: scale(1.3) translateY(-80px) rotate(0deg); opacity: 1; }
              30% { transform: scale(1.2) translateY(-60px) rotate(360deg); }
              45% { transform: scale(1.25) translateY(-40px) rotate(360deg); }
              60% { transform: scale(1.1) translateY(0px) rotate(720deg); }
              75% { transform: scale(1.15) translateY(-10px) rotate(720deg); }
              85% { transform: scale(1.05) translateY(5px) rotate(720deg); }
              100% { transform: scale(1.1) translateY(0px) rotate(720deg); }
            }

            @keyframes starGlowSequence {
              0% { filter: drop-shadow(0 0 10px rgba(255,215,0,0.3)); }
              50% { filter: drop-shadow(0 0 50px rgba(255,215,0,1)) drop-shadow(0 0 100px rgba(255,215,0,0.8)); }
              100% { filter: drop-shadow(0 0 40px rgba(255,215,0,0.9)) drop-shadow(0 0 80px rgba(255,215,0,0.6)); }
            }

            @keyframes starRotate {
              0% { transform: rotate(0deg); }
              100% { transform: rotate(360deg); }
            }

            @keyframes starPulse {
              0%, 100% { transform: scale(1); opacity: 0.6; }
              50% { transform: scale(1.2); opacity: 0.3; }
            }

            @keyframes starTwinkle {
              0%, 100% { opacity: 0.9; transform: scale(1); }
              50% { opacity: 0.4; transform: scale(0.7); }
            }

            @keyframes pulseGlow {
              0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.4; }
              50% { transform: translate(-50%, -50%) scale(1.3); opacity: 0.7; }
            }

            @keyframes textPulse {
              0% { opacity: 0; transform: translateX(-50%) scale(0.5); }
              10% { opacity: 1; transform: translateX(-50%) scale(1.2); }
              20% { opacity: 1; transform: translateX(-50%) scale(1); }
              30%, 100% { opacity: 1; transform: translateX(-50%) scale(1); }
            }

            @keyframes sparkle0 {
              0% { transform: translate(0, 0) scale(0); opacity: 0; }
              10% { opacity: 1; }
              100% { transform: translate(120px, -150px) scale(1); opacity: 0; }
            }

            @keyframes sparkle1 {
              0% { transform: translate(0, 0) scale(0); opacity: 0; }
              10% { opacity: 1; }
              100% { transform: translate(-130px, -140px) scale(1); opacity: 0; }
            }

            @keyframes sparkle2 {
              0% { transform: translate(0, 0) scale(0); opacity: 0; }
              10% { opacity: 1; }
              100% { transform: translate(140px, 120px) scale(1); opacity: 0; }
            }

            @keyframes sparkle3 {
              0% { transform: translate(0, 0) scale(0); opacity: 0; }
              10% { opacity: 1; }
              100% { transform: translate(-110px, 130px) scale(1); opacity: 0; }
            }
          `}</style>
        </div>
      );
    };

    ReactDOM.render(<DartsGame />, document.getElementById('root'));
  </script>
</body>
</html>
