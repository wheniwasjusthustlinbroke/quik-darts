<!DOCTYPE html>
<!-- Quik Darts v1.1 - January 2026 -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <!-- Security Headers (X-Frame-Options and frame-ancestors require HTTP headers, not meta tags) -->
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  <meta name="referrer" content="strict-origin-when-cross-origin">
  <!-- CSP: Allow scripts from trusted CDNs only -->
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdnjs.cloudflare.com https://www.gstatic.com https://apis.google.com https://unpkg.com https://*.firebasedatabase.app; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; connect-src 'self' https://*.firebaseio.com https://*.firebasedatabase.app wss://*.firebaseio.com wss://*.firebasedatabase.app https://identitytoolkit.googleapis.com https://securetoken.googleapis.com https://unpkg.com https://www.gstatic.com https://*.cloudfunctions.net; frame-src https://*.firebaseapp.com https://*.firebasedatabase.app; img-src 'self' data: https: blob:;">

  <meta name="description" content="Quik Darts - Championship-style online darts. Play solo, challenge friends, or compete online. No download required.">
  <title>Quik Darts - Championship Edition</title>

  <!-- Favicons - Google requires 48x48 minimum -->
  <link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="48x48" href="/favicon-48x48.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="manifest" href="/site.webmanifest">
  <meta name="theme-color" content="#0D1117">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Roboto+Mono:wght@400;500&display=swap" rel="stylesheet">

  <!-- External Scripts with Subresource Integrity (SRI) for supply chain protection -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js" integrity="sha512-8Q6Y9XnTbOE+JNvjBQwJ2H8S+UV4uA6hiRykhdtIyDYZ2TprdNmWOUaKdGzOhyr4dCyk287OejbPvwl7lrfqrQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js" integrity="sha512-MOCpqoRoisCTwJ8vQQiciZv0qcpROCidek3GTFS6KTk2+y7munJIlKCVkFCYY+p3ErYFXCjmFjnfTTRSC1OHWQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://unpkg.com/@babel/standalone@7.26.5/babel.min.js" integrity="sha384-SF03qAKhbEVbqj7hDewV6mk3wJJyzxf3nBCxNuF46+Sof8f1fx4Pes2gOVItRZn9" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <!-- Firebase SDKs with SRI -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js" integrity="sha384-yuGdyIzzYtOBlBG6JOWn+Ey9kpq7HocusNuxEGyyohr1eEyXpeEyehIIXC/hznw4" crossorigin="anonymous"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js" integrity="sha384-lI+CxEx/bCvWP1b0OK13j5HTrTZP7yf1xle8TVOFq2smz6KC1RChTarRV/RHP5PP" crossorigin="anonymous"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js" integrity="sha384-M6AmjBRXEjkdGzRN1Y94xtkmblFbYBSLkqzyZ8rPvpRM2c48nhjIRFXVvUM/VATL" crossorigin="anonymous"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-functions-compat.js" crossorigin="anonymous"></script>
  <style>
    /* CSS Custom Properties - Design System */
    :root {
      --color-primary: #1B4332;
      --color-primary-light: #2D6A4F;
      --color-primary-dark: #143728;
      --color-accent: #D4A03A;
      --color-accent-light: #E8B94A;
      --color-accent-dark: #B8862E;
      --color-background: #0D1117;
      --color-background-light: #161B22;
      --color-background-card: #1C2128;
      --color-text: #F5F5F5;
      --color-text-muted: #8B949E;
      --color-text-dark: #0D1117;
      --color-success: #2D8A2D;
      --color-error: #C92A2A;
      --font-primary: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      --font-mono: 'Roboto Mono', monospace;
      --radius-sm: 6px;
      --radius-md: 10px;
      --radius-lg: 16px;
      --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);
      --shadow-md: 0 8px 24px rgba(0, 0, 0, 0.4);
      --shadow-lg: 0 16px 48px rgba(0, 0, 0, 0.5);
      --transition-fast: 0.15s ease;
      --transition-normal: 0.3s ease;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    html { scroll-behavior: smooth; }

    body {
      font-family: var(--font-primary);
      background: var(--color-background);
      color: var(--color-text);
      -webkit-tap-highlight-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      touch-action: manipulation;
      line-height: 1.5;
    }

    /* Typography */
    h1, h2, h3, h4 { font-weight: 700; line-height: 1.2; }
    h1 { font-size: clamp(2rem, 5vw, 3.5rem); }
    h2 { font-size: clamp(1.5rem, 4vw, 2.5rem); }
    h3 { font-size: clamp(1.25rem, 3vw, 1.75rem); }

    /* Navigation */
    .nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      background: rgba(13, 17, 23, 0.95);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      transition: var(--transition-normal);
    }
    .nav-container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 24px;
      height: 64px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .nav-logo {
      font-size: 1.25rem;
      font-weight: 800;
      color: var(--color-accent);
      text-decoration: none;
      letter-spacing: 1px;
    }
    .nav-links {
      display: flex;
      align-items: center;
      gap: 32px;
      list-style: none;
    }
    .nav-link {
      color: var(--color-text-muted);
      text-decoration: none;
      font-size: 0.9rem;
      font-weight: 500;
      transition: var(--transition-fast);
      cursor: pointer;
    }
    .nav-link:hover { color: var(--color-text); }
    .nav-cta {
      background: var(--color-accent);
      color: var(--color-text-dark);
      padding: 10px 20px;
      border-radius: var(--radius-sm);
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
      border: none;
      transition: var(--transition-fast);
    }
    .nav-cta:hover {
      background: var(--color-accent-light);
      transform: translateY(-1px);
    }
    .nav-hamburger {
      display: none;
      flex-direction: column;
      gap: 5px;
      cursor: pointer;
      padding: 8px;
      background: none;
      border: none;
    }
    .nav-hamburger span {
      width: 24px;
      height: 2px;
      background: var(--color-text);
      transition: var(--transition-fast);
    }
    .nav-mobile {
      display: none;
      position: fixed;
      top: 64px;
      left: 0;
      right: 0;
      background: var(--color-background);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      padding: 16px 24px;
    }
    .nav-mobile.open { display: block; }
    .nav-mobile-links {
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    @media (max-width: 768px) {
      .nav-links { display: none; }
      .nav-hamburger { display: flex; }
      .game-layout { flex-direction: column !important; }
      .game-dartboard { order: 1 !important; }
      .game-history { order: 2 !important; max-height: 180px !important; }
      .game-scoreboard { order: 3 !important; }
    }

    /* Buttons */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 14px 28px;
      font-family: var(--font-primary);
      font-size: 1rem;
      font-weight: 600;
      border: none;
      border-radius: var(--radius-sm);
      cursor: pointer;
      transition: all var(--transition-normal);
      text-decoration: none;
      min-height: 48px;
    }
    .btn-primary {
      background: linear-gradient(135deg, var(--color-accent) 0%, var(--color-accent-dark) 100%);
      color: var(--color-text-dark);
      box-shadow: 0 4px 16px rgba(212, 160, 58, 0.3);
    }
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(212, 160, 58, 0.4);
    }
    .btn-secondary {
      background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
      color: var(--color-text);
      box-shadow: 0 4px 16px rgba(27, 67, 50, 0.3);
    }
    .btn-secondary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(27, 67, 50, 0.4);
    }
    .btn-ghost {
      background: transparent;
      color: var(--color-text);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .btn-ghost:hover {
      background: rgba(255, 255, 255, 0.05);
      border-color: rgba(255, 255, 255, 0.3);
    }
    .btn:active { transform: translateY(0) scale(0.98); }

    /* Footer */
    .footer {
      background: var(--color-background);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      padding: 48px 24px 24px;
    }
    .footer-container {
      max-width: 1200px;
      margin: 0 auto;
    }
    .footer-content {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      flex-wrap: wrap;
      gap: 32px;
      margin-bottom: 32px;
    }
    .footer-brand h3 {
      color: var(--color-accent);
      margin-bottom: 8px;
    }
    .footer-brand p {
      color: var(--color-text-muted);
      font-size: 0.9rem;
    }
    .footer-links {
      display: flex;
      gap: 48px;
      flex-wrap: wrap;
    }
    .footer-links-group h4 {
      color: var(--color-text);
      font-size: 0.9rem;
      margin-bottom: 12px;
    }
    .footer-links-group ul {
      list-style: none;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .footer-links-group a {
      color: var(--color-text-muted);
      text-decoration: none;
      font-size: 0.85rem;
      transition: var(--transition-fast);
      cursor: pointer;
    }
    .footer-links-group a:hover { color: var(--color-text); }
    .footer-bottom {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-top: 24px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      flex-wrap: wrap;
      gap: 16px;
    }
    .footer-bottom p {
      color: var(--color-text-muted);
      font-size: 0.8rem;
    }
    .footer-social {
      display: flex;
      gap: 16px;
    }
    .footer-social a {
      color: var(--color-text-muted);
      transition: var(--transition-fast);
    }
    .footer-social a:hover { color: var(--color-accent); }

    /* Animations */
    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    @keyframes almostTherePulse {
      0%, 100% { box-shadow: 0 0 0 0 rgba(212, 160, 58, 0); }
      50% { box-shadow: 0 0 20px 2px rgba(212, 160, 58, 0.3); }
    }
    @keyframes achievementUnlock {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
      100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }
    @keyframes iconBounce {
      0% { transform: scale(1); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @keyframes confetti0 {
      0% { transform: translate(0, 0) scale(0); opacity: 1; }
      100% { transform: translate(-80px, -100px) scale(1); opacity: 0; }
    }
    @keyframes confetti1 {
      0% { transform: translate(0, 0) scale(0); opacity: 1; }
      100% { transform: translate(80px, -90px) scale(1); opacity: 0; }
    }
    @keyframes confetti2 {
      0% { transform: translate(0, 0) scale(0); opacity: 1; }
      100% { transform: translate(-70px, 80px) scale(1); opacity: 0; }
    }
    @keyframes confetti3 {
      0% { transform: translate(0, 0) scale(0); opacity: 1; }
      100% { transform: translate(90px, 70px) scale(1); opacity: 0; }
    }
    @keyframes rareShimmer {
      0%, 100% { box-shadow: 0 0 15px rgba(52, 152, 219, 0.3); }
      50% { box-shadow: 0 0 25px rgba(52, 152, 219, 0.5); }
    }
    @keyframes epicGlow {
      0%, 100% { box-shadow: 0 0 20px rgba(155, 89, 182, 0.4), inset 0 0 30px rgba(155, 89, 182, 0.1); }
      50% { box-shadow: 0 0 35px rgba(155, 89, 182, 0.6), inset 0 0 40px rgba(155, 89, 182, 0.15); }
    }
    @keyframes legendaryPulse {
      0%, 100% { box-shadow: 0 0 25px rgba(243, 156, 18, 0.5), 0 0 50px rgba(243, 156, 18, 0.2); }
      50% { box-shadow: 0 0 40px rgba(243, 156, 18, 0.7), 0 0 70px rgba(243, 156, 18, 0.3); }
    }
    @keyframes mythicGlow {
      0%, 100% {
        box-shadow: 0 0 30px rgba(231, 76, 60, 0.6), 0 0 60px rgba(231, 76, 60, 0.3), inset 0 0 40px rgba(231, 76, 60, 0.1);
        border-color: rgba(231, 76, 60, 0.8);
      }
      50% {
        box-shadow: 0 0 50px rgba(231, 76, 60, 0.8), 0 0 80px rgba(231, 76, 60, 0.4), inset 0 0 50px rgba(231, 76, 60, 0.15);
        border-color: rgba(231, 76, 60, 1);
      }
    }
    /* Wagered Match Header Animations */
    @keyframes potPulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.06); }
      100% { transform: scale(1); }
    }
    @keyframes potGlow {
      0% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
      50% { box-shadow: 0 0 30px rgba(255, 215, 0, 1); }
      100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.7); }
    }
    @keyframes wagerFadeInUp {
      0% { opacity: 0; transform: translateY(10px); }
      100% { opacity: 1; transform: translateY(0); }
    }
    @keyframes skeletonPulse {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 0.8; }
    }
    .animate-fade-in { animation: fadeInUp 0.6s ease forwards; }
    .animate-delay-2 { animation-delay: 0.2s; opacity: 0; }

    /* Utility */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      border: 0;
    }

    /* ===== MATCHMAKING OVERLAY ===== */

    /* Backdrop */
    .qd-mmBackdrop {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: radial-gradient(60% 60% at 50% 45%, rgba(0,0,0,0.25), rgba(0,0,0,0.55));
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      z-index: 9999;
      pointer-events: auto; /* Prevent clicks passing through to background */
    }

    /* Matchmaking Card */
    .qd-mmCard {
      width: min(420px, calc(100vw - 32px));
      padding: 28px 26px 22px;
      border-radius: 18px;
      background: rgba(22, 26, 30, 0.92);
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow: 0 28px 70px rgba(0,0,0,0.55);
      text-align: center;
    }

    .qd-mmIcon {
      font-size: 30px;
      opacity: 0.95;
      margin-bottom: 10px;
    }

    .qd-mmTitle {
      font-weight: 900;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(226, 186, 92, 0.95);
      font-size: 20px;
    }

    .qd-mmTitle.green {
      color: rgba(80, 200, 120, 0.95);
    }

    .qd-mmSub {
      margin-top: 10px;
      font-size: 13px;
      color: rgba(255,255,255,0.55);
    }

    .qd-mmHint {
      margin-top: 12px;
      font-size: 12px;
      color: rgba(255,255,255,0.6);
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.06);
    }

    .qd-mmDots {
      margin: 14px auto 18px;
      display: flex;
      gap: 8px;
      justify-content: center;
    }

    .qd-mmDots span {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: rgba(80, 200, 120, 0.5);
      animation: qdDot 1.1s infinite ease-in-out;
    }

    .qd-mmDots span:nth-child(2) { animation-delay: 0.15s; opacity: 0.7; }
    .qd-mmDots span:nth-child(3) { animation-delay: 0.3s; opacity: 0.9; }

    @keyframes qdDot {
      0%, 80%, 100% { transform: translateY(0); opacity: 0.35; }
      40% { transform: translateY(-6px); opacity: 0.95; }
    }

    .qd-mmBtn {
      pointer-events: auto;
      padding: 10px 16px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.06);
      color: rgba(255,255,255,0.8);
      font-weight: 700;
      cursor: pointer;
      transition: background 0.2s;
    }

    .qd-mmBtn:hover {
      background: rgba(255,255,255,0.09);
    }

    /* Opponent block */
    .qd-mmOpponent {
      margin: 18px auto 6px;
      padding: 14px 14px;
      border-radius: 16px;
      width: min(320px, 100%);
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.06);
      display: grid;
      justify-items: center;
      gap: 10px;
    }

    .qd-mmAvatar {
      width: 44px;
      height: 44px;
      border-radius: 14px;
      overflow: hidden;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.08);
    }

    .qd-mmAvatar img { width: 100%; height: 100%; object-fit: cover; }

    .qd-mmAvatarFallback {
      width: 100%;
      height: 100%;
      display: grid;
      place-items: center;
      font-weight: 900;
      color: rgba(255,255,255,0.8);
    }

    .qd-mmName {
      font-weight: 800;
      color: rgba(226, 186, 92, 0.95);
    }

    /* VS Intro Screen */
    .qd-vsWrap {
      width: min(920px, calc(100vw - 32px));
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      gap: 32px;
      padding: 28px 30px;
      border-radius: 22px;
      background: rgba(14, 18, 22, 0.78);
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow: 0 28px 90px rgba(0,0,0,0.62);
      animation: qdIntroIn 420ms ease-out;
    }

    @keyframes qdIntroIn {
      from { opacity: 0; transform: translateY(8px) scale(0.99); }
      to   { opacity: 1; transform: translateY(0) scale(1); }
    }

    .qd-vsPlayer {
      display: grid;
      justify-items: center;
      gap: 8px;
      opacity: 0.96;
    }

    .qd-vsPlayer.left { animation: qdSlideLeft 520ms ease-out; }
    .qd-vsPlayer.right { animation: qdSlideRight 520ms ease-out; }

    @keyframes qdSlideLeft { from { transform: translateX(-10px); opacity: 0; } to { transform: translateX(0); opacity: 0.96; } }
    @keyframes qdSlideRight { from { transform: translateX(10px); opacity: 0; } to { transform: translateX(0); opacity: 0.96; } }

    .qd-vsAvatar {
      width: 74px;
      height: 74px;
      border-radius: 22px;
      overflow: hidden;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      box-shadow: 0 18px 40px rgba(0,0,0,0.45);
    }

    .qd-vsAvatar img { width: 100%; height: 100%; object-fit: cover; }

    .qd-vsAvatarFallback {
      width: 100%;
      height: 100%;
      display: grid;
      place-items: center;
      font-weight: 900;
      font-size: 28px;
      color: rgba(255,255,255,0.82);
    }

    .qd-vsName {
      font-weight: 900;
      color: rgba(255,255,255,0.92);
    }

    .qd-vsLvl {
      font-size: 12px;
      letter-spacing: 0.06em;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.08);
      color: rgba(255,255,255,0.75);
    }

    .qd-vsCenter {
      display: grid;
      justify-items: center;
      gap: 14px;
      padding: 10px 0;
    }

    .qd-vsText {
      font-size: 40px;
      font-weight: 900;
      letter-spacing: 0.08em;
      color: rgba(226, 186, 92, 0.95);
      text-shadow: 0 10px 22px rgba(0,0,0,0.55);
    }

    .qd-vsPot {
      display: grid;
      justify-items: center;
      gap: 6px;
    }

    .qd-vsChip {
      animation: qdChipPop 520ms cubic-bezier(.2,.9,.2,1.15);
      mix-blend-mode: lighten;
      filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.5));
    }

    @keyframes qdChipPop {
      0% { transform: scale(0.92); opacity: 0; }
      60% { transform: scale(1.04); opacity: 1; }
      100% { transform: scale(1); }
    }

    .qd-vsPotLabel {
      font-size: 11px;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.55);
    }

    .qd-vsPotAmount {
      font-size: 22px;
      font-weight: 900;
      color: rgba(255,255,255,0.92);
    }

    /* Accessibility - Reduced Motion */
    @media (prefers-reduced-motion: reduce) {
      .qd-mmDots span,
      .qd-vsPlayer,
      .qd-vsChip,
      .qd-vsWrap {
        animation: none;
      }
    }

    /* Mobile Responsive */
    @media (max-width: 640px) {
      .qd-vsWrap {
        grid-template-columns: 1fr;
        gap: 20px;
        padding: 20px;
      }

      .qd-vsPlayer.left,
      .qd-vsPlayer.right {
        animation: none;
      }

      .qd-vsCenter {
        order: -1;
      }

      .qd-vsText {
        font-size: 32px;
      }

      .qd-vsAvatar {
        width: 60px;
        height: 60px;
      }

      .qd-vsAvatarFallback {
        font-size: 22px;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useRef, useEffect, useCallback, useMemo } = React;

    // Firebase Configuration
    const firebaseConfig = {
      apiKey: "AIzaSyAapEmqdhRMQgRyrXIzhhMGSvNbpfQlaoM",
      authDomain: "quikdarts.firebaseapp.com",
      databaseURL: "https://quikdarts-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "quikdarts",
      storageBucket: "quikdarts.firebasestorage.app",
      messagingSenderId: "287454496132",
      appId: "1:287454496132:web:dd17354a71f9eb907f89d1",
      measurementId: "G-TE4B2W2CEJ"
    };

    // Initialize Firebase
    let database = null;
    let auth = null;
    let functions = null;
    let currentAuthUser = null;

    // Promise that resolves when auth is ready
    let authReadyResolve;
    const authReadyPromise = new Promise(resolve => { authReadyResolve = resolve; });

    try {
      if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
      }
      database = firebase.database();
      auth = firebase.auth();
      // Initialize Firebase Functions with europe-west1 region (matches deployed functions)
      functions = firebase.app().functions('europe-west1');

      // Listen for auth state changes
      auth.onAuthStateChanged((user) => {
        if (user) {
          currentAuthUser = user;
          authReadyResolve(user);
        } else {
          // Sign in anonymously if not authenticated
          auth.signInAnonymously().catch((error) => {
            console.warn('Anonymous auth failed:', error);
            authReadyResolve(null);
          });
        }
      });
    } catch (error) {
      console.warn('Firebase not configured. Online multiplayer disabled.', error);
      authReadyResolve(null);
    }

    // Menu Icon Components (defined outside component to prevent recreation on each render)
    const DartIcon = ({ size = 20, color = 'currentColor' }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" aria-hidden="true" style={{ marginRight: '12px', flexShrink: 0 }}>
        <path d="M22 2L13 11M22 2L18 22L13 11M22 2L2 7L13 11" stroke={color} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
      </svg>
    );

    const GlobeIcon = ({ size = 20, color = 'currentColor' }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" aria-hidden="true" style={{ marginRight: '12px', flexShrink: 0 }}>
        <circle cx="12" cy="12" r="10" stroke={color} strokeWidth="2"/>
        <path d="M2 12H22M12 2C14.5 4.5 16 8 16 12C16 16 14.5 19.5 12 22C9.5 19.5 8 16 8 12C8 8 9.5 4.5 12 2Z" stroke={color} strokeWidth="2"/>
      </svg>
    );

    const TargetIcon = ({ size = 20, color = 'currentColor' }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" aria-hidden="true" style={{ marginRight: '12px', flexShrink: 0 }}>
        <circle cx="12" cy="12" r="10" stroke={color} strokeWidth="2"/>
        <circle cx="12" cy="12" r="6" stroke={color} strokeWidth="2"/>
        <circle cx="12" cy="12" r="2" fill={color}/>
      </svg>
    );

    const TrophyIcon = ({ size = 20, color = 'currentColor' }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" aria-hidden="true" style={{ marginRight: '12px', flexShrink: 0 }}>
        <path d="M8 21H16M12 17V21M6 4H18V8C18 11.3137 15.3137 14 12 14C8.68629 14 6 11.3137 6 8V4Z" stroke={color} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
        <path d="M6 4H4V6C4 7.10457 4.89543 8 6 8V4ZM18 4V8C19.1046 8 20 7.10457 20 6V4H18Z" stroke={color} strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
      </svg>
    );

    // Additional icons for navigation and UI
    const MenuIcon = ({ size = 24 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" aria-hidden="true">
        <path d="M3 12H21M3 6H21M3 18H21" stroke="currentColor" strokeWidth="2" strokeLinecap="round"/>
      </svg>
    );

    const CloseIcon = ({ size = 24 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" aria-hidden="true">
        <path d="M18 6L6 18M6 6L18 18" stroke="currentColor" strokeWidth="2" strokeLinecap="round"/>
      </svg>
    );

    const PlayIcon = ({ size = 20 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
        <path d="M8 5v14l11-7z"/>
      </svg>
    );

    const UsersIcon = ({ size = 20 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none" aria-hidden="true" style={{ marginRight: '8px', flexShrink: 0 }}>
        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2M9 11a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM23 21v-2a4 4 0 0 0-3-3.87M16 3.13a4 4 0 0 1 0 7.75" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
      </svg>
    );

    // Coin icon for currency display (poker chip design with darts)
    const CoinIcon = ({ size = 16 }) => (
      <img
        src="assets/coin-chip.png"
        alt=""
        aria-hidden="true"
        width={size}
        height={size}
        style={{ objectFit: 'contain' }}
        decoding="async"
      />
    );

    // Stake chip icon for pot displays (larger chip stack)
    const StakeChipIcon = ({ size = 86, className = '' }) => (
      <img
        className={className}
        src="assets/chip-stack.png"
        alt=""
        aria-hidden="true"
        width={size}
        height={size}
        draggable={false}
        style={{
          display: 'block',
          userSelect: 'none',
          objectFit: 'contain',
          filter: 'drop-shadow(0 4px 12px rgba(0,0,0,0.5))',
          mixBlendMode: 'lighten',
        }}
      />
    );

    // ============================================
    // MATCHMAKING OVERLAY COMPONENT
    // ============================================
    const MatchmakingOverlay = ({ visible, stage, isWagered, stakeAmount, you, opponent, onCancel }) => {
      const backdropRef = useRef(null);
      const cancelBtnRef = useRef(null);
      const previousFocusRef = useRef(null);
      const [youAvatarError, setYouAvatarError] = useState(false);
      const [opponentAvatarError, setOpponentAvatarError] = useState(false);

      // Focus trap: capture focus when modal opens, restore on close
      useEffect(() => {
        if (visible) {
          previousFocusRef.current = document.activeElement;
          // Focus cancel button when in searching stage
          if (stage === 'searching' && cancelBtnRef.current) {
            cancelBtnRef.current.focus();
          }
        } else {
          // Restore focus when modal closes
          if (previousFocusRef.current && typeof previousFocusRef.current.focus === 'function') {
            previousFocusRef.current.focus();
          }
        }
      }, [visible, stage]);

      // Reset avatar errors when opponent changes
      useEffect(() => {
        setOpponentAvatarError(false);
        setYouAvatarError(false);
      }, [opponent?.avatarUrl, you?.avatarUrl]);

      // Keyboard escape handler
      const handleKeyDown = (e) => {
        if (e.key === 'Escape' && stage === 'searching') {
          onCancel();
        }
      };

      // Prevent clicks on backdrop from passing through
      const handleBackdropClick = (e) => {
        if (e.target === e.currentTarget && stage === 'searching') {
          onCancel();
        }
      };

      if (!visible) return null;

      return (
        <div
          ref={backdropRef}
          className="qd-mmBackdrop"
          role="dialog"
          aria-modal="true"
          aria-labelledby="mm-title"
          onKeyDown={handleKeyDown}
          onClick={handleBackdropClick}
        >
          {stage === 'searching' && (
            <div className="qd-mmCard">
              <div className="qd-mmIcon">üåç</div>
              <div id="mm-title" className="qd-mmTitle">FINDING OPPONENT‚Ä¶</div>
              <div className="qd-mmSub">Searching for players worldwide</div>
              {isWagered && stakeAmount > 0 && (
                <div className="qd-mmHint">
                  WAGERED MATCH ‚Ä¢ Stake locked: <strong>{stakeAmount?.toLocaleString()}</strong>
                </div>
              )}
              <div className="qd-mmDots" aria-hidden="true">
                <span /><span /><span />
              </div>
              <button ref={cancelBtnRef} className="qd-mmBtn" onClick={onCancel}>CANCEL</button>
            </div>
          )}

          {stage === 'found' && opponent && (
            <div className="qd-mmCard">
              <div className="qd-mmIcon">‚úì</div>
              <div id="mm-title" className="qd-mmTitle green">OPPONENT FOUND!</div>
              <div className="qd-mmOpponent">
                <div className="qd-mmAvatar">
                  {opponent.avatarUrl && !opponentAvatarError ? (
                    <img
                      src={opponent.avatarUrl}
                      alt={`${opponent.name}'s avatar`}
                      onError={() => setOpponentAvatarError(true)}
                    />
                  ) : (
                    <div className="qd-mmAvatarFallback">
                      {opponent.name?.slice(0,1)?.toUpperCase() || '?'}
                    </div>
                  )}
                </div>
                <div className="qd-mmName">{opponent.name}</div>
              </div>
              <div className="qd-mmSub">Starting game‚Ä¶</div>
            </div>
          )}

          {stage === 'intro' && opponent && isWagered && (
            <div className="qd-vsWrap">
              <div className="qd-vsPlayer left">
                <div className="qd-vsAvatar">
                  {you.avatarUrl && !youAvatarError ? (
                    <img
                      src={you.avatarUrl}
                      alt={`${you.name}'s avatar`}
                      onError={() => setYouAvatarError(true)}
                    />
                  ) : (
                    <div className="qd-vsAvatarFallback">
                      {you.name?.slice(0,1)?.toUpperCase() || '?'}
                    </div>
                  )}
                </div>
                <div className="qd-vsName">{you.name}</div>
                <div className="qd-vsLvl">Lv.{you.level}</div>
              </div>

              <div className="qd-vsCenter">
                <div className="qd-vsText">VS</div>
                <div className="qd-vsPot">
                  <StakeChipIcon size={86} className="qd-vsChip" />
                  <div className="qd-vsPotLabel">MATCH STAKE</div>
                  <div className="qd-vsPotAmount">{stakeAmount?.toLocaleString()}</div>
                </div>
              </div>

              <div className="qd-vsPlayer right">
                <div className="qd-vsAvatar">
                  {opponent.avatarUrl && !opponentAvatarError ? (
                    <img
                      src={opponent.avatarUrl}
                      alt={`${opponent.name}'s avatar`}
                      onError={() => setOpponentAvatarError(true)}
                    />
                  ) : (
                    <div className="qd-vsAvatarFallback">
                      {opponent.name?.slice(0,1)?.toUpperCase() || '?'}
                    </div>
                  )}
                </div>
                <div className="qd-vsName">{opponent.name}</div>
                <div className="qd-vsLvl">Lv.{opponent.level}</div>
              </div>
            </div>
          )}
        </div>
      );
    };

    // Format coin balance with commas
    const formatCoins = (amount) => {
      return amount.toLocaleString();
    };

    // Format large numbers compactly (1.2M, 500K, etc.)
    const formatCompactNumber = (num) => {
      if (num >= 1000000) {
        return (num / 1000000).toFixed(1).replace(/\.0$/, '') + 'M';
      }
      return num.toLocaleString('en-US');
    };

    // Design System Colors (matching CSS variables)
    const COLORS = {
      primary: '#1B4332',
      primaryLight: '#2D6A4F',
      primaryDark: '#143728',
      accent: '#D4A03A',
      accentLight: '#E8B94A',
      accentDark: '#B8862E',
      background: '#0D1117',
      backgroundLight: '#161B22',
      backgroundCard: '#1C2128',
      text: '#F5F5F5',
      textMuted: '#8B949E',
      textDark: '#0D1117',
      success: '#2D8A2D',
      error: '#C92A2A'
    };

    // Pre-computed bokeh light sizes (deterministic, no Math.random in render)
    const BOKEH_LIGHTS = [
      { size: 45, left: 10, top: 5 },
      { size: 65, left: 22, top: 15 },
      { size: 38, left: 34, top: 25 },
      { size: 72, left: 46, top: 35 },
      { size: 50, left: 58, top: 45 },
      { size: 58, left: 70, top: 55 },
      { size: 42, left: 82, top: 65 },
      { size: 68, left: 94, top: 75 }
    ];

    const BOARD_SIZE = 500;
    const CENTER = BOARD_SIZE / 2;
    const SEGMENTS = [20, 1, 18, 4, 13, 6, 10, 15, 2, 17, 3, 19, 7, 16, 8, 11, 14, 9, 12, 5];
    const SEGMENT_COLORS = ['#0a0a0a', '#f5f0e8']; // Deep black and cream (more realistic)
    const TRIPLE_INNER = 119;
    const TRIPLE_OUTER = 134;
    const DOUBLE_INNER = 200;
    const DOUBLE_OUTER = 215;
    const OUTER_BULL = 20;
    const INNER_BULL = 10;

    // ============================================
    // MATCHMAKING TIMING CONSTANTS
    // ============================================
    const MATCHMAKING_TIMINGS = Object.freeze({
      FOUND_TO_INTRO_DELAY_MS: 700,   // Delay after finding opponent before showing VS intro
      INTRO_DURATION_MS: 2500         // Duration of VS intro screen
    });

    // ============================================
    // DARTBOARD THEME SYSTEM
    // ============================================

    // Theme ID constants (no magic strings)
    const THEME_IDS = Object.freeze({
      CLASSIC: 'classic',
      PRO_WIRE: 'proWire',
      NEON_GLOW: 'neonGlow',
      GOLD_ELITE: 'goldElite',
      STEALTH: 'stealth'
    });

    // Neon color options for neonGlow theme
    const NEON_COLOR_OPTIONS = Object.freeze({
      CYAN: 'cyan',
      PINK: 'pink',
      GREEN: 'green'
    });

    // Classic theme - Matches iOS dartboard exactly (flat rendering, no 3D effects)
    const THEME_CLASSIC = Object.freeze({
      id: THEME_IDS.CLASSIC,
      name: 'Classic',
      description: 'Traditional dartboard matching iOS appearance',
      icon: 'üéØ',
      colors: {
        segmentPrimary: '#0a0a0a',      // Deep black
        segmentSecondary: '#f5f0e8',     // Cream
        doubleTripleEven: '#b8232a',     // Deep red
        doubleTripleOdd: '#0d6b2e',      // Deep green
        outerBull: '#0d6b2e',            // Green
        innerBull: '#b8232a',            // Red
        wireColor: '#888888',            // Light silver wire (matches iOS)
        wireHighlight: 'rgba(255,255,255,0.6)',
        chromeRing: '#c0c0c0',           // Silver chrome
        numberRing: '#1a1a2e',           // Navy background
        numberText: '#f5f0e8',           // Cream text
        frameColor: '#b8860b',           // Gold frame
        boardBackground: '#1a1a1a'
      },
      effects: {
        useSisalTexture: false,          // Disabled to match iOS (iOS doesn't render textures)
        useWoodGrain: false,             // Disabled to match iOS (iOS doesn't render wood grain)
        useChromeGradient: false,        // Disabled to match iOS (iOS uses solid chrome color)
        useBoardLighting: false,         // Disabled to match iOS (iOS doesn't render lighting)
        glowEffect: false,
        pulseAnimation: false,
        wireWidth: 1.0,                  // Thinner wire (matches iOS)
        shadowIntensity: 0               // Disabled to match iOS (iOS doesn't render shadows)
      }
    });

    // Pro Wire theme - Tournament look with metal wire dividers
    const THEME_PRO_WIRE = Object.freeze({
      id: THEME_IDS.PRO_WIRE,
      name: 'Pro Wire',
      description: 'Tournament style with thin metal wire dividers',
      icon: 'üèÜ',
      colors: {
        segmentPrimary: '#0a0a0a',
        segmentSecondary: '#e8e4dc',     // Slightly lighter cream
        doubleTripleEven: '#c41e3a',     // Brighter red
        doubleTripleOdd: '#1a8b45',      // Brighter green
        outerBull: '#1a8b45',
        innerBull: '#c41e3a',
        wireColor: '#d4d4d4',            // Silver wire
        wireHighlight: 'rgba(255,255,255,0.9)',
        chromeRing: '#e0e0e0',           // Bright chrome
        numberRing: '#1a1a2e',
        numberText: '#ffffff',           // White text
        frameColor: '#a0a0a0',           // Silver frame
        boardBackground: '#1a1a1a'
      },
      effects: {
        useSisalTexture: true,
        useWoodGrain: false,
        useChromeGradient: true,
        useBoardLighting: true,
        glowEffect: false,
        pulseAnimation: false,
        wireWidth: 0.8,                  // Thinner wires
        shadowIntensity: 0.2
      }
    });

    // Neon Glow theme - Dark board with glowing neon wires
    const THEME_NEON_GLOW = Object.freeze({
      id: THEME_IDS.NEON_GLOW,
      name: 'Neon Glow',
      description: 'Dark board with glowing neon wires',
      icon: '‚ú®',
      neonColorOptions: [NEON_COLOR_OPTIONS.CYAN, NEON_COLOR_OPTIONS.PINK, NEON_COLOR_OPTIONS.GREEN],
      defaultNeonColor: NEON_COLOR_OPTIONS.CYAN,
      // Colors will be dynamically set based on neon color selection
      getColors: (neonColor) => {
        const neonColors = {
          [NEON_COLOR_OPTIONS.CYAN]: {
            primary: '#00ffff',
            secondary: '#00d4ff',
            glow: 'rgba(0, 255, 255, 0.6)'
          },
          [NEON_COLOR_OPTIONS.PINK]: {
            primary: '#ff00ff',
            secondary: '#ff44aa',
            glow: 'rgba(255, 0, 255, 0.6)'
          },
          [NEON_COLOR_OPTIONS.GREEN]: {
            primary: '#00ff66',
            secondary: '#44ff88',
            glow: 'rgba(0, 255, 102, 0.6)'
          }
        };
        const neon = neonColors[neonColor] || neonColors[NEON_COLOR_OPTIONS.CYAN];
        return {
          segmentPrimary: '#0a0a12',       // Very dark
          segmentSecondary: '#1a1a28',     // Dark purple-black
          doubleTripleEven: '#2a0a1a',     // Dark red tint
          doubleTripleOdd: '#0a1a1a',      // Dark green tint
          outerBull: '#0a1a1a',
          innerBull: '#2a0a1a',
          wireColor: neon.primary,
          wireHighlight: neon.glow,
          chromeRing: '#1a1a28',
          numberRing: '#0a0a12',
          numberText: neon.primary,
          frameColor: neon.secondary,
          boardBackground: '#050508',
          neonGlow: neon.glow,
          neonPrimary: neon.primary
        };
      },
      effects: {
        useSisalTexture: false,
        useWoodGrain: false,
        useChromeGradient: false,
        useBoardLighting: false,
        glowEffect: true,
        pulseAnimation: true,
        wireWidth: 2.0,
        shadowIntensity: 0.1
      }
    });

    // Gold Elite theme - Black and gold luxury theme
    const THEME_GOLD_ELITE = Object.freeze({
      id: THEME_IDS.GOLD_ELITE,
      name: 'Gold Elite',
      description: 'Black and gold luxury premium theme',
      icon: 'üëë',
      colors: {
        segmentPrimary: '#0a0a0a',        // Black
        segmentSecondary: '#1a1a1a',      // Dark gray
        doubleTripleEven: '#b8860b',      // Dark gold
        doubleTripleOdd: '#daa520',       // Goldenrod
        outerBull: '#daa520',
        innerBull: '#ffd700',             // Gold
        wireColor: '#ffd700',             // Gold wire
        wireHighlight: 'rgba(255,215,0,0.8)',
        chromeRing: '#ffd700',            // Gold
        numberRing: '#0a0a0a',
        numberText: '#ffd700',
        frameColor: '#ffd700',
        boardBackground: '#050505',
        metallicSheen: 'rgba(255,215,0,0.15)'
      },
      effects: {
        useSisalTexture: false,
        useWoodGrain: false,
        useChromeGradient: false,
        useBoardLighting: true,
        glowEffect: false,
        pulseAnimation: false,
        wireWidth: 1.2,
        shadowIntensity: 0.4,
        useMetallicSheen: true
      }
    });

    // Stealth theme - All black/dark gray minimal (hard mode aesthetic)
    const THEME_STEALTH = Object.freeze({
      id: THEME_IDS.STEALTH,
      name: 'Stealth',
      description: 'Minimal dark theme - hard mode aesthetic',
      icon: 'üåë',
      colors: {
        segmentPrimary: '#0a0a0a',        // Deep black
        segmentSecondary: '#151515',      // Very dark gray
        doubleTripleEven: '#1a1a1a',      // Slightly lighter
        doubleTripleOdd: '#222222',       // Dark gray
        outerBull: '#1a1a1a',
        innerBull: '#252525',
        wireColor: '#333333',             // Dark gray wire
        wireHighlight: 'rgba(255,255,255,0.1)',
        chromeRing: '#1a1a1a',
        numberRing: '#0a0a0a',
        numberText: '#444444',            // Subtle text
        frameColor: '#151515',
        boardBackground: '#050505'
      },
      effects: {
        useSisalTexture: false,
        useWoodGrain: false,
        useChromeGradient: false,
        useBoardLighting: false,
        glowEffect: false,
        pulseAnimation: false,
        wireWidth: 0.5,
        shadowIntensity: 0.1
      }
    });

    // All themes collection
    const DARTBOARD_THEMES = Object.freeze({
      [THEME_IDS.CLASSIC]: THEME_CLASSIC,
      [THEME_IDS.PRO_WIRE]: THEME_PRO_WIRE,
      [THEME_IDS.NEON_GLOW]: THEME_NEON_GLOW,
      [THEME_IDS.GOLD_ELITE]: THEME_GOLD_ELITE,
      [THEME_IDS.STEALTH]: THEME_STEALTH
    });

    // Theme IDs array for iteration
    const THEME_IDS_LIST = Object.freeze([
      THEME_IDS.CLASSIC,
      THEME_IDS.PRO_WIRE,
      THEME_IDS.NEON_GLOW,
      THEME_IDS.GOLD_ELITE,
      THEME_IDS.STEALTH
    ]);

    // Default theme
    const DEFAULT_THEME_ID = THEME_IDS.CLASSIC;

    // Validate theme ID
    const isValidThemeId = (themeId) => {
      return themeId && Object.values(THEME_IDS).includes(themeId);
    };

    // Get theme by ID with validation
    const getThemeById = (themeId) => {
      if (!isValidThemeId(themeId)) {
        console.warn(`Invalid theme ID: ${themeId}, falling back to default`);
        return DARTBOARD_THEMES[DEFAULT_THEME_ID];
      }
      return DARTBOARD_THEMES[themeId];
    };

    // Get theme colors (handles neon glow special case)
    const getThemeColors = (theme, neonColor = null) => {
      if (theme.id === THEME_IDS.NEON_GLOW && theme.getColors) {
        return theme.getColors(neonColor || theme.defaultNeonColor);
      }
      return theme.colors;
    };

    // ============================================
    // END DARTBOARD THEME SYSTEM
    // ============================================

    // Achievements data - moved outside component to prevent recreation on every render
    // Achievements with chain property are part of tiered progression ladders
    const ACHIEVEMENTS_DATA = [
      // First Steps (standalone)
      { id: 'first_game', name: 'First Steps', description: 'Every champion starts somewhere. Complete your first game.', icon: 'üéØ', rarity: 'common', mode: 'offline' },
      { id: 'first_win', name: 'First Victory', description: 'The taste of victory never gets old. Win your first game.', icon: 'üèÜ', rarity: 'common', mode: 'offline' },

      // Maximum! Chain - 180 progression
      { id: 'first_180', name: 'Maximum! I', description: 'The crowd goes wild! Hit your first perfect 180.', icon: 'üíØ', rarity: 'uncommon', mode: 'offline', chain: 'maximum', tier: 1 },
      { id: 'ten_180s', name: 'Maximum! II', description: 'Consistency is key. Land 10 maximum scores.', icon: 'üíØ', rarity: 'rare', mode: 'offline', statKey: 'total180s', target: 10, chain: 'maximum', tier: 2 },
      { id: 'fifty_180s', name: 'Maximum! III', description: 'Only the elite reach this level. Hit 50 perfect 180s.', icon: 'üíØ', rarity: 'epic', mode: 'offline', statKey: 'total180s', target: 50, chain: 'maximum', tier: 3 },
      { id: 'hundred_180s', name: 'Maximum! IV', description: 'Legendary precision. 100 perfect 180s.', icon: 'üíØ', rarity: 'legendary', mode: 'offline', statKey: 'total180s', target: 100, chain: 'maximum', tier: 4 },

      // Nine Darter (standalone legendary)
      { id: 'nine_darter_offline', name: 'Perfect Game', description: 'The holy grail of darts. Achieve a legendary nine-dart finish.', icon: 'üëë', rarity: 'legendary', mode: 'offline' },
      { id: 'nine_darter_online', name: 'Online Legend', description: 'Perfection under pressure. Nine-dart finish against a real opponent.', icon: 'üíé', rarity: 'mythic', mode: 'online' },

      // Perfect 9 Chain (Nine-Darter milestones)
      { id: 'perfect9_first', name: 'Perfect 9', description: 'Complete a leg with 9 perfect darts.', icon: '9Ô∏è‚É£', rarity: 'mythic', mode: 'offline', chain: 'perfect9', tier: 1, statKey: 'totalNineDarters', target: 1 },
      { id: 'perfect9_ten', name: 'Perfect 9 Master', description: 'Complete 10 nine-darters.', icon: '9Ô∏è‚É£', rarity: 'mythic', mode: 'offline', chain: 'perfect9', tier: 2, statKey: 'totalNineDarters', target: 10 },
      { id: 'perfect9_hundred', name: 'Perfect 9 Legend', description: 'Complete 100 nine-darters.', icon: '9Ô∏è‚É£', rarity: 'mythic', mode: 'offline', chain: 'perfect9', tier: 3, statKey: 'totalNineDarters', target: 100 },

      // Bullseye! Chain
      { id: 'first_bull', name: 'Bullseye! I', description: 'Right in the center! Hit your first bullseye.', icon: 'üéØ', rarity: 'common', mode: 'offline', chain: 'bullseye', tier: 1 },
      { id: 'fifty_bulls', name: 'Bullseye! II', description: 'Precision personified. Find the bullseye 50 times.', icon: 'üéØ', rarity: 'rare', mode: 'offline', statKey: 'totalBulls', target: 50, chain: 'bullseye', tier: 2 },
      { id: 'hundred_bulls', name: 'Bullseye! III', description: 'The center is your home. 100 bullseyes and counting.', icon: 'üéØ', rarity: 'epic', mode: 'offline', statKey: 'totalBulls', target: 100, chain: 'bullseye', tier: 3 },
      { id: 'twofifty_bulls', name: 'Bullseye! IV', description: 'Master of the center. 250 bullseyes.', icon: 'üéØ', rarity: 'legendary', mode: 'offline', statKey: 'totalBulls', target: 250, chain: 'bullseye', tier: 4 },

      // Victory Chain
      { id: 'five_wins', name: 'Victory I', description: 'You\'re heating up! Claim 5 victories.', icon: 'üèÜ', rarity: 'uncommon', mode: 'offline', statKey: 'totalGamesWon', target: 5, chain: 'victory', tier: 1 },
      { id: 'twenty_wins', name: 'Victory II', description: 'They fear your name. Dominate with 20 wins.', icon: 'üèÜ', rarity: 'rare', mode: 'offline', statKey: 'totalGamesWon', target: 20, chain: 'victory', tier: 2 },
      { id: 'fifty_wins', name: 'Victory III', description: 'A true champion emerges. Conquer 50 games.', icon: 'üèÜ', rarity: 'epic', mode: 'offline', statKey: 'totalGamesWon', target: 50, chain: 'victory', tier: 3 },
      { id: 'hundred_wins', name: 'Victory IV', description: 'Unstoppable force. 100 victories.', icon: 'üèÜ', rarity: 'legendary', mode: 'offline', statKey: 'totalGamesWon', target: 100, chain: 'victory', tier: 4 },

      // Global Chain - Online progression
      { id: 'first_online', name: 'Global I', description: 'Step into the arena. Face your first online opponent.', icon: 'üåç', rarity: 'common', mode: 'online', chain: 'global', tier: 1 },
      { id: 'first_online_win', name: 'Global II', description: 'Real opponents, real pressure, real victory.', icon: 'üåç', rarity: 'uncommon', mode: 'online', chain: 'global', tier: 2 },
      { id: 'ten_online_wins', name: 'Global III', description: 'Battle-tested. Defeat 10 online challengers.', icon: 'üåç', rarity: 'rare', mode: 'online', statKey: 'totalOnlineWins', target: 10, chain: 'global', tier: 3 },
      { id: 'fifty_online_wins', name: 'Global IV', description: 'World-class competitor. 50 online victories.', icon: 'üåç', rarity: 'epic', mode: 'online', statKey: 'totalOnlineWins', target: 50, chain: 'global', tier: 4 },

      // Checkout Chain
      { id: 'big_checkout', name: 'Checkout I', description: 'Nerves of steel. Checkout 100+ in one visit.', icon: 'üéØ', rarity: 'uncommon', mode: 'offline', statKey: 'highestCheckout', target: 100, isThreshold: true, chain: 'checkout', tier: 1 },
      { id: 'huge_checkout', name: 'Checkout II', description: 'The impossible made possible. Checkout 150+ points.', icon: 'üéØ', rarity: 'rare', mode: 'offline', statKey: 'highestCheckout', target: 150, isThreshold: true, chain: 'checkout', tier: 2 },
      { id: 'max_checkout', name: 'Checkout III', description: 'The ultimate finish. Checkout 170 - the maximum.', icon: 'üéØ', rarity: 'legendary', mode: 'offline', statKey: 'highestCheckout', target: 170, isThreshold: true, chain: 'checkout', tier: 3 },

      // Triple Chain
      { id: 'fifty_triples', name: 'Triple I', description: 'Treble trouble for opponents. Hit 50 triples.', icon: '3Ô∏è‚É£', rarity: 'uncommon', mode: 'offline', statKey: 'totalTriples', target: 50, chain: 'triple', tier: 1 },
      { id: 'two_hundred_triples', name: 'Triple II', description: 'The triple 20 is your playground. 200 triples.', icon: '3Ô∏è‚É£', rarity: 'rare', mode: 'offline', statKey: 'totalTriples', target: 200, chain: 'triple', tier: 2 },
      { id: 'five_hundred_triples', name: 'Triple III', description: 'Triple mastery achieved. 500 triples.', icon: '3Ô∏è‚É£', rarity: 'epic', mode: 'offline', statKey: 'totalTriples', target: 500, chain: 'triple', tier: 3 }
    ];

    // Time-Limited Achievements - Weekly rotating challenges synced via Firebase
    // These rotate on a 4-week cycle
    const TIME_LIMITED_ACHIEVEMENTS = [
      // Week 1 - 180 Focus
      {
        id: 'weekly_180_sprint',
        name: 'Maximum Week',
        description: 'Hit 10 perfect 180s this week',
        icon: 'üíØ',
        rarity: 'rare',
        statKey: 'weekly180s',
        target: 10,
        week: 1,
        reward: '180 Master Badge'
      },
      // Week 2 - Bullseye Focus
      {
        id: 'weekly_bulls_blitz',
        name: 'Bulls Week',
        description: 'Hit 25 bullseyes this week',
        icon: 'üéØ',
        rarity: 'rare',
        statKey: 'weeklyBulls',
        target: 25,
        week: 2,
        reward: 'Bullseye Badge'
      },
      // Week 3 - Victory Focus
      {
        id: 'weekly_win_streak',
        name: 'Victory Week',
        description: 'Win 10 games this week',
        icon: 'üèÜ',
        rarity: 'rare',
        statKey: 'weeklyWins',
        target: 10,
        week: 3,
        reward: 'Champion Badge'
      },
      // Week 4 - Triples Focus
      {
        id: 'weekly_triple_threat',
        name: 'Triples Week',
        description: 'Hit 50 triples this week',
        icon: '3Ô∏è‚É£',
        rarity: 'rare',
        statKey: 'weeklyTriples',
        target: 50,
        week: 4,
        reward: 'Triple Badge'
      }
    ];

    // Get current week number (1-4 rotation)
    const getCurrentWeekNumber = () => {
      const now = new Date();
      const startOfYear = new Date(now.getFullYear(), 0, 1);
      const weekNumber = Math.ceil((((now - startOfYear) / 86400000) + startOfYear.getDay() + 1) / 7);
      return ((weekNumber - 1) % 4) + 1; // Returns 1-4
    };

    // Get the current active time-limited achievement
    const getActiveTimeLimitedAchievement = () => {
      const currentWeek = getCurrentWeekNumber();
      return TIME_LIMITED_ACHIEVEMENTS.find(a => a.week === currentWeek);
    };

    // Create default weekly challenge data for a given week
    const createDefaultWeeklyChallengeData = (weekNumber) => ({
      weekNumber: weekNumber,
      challengeId: TIME_LIMITED_ACHIEVEMENTS.find(a => a.week === weekNumber)?.id,
      stats: { weekly180s: 0, weeklyBulls: 0, weeklyWins: 0, weeklyTriples: 0 },
      completed: false,
      completedChallenges: []
    });

    // Validate weekly challenge data structure from localStorage
    const isValidWeeklyChallengeData = (data) => {
      if (!data || typeof data !== 'object') return false;
      if (typeof data.weekNumber !== 'number') return false;
      if (!data.stats || typeof data.stats !== 'object') return false;
      if (typeof data.completed !== 'boolean') return false;
      if (!Array.isArray(data.completedChallenges)) return false;
      return true;
    };

    // Get time until next weekly reset (Sunday midnight)
    const getTimeUntilWeeklyReset = () => {
      const now = new Date();
      const nextSunday = new Date(now);
      nextSunday.setDate(now.getDate() + (7 - now.getDay()));
      nextSunday.setHours(0, 0, 0, 0);
      return nextSunday - now;
    };

    // Format time remaining
    const formatTimeRemaining = (ms) => {
      const days = Math.floor(ms / (1000 * 60 * 60 * 24));
      const hours = Math.floor((ms % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
      const minutes = Math.floor((ms % (1000 * 60 * 60)) / (1000 * 60));
      if (days > 0) return `${days}d ${hours}h`;
      if (hours > 0) return `${hours}h ${minutes}m`;
      return `${minutes}m`;
    };

    // Daily Challenges - Rotating daily goals that reset at midnight
    const DAILY_CHALLENGES_POOL = [
      // 180s challenges
      { id: 'daily_180_1', name: 'Maximum!', description: 'Hit 1 perfect 180', icon: 'üíØ', statKey: 'daily180s', target: 1, difficulty: 'easy' },
      { id: 'daily_180_3', name: 'Triple Maximum', description: 'Hit 3 perfect 180s', icon: 'üíØ', statKey: 'daily180s', target: 3, difficulty: 'medium' },
      { id: 'daily_180_5', name: '180 Machine', description: 'Hit 5 perfect 180s', icon: 'üíØ', statKey: 'daily180s', target: 5, difficulty: 'hard' },
      // Bulls challenges
      { id: 'daily_bulls_5', name: 'Bullseye Starter', description: 'Hit 5 bullseyes', icon: 'üéØ', statKey: 'dailyBulls', target: 5, difficulty: 'easy' },
      { id: 'daily_bulls_15', name: 'Bulls on Target', description: 'Hit 15 bullseyes', icon: 'üéØ', statKey: 'dailyBulls', target: 15, difficulty: 'medium' },
      { id: 'daily_bulls_30', name: 'Bull Master', description: 'Hit 30 bullseyes', icon: 'üéØ', statKey: 'dailyBulls', target: 30, difficulty: 'hard' },
      // Wins challenges
      { id: 'daily_wins_1', name: 'First Win', description: 'Win 1 game', icon: 'üèÜ', statKey: 'dailyWins', target: 1, difficulty: 'easy' },
      { id: 'daily_wins_3', name: 'Winning Streak', description: 'Win 3 games', icon: 'üèÜ', statKey: 'dailyWins', target: 3, difficulty: 'medium' },
      { id: 'daily_wins_5', name: 'Dominant Day', description: 'Win 5 games', icon: 'üèÜ', statKey: 'dailyWins', target: 5, difficulty: 'hard' },
      // Games played challenges
      { id: 'daily_games_3', name: 'Warm Up', description: 'Play 3 games', icon: 'üéÆ', statKey: 'dailyGames', target: 3, difficulty: 'easy' },
      { id: 'daily_games_5', name: 'Practice Run', description: 'Play 5 games', icon: 'üéÆ', statKey: 'dailyGames', target: 5, difficulty: 'medium' },
      { id: 'daily_games_10', name: 'Marathon', description: 'Play 10 games', icon: 'üéÆ', statKey: 'dailyGames', target: 10, difficulty: 'hard' },
      // Triples challenges
      { id: 'daily_triples_10', name: 'Triple Starter', description: 'Hit 10 triples', icon: '3Ô∏è‚É£', statKey: 'dailyTriples', target: 10, difficulty: 'easy' },
      { id: 'daily_triples_25', name: 'Triple Threat', description: 'Hit 25 triples', icon: '3Ô∏è‚É£', statKey: 'dailyTriples', target: 25, difficulty: 'medium' },
      { id: 'daily_triples_50', name: 'Triple Master', description: 'Hit 50 triples', icon: '3Ô∏è‚É£', statKey: 'dailyTriples', target: 50, difficulty: 'hard' },
      // Score challenges
      { id: 'daily_score_500', name: 'Score Seeker', description: 'Score 500 points', icon: 'üìä', statKey: 'dailyScore', target: 500, difficulty: 'easy' },
      { id: 'daily_score_1500', name: 'Point Collector', description: 'Score 1500 points', icon: 'üìä', statKey: 'dailyScore', target: 1500, difficulty: 'medium' },
      { id: 'daily_score_3000', name: 'High Scorer', description: 'Score 3000 points', icon: 'üìä', statKey: 'dailyScore', target: 3000, difficulty: 'hard' }
    ];

    // Difficulty level colors for challenge UI
    const DIFFICULTY_COLORS = {
      easy: '#27ae60',
      medium: '#f39c12',
      hard: '#e74c3c'
    };

    // AI opponent difficulty levels and accuracy percentages
    const AI_DIFFICULTIES = {
      BEGINNER: { key: 'beginner', accuracy: 35, label: 'Beginner' },
      INTERMEDIATE: { key: 'intermediate', accuracy: 60, label: 'Intermediate' },
      EXPERT: { key: 'expert', accuracy: 80, label: 'Expert' },
      IMPOSSIBLE: { key: 'impossible', accuracy: 95, label: 'Impossible' }
    };

    // Generate daily challenges based on date seed
    const generateDailyChallenges = (dateString) => {
      const seed = dateString.split('-').reduce((acc, val) => acc + parseInt(val), 0);
      const shuffled = [...DAILY_CHALLENGES_POOL].sort((a, b) => {
        const hashA = (seed * 31 + a.id.charCodeAt(0)) % 1000;
        const hashB = (seed * 31 + b.id.charCodeAt(0)) % 1000;
        return hashA - hashB;
      });
      const easy = shuffled.find(c => c.difficulty === 'easy');
      const medium = shuffled.find(c => c.difficulty === 'medium');
      const hard = shuffled.find(c => c.difficulty === 'hard');
      return [easy, medium, hard].filter(Boolean);
    };

    // Get today's date string in YYYY-MM-DD format
    const getTodayString = () => {
      const today = new Date();
      return `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;
    };

    // Create default daily challenge data for a given date
    const createDefaultDailyChallengeData = (dateString) => ({
      date: dateString,
      challenges: generateDailyChallenges(dateString),
      stats: { daily180s: 0, dailyBulls: 0, dailyWins: 0, dailyGames: 0, dailyTriples: 0, dailyScore: 0 },
      completedChallenges: []
    });

    // Validate daily challenge data structure from localStorage
    const isValidDailyChallengeData = (data) => {
      if (!data || typeof data !== 'object') return false;
      if (typeof data.date !== 'string') return false;
      if (!Array.isArray(data.challenges)) return false;
      if (!data.stats || typeof data.stats !== 'object') return false;
      if (!Array.isArray(data.completedChallenges)) return false;
      // Validate each challenge has required properties
      for (const challenge of data.challenges) {
        if (!challenge.id || !challenge.statKey || typeof challenge.target !== 'number') {
          return false;
        }
      }
      return true;
    };

    // Country list for player nationality selection (static data, moved outside component for performance)
    const COUNTRIES = [
      { name: 'Afghanistan', flag: 'üá¶üá´' }, { name: 'Albania', flag: 'üá¶üá±' }, { name: 'Algeria', flag: 'üá©üáø' },
      { name: 'Argentina', flag: 'üá¶üá∑' }, { name: 'Armenia', flag: 'üá¶üá≤' }, { name: 'Australia', flag: 'üá¶üá∫' },
      { name: 'Austria', flag: 'üá¶üáπ' }, { name: 'Azerbaijan', flag: 'üá¶üáø' }, { name: 'Bahrain', flag: 'üáßüá≠' },
      { name: 'Bangladesh', flag: 'üáßüá©' }, { name: 'Belarus', flag: 'üáßüáæ' }, { name: 'Belgium', flag: 'üáßüá™' },
      { name: 'Bolivia', flag: 'üáßüá¥' }, { name: 'Bosnia', flag: 'üáßüá¶' }, { name: 'Brazil', flag: 'üáßüá∑' },
      { name: 'Bulgaria', flag: 'üáßüá¨' }, { name: 'Cambodia', flag: 'üá∞üá≠' }, { name: 'Canada', flag: 'üá®üá¶' },
      { name: 'Chile', flag: 'üá®üá±' }, { name: 'China', flag: 'üá®üá≥' }, { name: 'Colombia', flag: 'üá®üá¥' },
      { name: 'Costa Rica', flag: 'üá®üá∑' }, { name: 'Croatia', flag: 'üá≠üá∑' }, { name: 'Cuba', flag: 'üá®üá∫' },
      { name: 'Cyprus', flag: 'üá®üáæ' }, { name: 'Czech Republic', flag: 'üá®üáø' }, { name: 'Denmark', flag: 'üá©üá∞' },
      { name: 'Ecuador', flag: 'üá™üá®' }, { name: 'Egypt', flag: 'üá™üá¨' }, { name: 'England', flag: 'üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø' },
      { name: 'Estonia', flag: 'üá™üá™' }, { name: 'Ethiopia', flag: 'üá™üáπ' }, { name: 'Finland', flag: 'üá´üáÆ' },
      { name: 'France', flag: 'üá´üá∑' }, { name: 'Georgia', flag: 'üá¨üá™' }, { name: 'Germany', flag: 'üá©üá™' },
      { name: 'Ghana', flag: 'üá¨üá≠' }, { name: 'Greece', flag: 'üá¨üá∑' }, { name: 'Hong Kong', flag: 'üá≠üá∞' },
      { name: 'Hungary', flag: 'üá≠üá∫' }, { name: 'Iceland', flag: 'üáÆüá∏' }, { name: 'India', flag: 'üáÆüá≥' },
      { name: 'Indonesia', flag: 'üáÆüá©' }, { name: 'Iran', flag: 'üáÆüá∑' }, { name: 'Iraq', flag: 'üáÆüá∂' },
      { name: 'Ireland', flag: 'üáÆüá™' }, { name: 'Israel', flag: 'üáÆüá±' }, { name: 'Italy', flag: 'üáÆüáπ' },
      { name: 'Jamaica', flag: 'üáØüá≤' }, { name: 'Japan', flag: 'üáØüáµ' }, { name: 'Jordan', flag: 'üáØüá¥' },
      { name: 'Kazakhstan', flag: 'üá∞üáø' }, { name: 'Kenya', flag: 'üá∞üá™' }, { name: 'Kuwait', flag: 'üá∞üáº' },
      { name: 'Latvia', flag: 'üá±üáª' }, { name: 'Lebanon', flag: 'üá±üáß' }, { name: 'Libya', flag: 'üá±üáæ' },
      { name: 'Lithuania', flag: 'üá±üáπ' }, { name: 'Luxembourg', flag: 'üá±üá∫' }, { name: 'Malaysia', flag: 'üá≤üáæ' },
      { name: 'Malta', flag: 'üá≤üáπ' }, { name: 'Mexico', flag: 'üá≤üáΩ' }, { name: 'Morocco', flag: 'üá≤üá¶' },
      { name: 'Nepal', flag: 'üá≥üáµ' }, { name: 'Netherlands', flag: 'üá≥üá±' }, { name: 'New Zealand', flag: 'üá≥üáø' },
      { name: 'Nigeria', flag: 'üá≥üá¨' }, { name: 'North Korea', flag: 'üá∞üáµ' }, { name: 'Northern Ireland', flag: 'üá¨üáß' },
      { name: 'Norway', flag: 'üá≥üá¥' }, { name: 'Pakistan', flag: 'üáµüá∞' }, { name: 'Palestine', flag: 'üáµüá∏' },
      { name: 'Panama', flag: 'üáµüá¶' }, { name: 'Peru', flag: 'üáµüá™' }, { name: 'Philippines', flag: 'üáµüá≠' },
      { name: 'Poland', flag: 'üáµüá±' }, { name: 'Portugal', flag: 'üáµüáπ' }, { name: 'Qatar', flag: 'üá∂üá¶' },
      { name: 'Romania', flag: 'üá∑üá¥' }, { name: 'Russia', flag: 'üá∑üá∫' }, { name: 'Saudi Arabia', flag: 'üá∏üá¶' },
      { name: 'Scotland', flag: 'üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø' }, { name: 'Senegal', flag: 'üá∏üá≥' }, { name: 'Serbia', flag: 'üá∑üá∏' },
      { name: 'Singapore', flag: 'üá∏üá¨' }, { name: 'Slovakia', flag: 'üá∏üá∞' }, { name: 'Slovenia', flag: 'üá∏üáÆ' },
      { name: 'South Africa', flag: 'üáøüá¶' }, { name: 'South Korea', flag: 'üá∞üá∑' }, { name: 'Spain', flag: 'üá™üá∏' },
      { name: 'Sri Lanka', flag: 'üá±üá∞' }, { name: 'Sweden', flag: 'üá∏üá™' }, { name: 'Switzerland', flag: 'üá®üá≠' },
      { name: 'Syria', flag: 'üá∏üáæ' }, { name: 'Taiwan', flag: 'üáπüáº' }, { name: 'Thailand', flag: 'üáπüá≠' },
      { name: 'Tunisia', flag: 'üáπüá≥' }, { name: 'Turkey', flag: 'üáπüá∑' }, { name: 'UAE', flag: 'üá¶üá™' },
      { name: 'Uganda', flag: 'üá∫üá¨' }, { name: 'Ukraine', flag: 'üá∫üá¶' }, { name: 'United Kingdom', flag: 'üá¨üáß' },
      { name: 'Uruguay', flag: 'üá∫üáæ' }, { name: 'USA', flag: 'üá∫üá∏' }, { name: 'Uzbekistan', flag: 'üá∫üáø' },
      { name: 'Venezuela', flag: 'üáªüá™' }, { name: 'Vietnam', flag: 'üáªüá≥' }, { name: 'Wales', flag: 'üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø' },
      { name: 'Yemen', flag: 'üáæüá™' }, { name: 'Zimbabwe', flag: 'üáøüáº' }
    ];

    // Checkout suggestions for darts (static data, moved outside component for performance)
    const CHECKOUT_SUGGESTIONS = {
      170: 'T20 T20 Bull', 167: 'T20 T19 Bull', 164: 'T20 T18 Bull', 161: 'T20 T17 Bull',
      160: 'T20 T20 D20', 158: 'T20 T20 D19', 157: 'T20 T19 D20', 156: 'T20 T20 D18',
      155: 'T20 T19 D19', 154: 'T20 T18 D20', 153: 'T20 T19 D18', 152: 'T20 T20 D16',
      151: 'T20 T17 D20', 150: 'T20 T18 D18', 149: 'T20 T19 D16', 148: 'T20 T20 D14',
      147: 'T20 T17 D18', 146: 'T20 T18 D16', 145: 'T20 T19 D14', 144: 'T20 T20 D12',
      143: 'T20 T17 D16', 142: 'T20 T14 D20', 141: 'T20 T19 D12', 140: 'T20 T20 D10',
      139: 'T20 T13 D20', 138: 'T20 T18 D12', 137: 'T20 T19 D10', 136: 'T20 T20 D8',
      135: 'T20 T17 D12', 134: 'T20 T14 D16', 133: 'T20 T19 D8', 132: 'T20 T16 D12',
      131: 'T20 T13 D16', 130: 'T20 T18 D8', 129: 'T19 T16 D12', 128: 'T18 T14 D16',
      127: 'T20 T17 D8', 126: 'T19 T19 D6', 125: 'T20 T19 D4', 124: 'T20 T16 D8',
      123: 'T19 T16 D9', 122: 'T18 T18 D7', 121: 'T20 T11 D14', 120: 'T20 S20 D20',
      119: 'T19 T12 D13', 118: 'T20 S18 D20', 117: 'T20 S17 D20', 116: 'T20 S16 D20',
      115: 'T20 S15 D20', 114: 'T20 S14 D20', 113: 'T20 S13 D20', 112: 'T20 S12 D20',
      111: 'T20 S11 D20', 110: 'T20 S10 D20', 109: 'T20 S9 D20', 108: 'T20 S8 D20',
      107: 'T19 S10 D20', 106: 'T20 S6 D20', 105: 'T20 S5 D20', 104: 'T20 S4 D20',
      103: 'T20 S3 D20', 102: 'T20 S2 D20', 101: 'T20 S1 D20', 100: 'T20 D20',
      99: 'T19 S10 D16', 98: 'T20 D19', 97: 'T19 D20', 96: 'T20 D18', 95: 'T19 D19',
      94: 'T18 D20', 93: 'T19 D18', 92: 'T20 D16', 91: 'T17 D20', 90: 'T18 D18',
      89: 'T19 D16', 88: 'T20 D14', 87: 'T17 D18', 86: 'T18 D16', 85: 'T19 D14',
      84: 'T20 D12', 83: 'T17 D16', 82: 'T14 D20', 81: 'T19 D12', 80: 'T20 D10',
      79: 'T13 D20', 78: 'T18 D12', 77: 'T19 D10', 76: 'T20 D8', 75: 'T17 D12',
      74: 'T14 D16', 73: 'T19 D8', 72: 'T16 D12', 71: 'T13 D16', 70: 'T18 D8',
      69: 'T19 D6', 68: 'T20 D4', 67: 'T17 D8', 66: 'T10 D18', 65: 'T19 D4',
      64: 'T16 D8', 63: 'T13 D12', 62: 'T10 D16', 61: 'T15 D8', 60: 'S20 D20',
      59: 'S19 D20', 58: 'S18 D20', 57: 'S17 D20', 56: 'S16 D20', 55: 'S15 D20',
      54: 'S14 D20', 53: 'S13 D20', 52: 'S12 D20', 51: 'S11 D20', 50: 'S10 D20',
      49: 'S9 D20', 48: 'S8 D20', 47: 'S7 D20', 46: 'S6 D20', 45: 'S5 D20',
      44: 'S4 D20', 43: 'S3 D20', 42: 'S2 D20', 41: 'S1 D20', 40: 'D20',
      38: 'D19', 36: 'D18', 34: 'D17', 32: 'D16', 30: 'D15', 28: 'D14',
      26: 'D13', 24: 'D12', 22: 'D11', 20: 'D10', 18: 'D9', 16: 'D8',
      14: 'D7', 12: 'D6', 10: 'D5', 8: 'D4', 6: 'D3', 4: 'D2', 2: 'D1'
    };

    const DartsGame = () => {
      const [gameState, setGameState] = useState('landing');
      const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
      const [players, setPlayers] = useState([]);
      const [currentPlayerIndex, setCurrentPlayerIndex] = useState(0);
      const [dartsThrown, setDartsThrown] = useState(0);
      const [currentTurnScore, setCurrentTurnScore] = useState(0);
      const [throwHistory, setThrowHistory] = useState([]);
      const [aimPosition, setAimPosition] = useState({ x: CENTER, y: CENTER });
      const [isAiming, setIsAiming] = useState(false);
      const [power, setPower] = useState(0);
      const [isPowerCharging, setIsPowerCharging] = useState(false);
      const [dartPositions, setDartPositions] = useState([]);
      const [showScorePopup, setShowScorePopup] = useState(null);
      const [gameStats, setGameStats] = useState({});
      const [winner, setWinner] = useState(null);
      const [skillLevel, setSkillLevel] = useState(60); // Default to Intermediate
      const [soundEnabled, setSoundEnabled] = useState(true);
      const [showStats, setShowStats] = useState(false);
      const [playerSetup, setPlayerSetup] = useState({ count: 1, names: ['Player 1', 'Player 2', 'Player 3', 'Player 4'], gameMode: 501, aiPlayers: [false, false, false, false], aiDifficulty: [null, null, null, null], legsPerSet: 3, setsToWin: 1, flags: ['üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø', 'üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø', 'üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø', 'üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø'] });
      const [animatingDart, setAnimatingDart] = useState(null);
      const [checkout, setCheckout] = useState(null);
      const [triplesHit, setTriplesHit] = useState(0);
      const [isCheckoutPosition, setIsCheckoutPosition] = useState(false);
      const [legScores, setLegScores] = useState([]); // Track legs won per player
      const [setScores, setSetScores] = useState([]); // Track sets won per player
      const [matchWinner, setMatchWinner] = useState(null);
      const [legDartsThrown, setLegDartsThrown] = useState([]); // Track darts thrown per player in current leg
      const [showNineDarter, setShowNineDarter] = useState(false);
      const [currentTurnThrows, setCurrentTurnThrows] = useState([]); // Track throws in current turn for wobble detection
      const [aimWobble, setAimWobble] = useState({ x: 0, y: 0 }); // Wobble offset for aim position
      const [isMobile, setIsMobile] = useState(() => {
        // Robust mobile detection: check screen width, touch capability, and user agent
        const isSmallScreen = window.innerWidth < 600;
        const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        const isMobileUA = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        return isSmallScreen || (hasTouchScreen && isMobileUA);
      }); // Mobile detection for responsive UI

      // Online multiplayer states
      const [onlineMode, setOnlineMode] = useState(false); // true when in online multiplayer
      const [matchmakingState, setMatchmakingState] = useState(null); // null, 'searching', 'found', 'playing'
      const [gameRoomId, setGameRoomId] = useState(null); // Firebase room ID
      const [playerId, setPlayerId] = useState(null); // Player index (0 or 1) in the game
      const [myAuthId, setMyAuthId] = useState(null); // Auth UID for matchmaking queue
      const [opponentName, setOpponentName] = useState('');
      const [opponentFlag, setOpponentFlag] = useState('üåç');
      const [opponentLevel, setOpponentLevel] = useState(1);
      const [opponentAvatar, setOpponentAvatar] = useState(null);
      const [pendingGameInfo, setPendingGameInfo] = useState(null); // {roomId, playerIndex} for stage transitions
      const gameRoomRef = useRef(null); // Firebase room reference
      const opponentWasConnected = useRef(false); // Track if opponent was ever connected
      const earlyDisconnectListenerRef = useRef(null); // Track listener during 'found' state
      const heartbeatIntervalRef = useRef(null); // Heartbeat interval for disconnect detection
      const myPlayerKeyRef = useRef(null); // Store player key (player1 or player2) for heartbeat

      // Practice mode states
      const [practiceMode, setPracticeMode] = useState(false); // true when in practice mode
      const [practiceSkillLevel, setPracticeSkillLevel] = useState(null); // skill level for practice
      const [practiceStats, setPracticeStats] = useState({
        dartsThrown: 0,
        t20: 0,
        t19: 0,
        t18: 0,
        bulls: 0,
        singleBull: 0,
        triples: 0,
        doubles: 0,
        totalScore: 0
      }); // track what player hits in practice

      // Achievements system
      const [unlockedAchievements, setUnlockedAchievements] = useState(() => {
        try {
          const saved = localStorage.getItem('quikdarts_achievements');
          if (saved) {
            const parsed = JSON.parse(saved);
            // Validate: only keep IDs that exist in ACHIEVEMENTS_DATA
            return Array.isArray(parsed) ? parsed.filter(id =>
              typeof id === 'string' && ACHIEVEMENTS_DATA.some(a => a.id === id)
            ) : [];
          }
          return [];
        } catch (error) {
          console.error('Failed to load achievements from localStorage:', error);
          return [];
        }
      });
      const [achievementPopup, setAchievementPopup] = useState(null); // Currently showing achievement
      const [showAchievements, setShowAchievements] = useState(false); // Show achievements gallery
      const [achievementTab, setAchievementTab] = useState('offline'); // 'offline' | 'online'
      const [showLoginModal, setShowLoginModal] = useState(false); // Show login modal
      const [currentUser, setCurrentUser] = useState(null); // Current signed-in user

      // Coin system state
      const [coinBalance, setCoinBalance] = useState(0); // User's coin balance
      const [dailyBonusAvailable, setDailyBonusAvailable] = useState(false); // Daily bonus claimable
      const [showStakeSelection, setShowStakeSelection] = useState(false); // Stake selection modal
      const [selectedStake, setSelectedStake] = useState(50); // Selected stake amount
      const [isClaimingBonus, setIsClaimingBonus] = useState(false); // Claiming daily bonus
      const [adsRemainingToday, setAdsRemainingToday] = useState(5); // Ad rewards remaining today
      const [isWatchingAd, setIsWatchingAd] = useState(false); // Currently watching ad
      const [adError, setAdError] = useState(null); // Ad error message
      const [showCoinShop, setShowCoinShop] = useState(false); // Coin shop modal
      const [isPurchasing, setIsPurchasing] = useState(false); // Processing purchase
      const walletListenerRef = useRef(null); // Wallet listener cleanup
      const profileListenerRef = useRef(null); // Profile listener cleanup

      // Profile state
      const [userProfile, setUserProfile] = useState(null); // User's profile data
      const [userProgression, setUserProgression] = useState(null); // User's level/XP data
      const [userStreaks, setUserStreaks] = useState(null); // User's win streak data
      const [showProfileScreen, setShowProfileScreen] = useState(false); // Profile screen visibility

      // Nickname editing state
      const [isEditingNickname, setIsEditingNickname] = useState(false);
      const [nicknameInput, setNicknameInput] = useState('');

      const [currentEscrowId, setCurrentEscrowId] = useState(null); // Active escrow ID for wagered match
      const [isWageredMatch, setIsWageredMatch] = useState(false); // Is current match wagered
      const [showLeaveConfirmation, setShowLeaveConfirmation] = useState(false); // Leave match confirmation modal
      const [isCreatingEscrow, setIsCreatingEscrow] = useState(false); // Creating escrow in progress
      const [escrowData, setEscrowData] = useState(null); // Escrow data for wagered match header

      // Tiered Optimistic UI state for wagered matches
      const [scoreConfirming, setScoreConfirming] = useState(false); // Show "Confirming..." on score
      const [rhythmState, setRhythmState] = useState('neutral'); // 'flow' | 'perfect' | 'neutral' | 'rushing' | 'hesitating'

      const [achievementStats, setAchievementStats] = useState(() => {
        try {
          const saved = localStorage.getItem('quikdarts_stats');
          return saved ? JSON.parse(saved) : {
            totalGamesPlayed: 0,
            totalGamesWon: 0,
            total180s: 0,
            totalNineDarters: 0,
            totalOnlineGames: 0,
            totalOnlineWins: 0,
            totalBulls: 0,
            totalTriples: 0,
            highestCheckout: 0
          };
        } catch (error) {
          console.error('Failed to load achievement stats from localStorage:', error);
          return {
            totalGamesPlayed: 0,
            totalGamesWon: 0,
            total180s: 0,
            totalNineDarters: 0,
            totalOnlineGames: 0,
            totalOnlineWins: 0,
            totalBulls: 0,
            totalTriples: 0,
            highestCheckout: 0
          };
        }
      });

      // Helper to check if current game has at least one AI opponent
      // Used to prevent solo play (no AI) from counting towards achievements
      const hasAIOpponent = useMemo(() => {
        return players.length > 1 && players.some(p => p.isAI);
      }, [players]);

      // Weekly time-limited challenge state - synced via Firebase, resets weekly
      const [weeklyChallenge, setWeeklyChallenge] = useState(() => {
        const currentWeek = getCurrentWeekNumber();
        try {
          const saved = localStorage.getItem('quikdarts_weekly_challenge');
          if (saved) {
            const parsed = JSON.parse(saved);
            // Validate data structure and check if it's from the current week
            if (isValidWeeklyChallengeData(parsed) && parsed.weekNumber === currentWeek) {
              return parsed;
            }
          }
        } catch (error) {
          console.error('Failed to load weekly challenge:', error);
        }
        return createDefaultWeeklyChallengeData(currentWeek);
      });

      // Time remaining until weekly reset
      const [timeUntilReset, setTimeUntilReset] = useState(getTimeUntilWeeklyReset());

      // Daily challenges state - resets at midnight each day
      const [dailyChallengeData, setDailyChallengeData] = useState(() => {
        const today = getTodayString();
        try {
          const saved = localStorage.getItem('quikdarts_daily_challenges');
          if (saved) {
            const parsed = JSON.parse(saved);
            // Validate data structure and check if it's from today
            if (isValidDailyChallengeData(parsed) && parsed.date === today) {
              return parsed;
            }
          }
        } catch (error) {
          console.error('Failed to load daily challenges:', error);
        }
        return createDefaultDailyChallengeData(today);
      });

      // Dartboard theme customization state
      const [selectedThemeId, setSelectedThemeId] = useState(() => {
        try {
          const saved = localStorage.getItem('quikdarts_theme');
          if (saved) {
            const parsed = JSON.parse(saved);
            // Validate the saved theme ID
            if (isValidThemeId(parsed.themeId)) {
              return parsed.themeId;
            }
          }
          return DEFAULT_THEME_ID;
        } catch (error) {
          console.error('Failed to load theme from localStorage:', error);
          return DEFAULT_THEME_ID;
        }
      });

      const [selectedNeonColor, setSelectedNeonColor] = useState(() => {
        try {
          const saved = localStorage.getItem('quikdarts_theme');
          if (saved) {
            const parsed = JSON.parse(saved);
            if (parsed.neonColor && Object.values(NEON_COLOR_OPTIONS).includes(parsed.neonColor)) {
              return parsed.neonColor;
            }
          }
          return NEON_COLOR_OPTIONS.CYAN;
        } catch (error) {
          console.error('Failed to load neon color from localStorage:', error);
          return NEON_COLOR_OPTIONS.CYAN;
        }
      });

      const [neonPulsePhase, setNeonPulsePhase] = useState(0); // For neon pulse animation

      // Save theme selection to localStorage
      const saveThemeSelection = useCallback((themeId, neonColor) => {
        try {
          const themeData = {
            themeId: themeId,
            neonColor: neonColor,
            savedAt: new Date().toISOString()
          };
          localStorage.setItem('quikdarts_theme', JSON.stringify(themeData));
        } catch (error) {
          console.error('Failed to save theme to localStorage:', error);
        }
      }, []);

      // Update theme selection handler
      const handleThemeChange = useCallback((themeId) => {
        if (isValidThemeId(themeId)) {
          setSelectedThemeId(themeId);
          saveThemeSelection(themeId, selectedNeonColor);
        }
      }, [selectedNeonColor, saveThemeSelection]);

      // Update neon color selection handler
      const handleNeonColorChange = useCallback((neonColor) => {
        if (Object.values(NEON_COLOR_OPTIONS).includes(neonColor)) {
          setSelectedNeonColor(neonColor);
          saveThemeSelection(selectedThemeId, neonColor);
        }
      }, [selectedThemeId, saveThemeSelection]);

      // Get current theme and colors
      const currentTheme = getThemeById(selectedThemeId);
      const currentThemeColors = getThemeColors(currentTheme, selectedNeonColor);

      // Neon pulse animation effect
      useEffect(() => {
        if (currentTheme.effects.pulseAnimation) {
          const interval = setInterval(() => {
            setNeonPulsePhase(prev => (prev + 0.05) % (2 * Math.PI));
          }, 50);
          return () => clearInterval(interval);
        }
      }, [currentTheme.effects.pulseAnimation]);

      // Mobile detection resize listener
      useEffect(() => {
        const handleResize = () => {
          const isSmallScreen = window.innerWidth < 600;
          const hasTouchScreen = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
          const isMobileUA = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
          setIsMobile(isSmallScreen || (hasTouchScreen && isMobileUA));
        };
        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
      }, []);

      // Stage timing: 'found' ‚Üí 'intro' (wagered) or start game (casual)
      useEffect(() => {
        if (matchmakingState !== 'found' || !pendingGameInfo) return;

        // Respect reduced motion preference
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        const delay = prefersReducedMotion ? 0 : MATCHMAKING_TIMINGS.FOUND_TO_INTRO_DELAY_MS;

        const timer = setTimeout(() => {
          if (isWageredMatch) {
            // Wagered: show VS intro screen
            setMatchmakingState('intro');
          } else {
            // Casual: start game directly
            startOnlineGame(pendingGameInfo.roomId, pendingGameInfo.playerIndex);
            setPendingGameInfo(null);
          }
        }, delay);

        return () => clearTimeout(timer);
      }, [matchmakingState, pendingGameInfo, isWageredMatch]);

      // Stage timing: 'intro' ‚Üí start game after VS intro
      useEffect(() => {
        if (matchmakingState !== 'intro' || !pendingGameInfo) return;

        // Respect reduced motion preference - skip intro for users who prefer reduced motion
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        const delay = prefersReducedMotion ? 0 : MATCHMAKING_TIMINGS.INTRO_DURATION_MS;

        const timer = setTimeout(() => {
          startOnlineGame(pendingGameInfo.roomId, pendingGameInfo.playerIndex);
          setPendingGameInfo(null);
        }, delay);

        return () => clearTimeout(timer);
      }, [matchmakingState, pendingGameInfo]);

      const boardRef = useRef(null);
      const powerIntervalRef = useRef(null);
      const powerResetTimeoutRef = useRef(null);
      const matchmakingIntervalRef = useRef(null);
      const wageredListenerRef = useRef(null); // Stores wagered matchmaking listener for cleanup
      const audioContext = useRef(null);
      const aimPositionRef = useRef({ x: CENTER, y: CENTER });

      const playSound = useCallback((type) => {
        if (!soundEnabled) return;
        if (!audioContext.current) {
          audioContext.current = new (window.AudioContext || window.webkitAudioContext)();
        }
        const ctx = audioContext.current;
        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(ctx.destination);
        
        switch(type) {
          case 'throw':
            oscillator.frequency.setValueAtTime(200, ctx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.1);
            gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + 0.1);
            break;
          case 'hit':
            oscillator.frequency.setValueAtTime(800, ctx.currentTime);
            gainNode.gain.setValueAtTime(0.2, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.05);
            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + 0.05);
            break;
          case 'bullseye':
            oscillator.frequency.setValueAtTime(523, ctx.currentTime);
            oscillator.frequency.setValueAtTime(659, ctx.currentTime + 0.1);
            oscillator.frequency.setValueAtTime(784, ctx.currentTime + 0.2);
            gainNode.gain.setValueAtTime(0.3, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + 0.3);
            break;
          case 'bust':
            oscillator.frequency.setValueAtTime(200, ctx.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.3);
            gainNode.gain.setValueAtTime(0.4, ctx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
            oscillator.start(ctx.currentTime);
            oscillator.stop(ctx.currentTime + 0.3);
            break;
          case 'win':
            [523, 659, 784, 1047].forEach((freq, i) => {
              const osc = ctx.createOscillator();
              const gain = ctx.createGain();
              osc.connect(gain);
              gain.connect(ctx.destination);
              osc.frequency.setValueAtTime(freq, ctx.currentTime + i * 0.15);
              gain.gain.setValueAtTime(0.3, ctx.currentTime + i * 0.15);
              gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.15 + 0.2);
              osc.start(ctx.currentTime + i * 0.15);
              osc.stop(ctx.currentTime + i * 0.15 + 0.2);
            });
            break;
          case '180':
            // Exciting ascending celebration sound for 180!
            [392, 523, 659, 784, 1047, 1319].forEach((freq, i) => {
              const osc = ctx.createOscillator();
              const gain = ctx.createGain();
              osc.connect(gain);
              gain.connect(ctx.destination);
              osc.frequency.setValueAtTime(freq, ctx.currentTime + i * 0.08);
              gain.gain.setValueAtTime(0.4, ctx.currentTime + i * 0.08);
              gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.08 + 0.15);
              osc.start(ctx.currentTime + i * 0.08);
              osc.stop(ctx.currentTime + i * 0.08 + 0.15);
            });
            break;
          case 'ninedarter':
            // Epic crowd roar effect
            // Create white noise for crowd roar
            const bufferSize = ctx.sampleRate * 3; // 3 seconds
            const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
              data[i] = Math.random() * 2 - 1;
            }
            const crowdNoise = ctx.createBufferSource();
            crowdNoise.buffer = buffer;

            const crowdFilter = ctx.createBiquadFilter();
            crowdFilter.type = 'bandpass';
            crowdFilter.frequency.setValueAtTime(800, ctx.currentTime);
            crowdFilter.Q.setValueAtTime(1, ctx.currentTime);

            const crowdGain = ctx.createGain();
            crowdGain.gain.setValueAtTime(0, ctx.currentTime);
            crowdGain.gain.linearRampToValueAtTime(0.3, ctx.currentTime + 0.5);
            crowdGain.gain.setValueAtTime(0.3, ctx.currentTime + 2);
            crowdGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 3);

            crowdNoise.connect(crowdFilter);
            crowdFilter.connect(crowdGain);
            crowdGain.connect(ctx.destination);
            crowdNoise.start(ctx.currentTime);
            crowdNoise.stop(ctx.currentTime + 3);

            // Add epic fanfare over the crowd roar
            [523, 659, 784, 1047, 1319, 1568].forEach((freq, i) => {
              const osc = ctx.createOscillator();
              const gain = ctx.createGain();
              osc.type = 'triangle';
              osc.connect(gain);
              gain.connect(ctx.destination);
              osc.frequency.setValueAtTime(freq, ctx.currentTime + i * 0.15);
              gain.gain.setValueAtTime(0.25, ctx.currentTime + i * 0.15);
              gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + i * 0.15 + 0.4);
              osc.start(ctx.currentTime + i * 0.15);
              osc.stop(ctx.currentTime + i * 0.15 + 0.4);
            });
            break;
        }
      }, [soundEnabled]);

      // ========== ONLINE MULTIPLAYER FUNCTIONS ==========

      // Whitelist-based sanitization for player names
      // Only allows safe characters - much more secure than blacklist approach
      const sanitizeName = (name) => {
        if (!name || typeof name !== 'string') return 'Player';
        return name
          .slice(0, 20)                                    // Limit length first
          .replace(/[^a-zA-Z0-9\s\-_.!?]/g, '')           // Whitelist: only letters, numbers, spaces, -_.!?
          .replace(/\s+/g, ' ')                            // Collapse multiple spaces
          .trim() || 'Player';
      };

      // Sanitize flag emoji - validates it's a proper emoji and limits length
      const sanitizeFlag = (flag) => {
        if (!flag || typeof flag !== 'string') return 'üåç';
        // Flag emojis can be up to 28 bytes (regional indicator pairs or flag sequences)
        // Limit to 50 characters to allow for complex emojis while preventing abuse
        const trimmed = flag.slice(0, 50);
        // Basic validation: must contain at least one emoji-like character
        // Regional indicators are in range U+1F1E6 to U+1F1FF, flags use U+1F3F4
        const hasEmoji = /[\u{1F1E6}-\u{1F1FF}]|[\u{1F3F4}]|[\u{1F300}-\u{1F9FF}]/u.test(trimmed);
        return hasEmoji ? trimmed : 'üåç';
      };

      // Sanitize avatar URL - whitelist approach for security
      // SECURITY: Prevents XSS via javascript: URLs and SSRF via internal URLs
      const sanitizeAvatarUrl = (url) => {
        if (!url || typeof url !== 'string') return null;
        if (url.length > 500) return null; // Max length

        try {
          const parsed = new URL(url);

          // CRITICAL: Only allow HTTPS
          if (parsed.protocol !== 'https:') {
            console.warn('[Security] Rejected non-HTTPS avatar URL');
            return null;
          }

          // Whitelist trusted domains only
          const allowedHosts = [
            'firebasestorage.googleapis.com',
            'lh3.googleusercontent.com',        // Google profile pics
            'storage.googleapis.com'
          ];

          if (!allowedHosts.some(h => parsed.host === h || parsed.host.endsWith('.' + h))) {
            console.warn('[Security] Rejected untrusted avatar domain:', parsed.host);
            return null;
          }

          return url;
        } catch (e) {
          console.warn('[Security] Invalid avatar URL:', e.message);
          return null;
        }
      };

      // Sanitize level - validates it's a reasonable number
      const sanitizeLevel = (level) => {
        const num = parseInt(level, 10);
        if (isNaN(num) || num < 1) return 1;
        if (num > 999) return 999;
        return num;
      };

      // Save nickname/display name to Firebase
      const saveNickname = useCallback(async () => {
        if (!currentUser || currentUser.isAnonymous || !database) return;

        const sanitized = sanitizeName(nicknameInput);
        if (!sanitized || sanitized.length < 1 || sanitized === 'Player') {
          alert('Please enter a valid nickname (1-20 characters)');
          return;
        }

        try {
          // Use update() to preserve other profile fields while changing displayName
          // Firebase rules validate the entire profile, so we need to include existing fields
          const profileUpdate = {
            displayName: sanitized
          };
          // Include existing flag if present to satisfy validation
          if (userProfile?.flag) {
            profileUpdate.flag = userProfile.flag;
          }
          if (userProfile?.uniqueId) {
            profileUpdate.uniqueId = userProfile.uniqueId;
          }
          if (userProfile?.avatar) {
            profileUpdate.avatar = userProfile.avatar;
          }
          if (userProfile?.createdAt) {
            profileUpdate.createdAt = userProfile.createdAt;
          }
          if (userProfile?.provider) {
            profileUpdate.provider = userProfile.provider;
          }

          await database.ref(`users/${currentUser.uid}/profile`).set(profileUpdate);
          setIsEditingNickname(false);
          setNicknameInput('');
          // userProfile will auto-update via the existing Firebase listener
        } catch (error) {
          console.error('Failed to save nickname:', error);
          alert('Failed to save nickname. Please try again.');
        }
      }, [currentUser, database, nicknameInput, userProfile]);

      // Validate numeric values from Firebase to prevent data tampering
      const validateScore = (score, gameMode) => {
        if (typeof score !== 'number' || !Number.isInteger(score)) return gameMode || 501;
        if (score < 0 || score > 501 || score === 1) return gameMode || 501;
        return score;
      };

      const validatePlayerIndex = (index) => {
        if (typeof index !== 'number' || !Number.isInteger(index)) return 0;
        return index === 0 || index === 1 ? index : 0;
      };

      const validateDartsThrown = (darts) => {
        if (typeof darts !== 'number' || !Number.isInteger(darts)) return 0;
        return darts >= 0 && darts <= 3 ? darts : 0;
      };

      const validateTurnScore = (score) => {
        if (typeof score !== 'number' || !Number.isInteger(score)) return 0;
        return score >= 0 && score <= 180 ? score : 0;
      };

      const validateScoreArray = (arr, defaultValue = 0) => {
        if (!Array.isArray(arr) || arr.length !== 2) return [defaultValue, defaultValue];
        return arr.map(val => {
          if (typeof val !== 'number' || !Number.isInteger(val) || val < 0) return defaultValue;
          return val;
        });
      };

      // Validate throw history item from Firebase
      const validateThrowItem = (item) => {
        if (!item || typeof item !== 'object') return null;
        const score = typeof item.score === 'number' && item.score >= 0 && item.score <= 180 ? item.score : 0;
        // Sanitize label: only allow A-Z, 0-9, ! (valid labels are like "T20", "D19", "BULL", "MISS", "180!!!")
        const rawLabel = typeof item.label === 'string' ? item.label : '';
        const label = rawLabel.replace(/[^A-Z0-9!]/gi, '').slice(0, 10) || 'MISS';
        const player = (item.player === 0 || item.player === 1) ? item.player : 0;
        const multiplier = typeof item.multiplier === 'number' && item.multiplier >= 0 && item.multiplier <= 3 ? item.multiplier : 1;
        return { score, label, player, multiplier };
      };

      // Validate dart position from Firebase
      const validateDartPosition = (pos) => {
        if (!pos || typeof pos !== 'object') return null;
        const x = typeof pos.x === 'number' && pos.x >= 0 && pos.x <= 500 ? pos.x : 250;
        const y = typeof pos.y === 'number' && pos.y >= 0 && pos.y <= 500 ? pos.y : 250;
        return { x, y };
      };

      // Retry wrapper for Firebase operations with exponential backoff
      const retryFirebaseOperation = async (operation, maxRetries = 3) => {
        let lastError;
        for (let attempt = 0; attempt < maxRetries; attempt++) {
          try {
            return await operation();
          } catch (error) {
            lastError = error;
            if (attempt < maxRetries - 1) {
              // Exponential backoff: 100ms, 200ms, 400ms
              await new Promise(resolve => setTimeout(resolve, 100 * Math.pow(2, attempt)));
            }
          }
        }
        throw lastError;
      };

      // Start matchmaking - find a random opponent
      const startMatchmaking = useCallback(async () => {
        if (!database) {
          alert('Firebase not configured. Please add your Firebase credentials to play online.');
          return;
        }

        // Rate limiting: Prevent spamming matchmaking button
        if (matchmakingState === 'searching') {
          return; // Already searching
        }

        setMatchmakingState('searching');
        setOnlineMode(true);
        const queueRef = database.ref('matchmaking_queue/casual');
        // Note: gamesRef removed - we no longer query /games directly (permission denied)
        // Instead we notify opponent via matchedGameId in their queue entry

        // Wait for authentication and use auth UID as player ID
        const authUser = await authReadyPromise;
        if (!authUser) {
          console.error('Authentication required for online play');
          setMatchmakingState('idle');
          setOnlineMode(false);
          return;
        }

        // Use authenticated user ID (prevents spoofing/spam)
        const myPlayerId = authUser.uid;
        setMyAuthId(myPlayerId);

        // SECURITY: Game cleanup is handled by onDisconnect handlers and server-side
        // logic. We no longer enumerate all games to prevent data leakage.
        // Stale games are cleaned up via the cleanupExpiredEscrows scheduled function
        // and onDisconnect handlers set up when joining a game.

        // Small delay to avoid race condition where both players check queue at exact same time
        setTimeout(() => {
          // Look for available opponent in queue
          queueRef.orderByChild('timestamp').limitToFirst(1).once('value', async (snapshot) => {
          if (snapshot.exists()) {
            // Found an opponent - join their game
            const opponentId = Object.keys(snapshot.val())[0];
            const opponentData = snapshot.val()[opponentId];

            // Make sure we're not matching with ourselves
            if (opponentData.playerId === myPlayerId) {
              // This shouldn't happen, but if it does, add ourselves to queue instead
              const myQueueEntry = {
                playerId: myPlayerId,
                name: sanitizeName(userProfile?.displayName || currentUser?.displayName) || 'Player',
                flag: sanitizeFlag(userProfile?.flag) || 'üåç',
                level: userProgression?.level || 1,
                avatarUrl: sanitizeAvatarUrl(userProfile?.avatar) || null,
                timestamp: firebase.database.ServerValue.TIMESTAMP
              };
              queueRef.child(myPlayerId).set(myQueueEntry);
              return;
            }

            // Note: Opponent will remove themselves from queue when they find the game
            // (we can't remove their entry due to auth rules)

            // Create game room via Cloud Function (server-authoritative)
            if (!functions) {
              console.error('Cloud Functions not available');
              alert('Online play is temporarily unavailable. Please try again later.');
              cancelMatchmaking();
              return;
            }

            try {
              const createGameFn = functions.httpsCallable('createGame');
              const result = await createGameFn({
                player1Id: opponentData.playerId,
                player1Name: sanitizeName(opponentData.name),
                player1Flag: sanitizeFlag(opponentData.flag),
                player2Id: myPlayerId,
                player2Name: sanitizeName(userProfile?.displayName || currentUser?.displayName) || 'Player',
                player2Flag: sanitizeFlag(userProfile?.flag) || 'üåç',
                gameMode: playerSetup.gameMode,
                isWagered: false
              });

              if (!result.data.success || !result.data.gameId) {
                console.error('Failed to create game:', result.data.error);
                alert('Failed to create game. Please try again.');
                cancelMatchmaking();
                return;
              }

              const roomId = result.data.gameId;
              setGameRoomId(roomId);
              gameRoomRef.current = database.ref(`games/${roomId}`);

              // Notify opponent by updating their queue entry with matchedGameId
              // This allows them to find the game without querying /games
              await queueRef.child(opponentData.playerId).update({
                matchedGameId: roomId,
                matchedByName: sanitizeName(userProfile?.displayName || currentUser?.displayName) || 'Player',
                matchedByFlag: sanitizeFlag(userProfile?.flag) || 'üåç'
              });

              // IMPORTANT: Register onDisconnect FIRST to protect against early browser close
              // This ensures if player closes browser during "opponent found" screen, Firebase sets connected=false
              gameRoomRef.current.child('player2/connected').onDisconnect().set(false).then(() => {
                // Start heartbeat for disconnect detection (I'm player2, opponent is player1)
                startHeartbeat(gameRoomRef.current, 'player2', 'player1', () => {
                  stopHeartbeat();
                  alert('Opponent disconnected. Returning to menu.');
                  cancelMatchmaking();
                });

                setOpponentName(sanitizeName(opponentData.name));
                setOpponentFlag(sanitizeFlag(opponentData.flag));
                setOpponentLevel(sanitizeLevel(opponentData.level));
                setOpponentAvatar(sanitizeAvatarUrl(opponentData.avatarUrl));
                setPendingGameInfo({ roomId, playerIndex: 1 });
                setMatchmakingState('found');
              }).catch((err) => {
                console.error('[matchmaking] Failed to register onDisconnect:', err);
                // Still proceed - better than blocking entirely
                setOpponentName(sanitizeName(opponentData.name));
                setOpponentFlag(sanitizeFlag(opponentData.flag));
                setOpponentLevel(sanitizeLevel(opponentData.level));
                setOpponentAvatar(sanitizeAvatarUrl(opponentData.avatarUrl));
                setPendingGameInfo({ roomId, playerIndex: 1 });
                setMatchmakingState('found');
              });
            } catch (error) {
              console.error('Error creating game:', error);
              alert('Failed to create game. Please try again.');
              cancelMatchmaking();
              return;
            }

          } else {
            // No opponent found - add self to queue with profile name
            const myQueueEntry = {
              playerId: myPlayerId,
              name: sanitizeName(userProfile?.displayName || currentUser?.displayName) || 'Player',
              flag: sanitizeFlag(userProfile?.flag) || 'üåç',
              level: userProgression?.level || 1,
              avatarUrl: sanitizeAvatarUrl(userProfile?.avatar) || null,
              timestamp: firebase.database.ServerValue.TIMESTAMP
            };

            queueRef.child(myPlayerId).set(myQueueEntry);

            // Auto-remove from queue if user disconnects (closes browser, loses connection, etc.)
            queueRef.child(myPlayerId).onDisconnect().remove();

            // Store ref for cleanup
            const myQueueEntryRef = queueRef.child(myPlayerId);
            let isProcessingMatch = false;

            // Listen for matchedGameId (when someone creates a game with us as player1)
            const queueEntryListener = myQueueEntryRef.on('value', async (snapshot) => {
              if (isProcessingMatch) return;
              if (!snapshot.exists()) return;

              const myEntry = snapshot.val();

              // Check if someone matched with us (they wrote matchedGameId to our queue entry)
              if (myEntry.matchedGameId) {
                console.log('[casualMatchmaking] Found matchedGameId in queue entry:', myEntry.matchedGameId);
                isProcessingMatch = true;

                const roomId = myEntry.matchedGameId;
                const opponentName = myEntry.matchedByName || 'Opponent';
                const opponentFlag = myEntry.matchedByFlag || 'üåç';

                // Clean up listener and interval
                myQueueEntryRef.off('value', queueEntryListener);
                if (matchmakingIntervalRef.current) {
                  clearInterval(matchmakingIntervalRef.current);
                  matchmakingIntervalRef.current = null;
                }
                await myQueueEntryRef.remove();

                setGameRoomId(roomId);
                gameRoomRef.current = database.ref(`games/${roomId}`);

                // Validate game exists and we're a player
                let gameData;
                try {
                  const gameSnap = await gameRoomRef.current.once('value');
                  gameData = gameSnap.val();
                } catch (readErr) {
                  console.error('[casualMatchmaking] Failed to read game:', readErr);
                  isProcessingMatch = false;
                  return;
                }

                if (!gameData || gameData.player1?.id !== myPlayerId) {
                  console.error('[casualMatchmaking] Invalid game data - ignoring');
                  isProcessingMatch = false;
                  return;
                }

                // IMPORTANT: Register onDisconnect FIRST
                gameRoomRef.current.child('player1/connected').onDisconnect().set(false).then(() => {
                  gameRoomRef.current.child('player1/connected').set(true);
                  opponentWasConnected.current = true;

                  startHeartbeat(gameRoomRef.current, 'player1', 'player2', () => {
                    stopHeartbeat();
                    alert('Opponent disconnected. Returning to menu.');
                    // Game cleanup handled server-side
                    cancelMatchmaking();
                  });

                  setOpponentName(sanitizeName(opponentName));
                  setOpponentFlag(sanitizeFlag(opponentFlag));
                  setOpponentLevel(sanitizeLevel(gameData.player2?.level));
                  setOpponentAvatar(sanitizeAvatarUrl(gameData.player2?.avatarUrl));
                  setPendingGameInfo({ roomId, playerIndex: 0 });
                  setMatchmakingState('found');
                }).catch((err) => {
                  console.error('[casualMatchmaking] Failed to register onDisconnect:', err);
                  setOpponentName(sanitizeName(opponentName));
                  setOpponentFlag(sanitizeFlag(opponentFlag));
                  setOpponentLevel(sanitizeLevel(gameData.player2?.level));
                  setOpponentAvatar(sanitizeAvatarUrl(gameData.player2?.avatarUrl));
                  setPendingGameInfo({ roomId, playerIndex: 0 });
                  setMatchmakingState('found');
                });
              }
            });

            // Also periodically check if there are OTHER players in queue we can join
            matchmakingIntervalRef.current = setInterval(() => {
              if (isProcessingMatch) return;

              queueRef.orderByChild('timestamp').limitToFirst(2).once('value', async (queueSnapshot) => {
                if (isProcessingMatch) return;
                if (!queueSnapshot.exists()) return;

                const queuePlayers = queueSnapshot.val();
                // Find first player that isn't us and doesn't already have a match
                const otherPlayerId = Object.keys(queuePlayers).find(id =>
                  id !== myPlayerId && !queuePlayers[id].matchedGameId
                );

                if (otherPlayerId) {
                  const otherPlayer = queuePlayers[otherPlayerId];
                  isProcessingMatch = true;

                  // Clean up listener and interval
                  myQueueEntryRef.off('value', queueEntryListener);
                  if (matchmakingIntervalRef.current) {
                    clearInterval(matchmakingIntervalRef.current);
                    matchmakingIntervalRef.current = null;
                  }

                  // Remove myself from queue
                  queueRef.child(myPlayerId).remove();

                  if (!functions) {
                    console.error('Cloud Functions not available');
                    isProcessingMatch = false;
                    return;
                  }

                  try {
                    const createGameFn = functions.httpsCallable('createGame');
                    const result = await createGameFn({
                      player1Id: otherPlayer.playerId,
                      player1Name: sanitizeName(otherPlayer.name),
                      player1Flag: sanitizeFlag(otherPlayer.flag),
                      player2Id: myPlayerId,
                      player2Name: sanitizeName(userProfile?.displayName || currentUser?.displayName) || 'Player',
                      player2Flag: sanitizeFlag(userProfile?.flag) || 'üåç',
                      gameMode: playerSetup.gameMode,
                      isWagered: false
                    });

                    if (!result.data.success || !result.data.gameId) {
                      console.error('Failed to create game:', result.data.error);
                      isProcessingMatch = false;
                      return;
                    }

                    const roomId = result.data.gameId;

                    // Notify opponent by updating their queue entry with matchedGameId
                    await queueRef.child(otherPlayer.playerId).update({
                      matchedGameId: roomId,
                      matchedByName: sanitizeName(userProfile?.displayName || currentUser?.displayName) || 'Player',
                      matchedByFlag: sanitizeFlag(userProfile?.flag) || 'üåç'
                    });

                    setGameRoomId(roomId);
                    gameRoomRef.current = database.ref(`games/${roomId}`);

                    gameRoomRef.current.child('player2/connected').onDisconnect().set(false).then(() => {
                      startHeartbeat(gameRoomRef.current, 'player2', 'player1', () => {
                        stopHeartbeat();
                        alert('Opponent disconnected. Returning to menu.');
                        cancelMatchmaking();
                      });

                      setOpponentName(sanitizeName(otherPlayer.name));
                      setOpponentFlag(sanitizeFlag(otherPlayer.flag));
                      setOpponentLevel(sanitizeLevel(otherPlayer.level));
                      setOpponentAvatar(sanitizeAvatarUrl(otherPlayer.avatarUrl));
                      setPendingGameInfo({ roomId, playerIndex: 1 });
                      setMatchmakingState('found');
                    });
                  } catch (error) {
                    console.error('Error creating game:', error);
                    isProcessingMatch = false;
                  }
                }
              });
            }, 2000);

            // Timeout after 60 seconds
            setTimeout(() => {
              if (matchmakingState === 'searching') {
                if (matchmakingIntervalRef.current) {
                  clearInterval(matchmakingIntervalRef.current);
                  matchmakingIntervalRef.current = null;
                }
                queueRef.child(myPlayerId).remove();
                cancelMatchmaking();
                alert('No opponent found. Please try again.');
              }
            }, 60000);
          }
        });
        }, 500); // 500ms delay to avoid race condition
      }, [database, playerSetup, matchmakingState]);

      // Start heartbeat for disconnect detection
      const startHeartbeat = useCallback((roomRef, myKey, opponentKey, onDisconnect) => {
        // Clear any existing heartbeat
        if (heartbeatIntervalRef.current) {
          clearInterval(heartbeatIntervalRef.current);
        }

        myPlayerKeyRef.current = myKey;
        const heartbeatStartTime = Date.now();

        // Send initial heartbeat
        roomRef.child(`${myKey}/lastHeartbeat`).set(Date.now());

        // Send heartbeat every 3 seconds and check opponent's heartbeat
        heartbeatIntervalRef.current = setInterval(() => {
          if (!roomRef) return;

          // Update my heartbeat
          roomRef.child(`${myKey}/lastHeartbeat`).set(Date.now()).catch(() => {});

          // Check opponent's heartbeat
          roomRef.child(`${opponentKey}/lastHeartbeat`).once('value', (snapshot) => {
            const opponentHeartbeat = snapshot.val();
            const now = Date.now();

            if (opponentHeartbeat) {
              // Opponent has sent heartbeats - check if recent
              const timeSinceHeartbeat = now - opponentHeartbeat;
              if (timeSinceHeartbeat > 15000) {
                onDisconnect();
              }
            } else {
              // Opponent has NEVER sent a heartbeat
              // If we've been waiting more than 10 seconds, they're not coming
              const timeSinceStart = now - heartbeatStartTime;
              if (timeSinceStart > 10000) {
                onDisconnect();
              }
            }
          });
        }, 3000);
      }, []);

      // Stop heartbeat
      const stopHeartbeat = useCallback(() => {
        if (heartbeatIntervalRef.current) {
          clearInterval(heartbeatIntervalRef.current);
          heartbeatIntervalRef.current = null;
        }
      }, []);

      // Start the online game
      const startOnlineGame = useCallback((roomId, playerIndex) => {
        setMatchmakingState('playing');
        setGameState('playing');
        setPlayerId(playerIndex);

        // Cleanup any existing listener first (prevent memory leak)
        if (gameRoomRef.current) {
          gameRoomRef.current.off();
          gameRoomRef.current = null;
        }

        // Clear early disconnect listener ref (listener already cleaned up by .off() above)
        earlyDisconnectListenerRef.current = null;

        // Initialize game state for online mode
        setWinner(null);
        setMatchWinner(null);
        setTriplesHit(0);
        setIsCheckoutPosition(false);
        setCurrentTurnThrows([]);
        setGameStats({});
        setLegDartsThrown([0, 0]);
        // NOTE: Don't reset opponentWasConnected here - it was set during matchmaking
        // and needs to persist to detect disconnects that happen during the transition

        // Listen for game state changes
        const roomRef = database.ref(`games/${roomId}`);
        gameRoomRef.current = roomRef;

        // Set my presence as connected
        const myPlayerKey = playerIndex === 0 ? 'player1' : 'player2';
        roomRef.child(`${myPlayerKey}/connected`).set(true);

        // Auto-disconnect presence when I leave
        roomRef.child(`${myPlayerKey}/connected`).onDisconnect().set(false);

        roomRef.on('value', (snapshot) => {
          const gameData = snapshot.val();
          // Validate game state completeness before processing
          // Prevents race conditions where partial data is read before game is fully initialized
          if (!gameData || !gameData.player1 || !gameData.player2 || !gameData.gameMode) {
            console.log('[gameListener] Waiting for complete game data...');
            return;
          }

          // Log game state updates for debugging
          console.log('[gameListener] Update received:', {
            p1Score: gameData.player1?.score,
            p2Score: gameData.player2?.score,
            currentPlayer: gameData.currentPlayer,
            dartsThrown: gameData.dartsThrown,
            status: gameData.status
          });

          // Update local game state from Firebase
          const myPlayer = playerIndex === 0 ? gameData.player1 : gameData.player2;
          const opponent = playerIndex === 0 ? gameData.player2 : gameData.player1;

          // Track if opponent was ever connected
          if (opponent.connected === true) {
            opponentWasConnected.current = true;
          }

          // Only alert about disconnection if opponent WAS connected before
          if (opponentWasConnected.current && opponent.connected === false && !gameData.winner) {
            opponentWasConnected.current = false; // Reset for next game
            console.log('[gameListener] Opponent disconnected! Processing disconnect...', {
              roomId,
              hasWager: !!gameData.wager,
              isWageredMatchState: isWageredMatch
            });

            // For wagered matches, the remaining player wins by forfeit
            // IMPORTANT: Check gameData.wager from Firebase (more reliable than closure state)
            // and use roomId parameter (not gameRoomId which might be stale)
            const isWagered = !!(gameData.wager && gameData.wager.escrowId);
            if (isWagered && roomId && functions) {
              console.log('[gameListener] Opponent disconnected in wagered match - claiming forfeit win');
              const forfeitGameFn = functions.httpsCallable('forfeitGame');
              forfeitGameFn({ gameId: roomId, reason: 'disconnect', claimWin: true })
                .then(result => {
                  console.log('[forfeitGame] Result:', result.data);
                  if (result.data.success) {
                    const payout = result.data.winnerPayout || 0;
                    alert(`${sanitizeName(opponent.name)} has disconnected. You win ${payout} coins!`);
                    // Update coin balance with winnings
                    if (payout > 0) {
                      setCoinBalance(prev => prev + payout);
                    }
                  } else {
                    alert(`${sanitizeName(opponent.name)} has disconnected. Returning to menu.`);
                  }
                  // Clear escrow state
                  setCurrentEscrowId(null);
                  setIsWageredMatch(false);
                  setEscrowData(null);
                })
                .catch(err => {
                  console.error('[forfeitGame] Error:', err);
                  alert(`${sanitizeName(opponent.name)} has disconnected. Returning to menu.`);
                });
            } else {
              alert(`${sanitizeName(opponent.name)} has disconnected. Returning to menu.`);
            }

            // Game cleanup handled server-side by forfeitGame Cloud Function
            cancelMatchmaking();
            return;
          }

          // Sanitize and validate all player data received from Firebase for security
          const validatedGameMode = gameData.gameMode === 301 || gameData.gameMode === 501 ? gameData.gameMode : 501;
          setPlayers([
            {
              uid: gameData.player1.id,
              name: sanitizeName(gameData.player1.name),
              flag: sanitizeFlag(gameData.player1.flag),
              score: validateScore(gameData.player1.score, validatedGameMode),
              level: sanitizeLevel(gameData.player1.level) || 1,
              avatarUrl: sanitizeAvatarUrl(gameData.player1.avatarUrl) || null,
              isAI: false
            },
            {
              uid: gameData.player2.id,
              name: sanitizeName(gameData.player2.name),
              flag: sanitizeFlag(gameData.player2.flag),
              score: validateScore(gameData.player2.score, validatedGameMode),
              level: sanitizeLevel(gameData.player2.level) || 1,
              avatarUrl: sanitizeAvatarUrl(gameData.player2.avatarUrl) || null,
              isAI: false
            }
          ]);

          // Fetch escrow data for wagered match header
          if (gameData.wager?.escrowId && !escrowData) {
            database.ref(`escrow/${gameData.wager.escrowId}`).once('value', (snap) => {
              if (snap.exists()) {
                setEscrowData(snap.val());
              }
            });
          }

          setCurrentPlayerIndex(validatePlayerIndex(gameData.currentPlayer));
          setDartsThrown(validateDartsThrown(gameData.dartsThrown));
          setCurrentTurnScore(validateTurnScore(gameData.currentTurnScore));

          // Convert and validate throwHistory from Firebase object to array
          const throwsArray = gameData.throwHistory
            ? Object.values(gameData.throwHistory).map(validateThrowItem).filter(Boolean)
            : [];
          setThrowHistory(throwsArray);

          // Convert and validate dartPositions from Firebase object to array
          const dartsArray = gameData.dartPositions
            ? Object.values(gameData.dartPositions).map(validateDartPosition).filter(Boolean)
            : [];
          setDartPositions(dartsArray);

          setLegScores(validateScoreArray(gameData.legScores, 0));
          setSetScores(validateScoreArray(gameData.setScores, 0));

          // Check for winner (game ended)
          if (gameData.winner !== undefined && gameData.status === 'finished') {
            const winnerIndex = validatePlayerIndex(gameData.winner);
            const isWinner = winnerIndex === playerIndex;
            const winnerPlayer = isWinner ? myPlayer : opponent;

            console.log('[gameListener] Game finished! Winner:', winnerIndex, 'isWinner:', isWinner);

            // Set winner state
            setWinner(winnerPlayer);
            setMatchWinner(winnerPlayer);

            // Play win/lose sound
            if (isWinner) {
              playSound('win');
            }

            // For wagered matches, settle the game (release escrow to winner)
            // IMPORTANT: Check gameData.wager from Firebase (more reliable than closure state)
            // and use roomId parameter (not gameRoomId which might be stale)
            const hasWager = !!(gameData.wager && gameData.wager.escrowId);
            if (hasWager && roomId && functions) {
              console.log('[settleGame] Settling wagered match from listener:', roomId, 'escrowId:', gameData.wager.escrowId);
              const settleGameFn = functions.httpsCallable('settleGame');
              settleGameFn({ gameId: roomId })
                .then(result => {
                  console.log('[settleGame] Result:', result.data);
                  if (result.data.success && result.data.payout > 0 && isWinner) {
                    alert(`Congratulations! You won ${result.data.payout} coins!`);
                    // Update coin balance with winnings
                    setCoinBalance(prev => prev + result.data.payout);
                  }
                  // Clear escrow state
                  setCurrentEscrowId(null);
                  setIsWageredMatch(false);
                  setEscrowData(null);
                })
                .catch(err => {
                  console.error('[settleGame] Error:', err);
                  // Don't alert - settlement might have been done by opponent
                });
            }
            // Game cleanup handled server-side by settleWageredGame
          }
        }, (error) => {
          // Handle Firebase listener errors
          console.error('Game listener error:', error);
          alert('Connection to game lost. Returning to menu.');
          cancelMatchmaking();
        });
      }, [database, isWageredMatch, currentEscrowId, functions, gameRoomId, playSound]);

      // Generate unique throw ID for tracking
      const generateThrowId = useCallback(() => {
        return `t_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      }, []);

      // Sync throw to Firebase via Cloud Function (server-authoritative)
      // SECURITY: No fallback to direct writes - all throws MUST go through Cloud Function
      // Returns server result for tiered optimistic UI
      const syncThrowToFirebase = useCallback(async (throwData) => {
        if (!onlineMode || !gameRoomId) return null;

        // SECURITY: Require Cloud Functions - no direct write fallback
        if (!functions) {
          console.error('Cloud Functions not available - online mode requires server validation');
          alert('Online play is temporarily unavailable. Please try again later.');
          return null;
        }

        // Build payload - enhanced for wagered matches
        const payload = {
          gameId: gameRoomId,
          dartPosition: throwData.position
        };

        // Add enhanced payload for wagered matches (anti-cheat validation)
        if (isWageredMatch && throwData.aimPoint && throwData.powerValue !== undefined) {
          payload.aimPoint = throwData.aimPoint;
          payload.powerValue = throwData.powerValue;
          payload.throwId = throwData.throwId || generateThrowId();
        }

        const maxRetries = 3;
        let lastError = null;

        for (let attempt = 0; attempt < maxRetries; attempt++) {
          try {
            console.log(`[syncThrow] Attempt ${attempt + 1}: Sending dart at`, throwData.position);
            const submitThrow = functions.httpsCallable('submitThrow');
            const result = await submitThrow(payload);

            // Server returns: { success, score, label, isBust, newScore, isCheckout, rhythm, serverTimestamp }
            if (!result.data.success) {
              console.error('[syncThrow] Throw rejected by server:', result.data.error);
              // Don't retry on server rejection (it's not a transient error)
              return null;
            }

            console.log('[syncThrow] Throw accepted:', result.data.label, result.data.score, 'pts', 'rhythm:', result.data.rhythm);
            // Return server result for tiered optimistic UI
            return result.data;
          } catch (error) {
            lastError = error;
            console.error(`[syncThrow] Attempt ${attempt + 1} failed:`, error.message || error);

            // Don't retry on permission/precondition errors - they won't succeed
            if (error.code === 'functions/failed-precondition') {
              console.warn('[syncThrow] Server rejected: not your turn or game ended');
              return null;
            } else if (error.code === 'functions/permission-denied') {
              console.warn('[syncThrow] Server rejected: not a player in this game');
              return null;
            }

            // Retry with backoff for network errors
            if (attempt < maxRetries - 1) {
              await new Promise(r => setTimeout(r, 200 * (attempt + 1)));
            }
          }
        }

        // All retries failed
        console.error('[syncThrow] All retries failed:', lastError);
        alert('Failed to register throw. Please check your connection and try again.');
        return null;
      }, [onlineMode, gameRoomId, isWageredMatch, generateThrowId, functions]);

      // Cancel matchmaking
      const cancelMatchmaking = useCallback(() => {
        // CRITICAL: Capture refs BEFORE any cleanup so disconnect notification can complete
        // This prevents the race condition where we clear refs before Firebase write finishes
        const capturedGameRoomRef = gameRoomRef.current;
        const capturedPlayerId = playerId;
        const capturedGameRoomId = gameRoomId;

        console.log('[cancelMatchmaking] Starting cleanup:', {
          hasGameRoom: !!capturedGameRoomRef,
          playerId: capturedPlayerId,
          gameRoomId: capturedGameRoomId,
          isWageredMatch
        });

        // If in an active game, set my connected status to false to notify opponent
        // IMPORTANT: Use captured ref so write completes even after cleanup
        if (capturedGameRoomRef && capturedPlayerId !== null) {
          const myPlayerKey = capturedPlayerId === 0 ? 'player1' : 'player2';
          console.log(`[cancelMatchmaking] Sending disconnect notification: ${myPlayerKey}/connected = false`);
          capturedGameRoomRef.child(`${myPlayerKey}/connected`).set(false)
            .then(() => console.log('[cancelMatchmaking] Disconnect notification sent successfully'))
            .catch(err => console.error('[cancelMatchmaking] Failed to set disconnected:', err));
        } else {
          console.log('[cancelMatchmaking] Skipping disconnect notification - no active game or playerId is null');
        }

        // Clear matchmaking interval if it's running
        if (matchmakingIntervalRef.current) {
          clearInterval(matchmakingIntervalRef.current);
          matchmakingIntervalRef.current = null;
        }

        // Clean up wagered matchmaking listener and timeout
        if (wageredListenerRef.current) {
          wageredListenerRef.current.ref.off('value', wageredListenerRef.current.callback);
          if (wageredListenerRef.current.timeoutId) {
            clearTimeout(wageredListenerRef.current.timeoutId);
          }
          wageredListenerRef.current = null;
        }

        // Remove from queue if still in matchmaking (use auth ID, not player index)
        if (myAuthId && database) {
          database.ref('matchmaking_queue').child(myAuthId).remove();
          // Also remove from wagered queues
          [50, 100, 500, 2500].forEach(stake => {
            database.ref(`matchmaking_queue/wagered/${stake}`).child(myAuthId).remove();
          });
        }

        // Refund escrow if we have one and game hasn't started
        // IMPORTANT: Await the refund and update coin balance before clearing state
        if (currentEscrowId && !capturedGameRoomId && functions) {
          console.log('[cancelMatchmaking] Refunding escrow:', currentEscrowId);
          const refundEscrowFn = functions.httpsCallable('refundEscrow');
          refundEscrowFn({ escrowId: currentEscrowId, reason: 'cancelled' })
            .then(result => {
              console.log('[cancelMatchmaking] Escrow refund result:', result.data);
              // Update coin balance if refund succeeded and we got coins back
              if (result.data.success && result.data.refundedAmounts && result.data.refundedAmounts.length > 0) {
                // Find our refund amount (we should be in the list)
                const totalRefunded = result.data.refundedAmounts.reduce((sum, amt) => sum + amt, 0);
                // Only add back our portion (usually first amount for player who initiated)
                const ourRefund = result.data.refundedAmounts[0];
                if (ourRefund > 0) {
                  setCoinBalance(prev => prev + ourRefund);
                  console.log('[cancelMatchmaking] Coins refunded to balance:', ourRefund);
                }
              }
            })
            .catch(err => {
              console.error('[cancelMatchmaking] Escrow refund failed:', err);
              // Escrow might already be locked or expired - cleanup will handle it
            });
        }

        // Clean up game room listener - turn off AFTER disconnect notification is sent
        // The notification uses capturedGameRoomRef so it's safe to clear this now
        if (gameRoomRef.current) {
          gameRoomRef.current.off();
          gameRoomRef.current = null;
        }

        // Clear early disconnect listener ref
        earlyDisconnectListenerRef.current = null;

        // Stop heartbeat
        stopHeartbeat();

        // Reset opponent connected state for next game session
        opponentWasConnected.current = false;

        setMatchmakingState(null);
        setOnlineMode(false);
        setGameRoomId(null);
        setPlayerId(null);
        setMyAuthId(null);
        setCurrentEscrowId(null);
        setIsWageredMatch(false);
        setEscrowData(null);
        setShowLeaveConfirmation(false); // Close confirmation modal on cleanup
        setGameState('menu');
      }, [myAuthId, database, playerId, currentEscrowId, gameRoomId, functions, isWageredMatch]);

      // Leave online game
      const leaveOnlineGame = useCallback(() => {
        // cancelMatchmaking now handles all cleanup including setting connected=false
        cancelMatchmaking();
      }, [cancelMatchmaking]);

      // Handle leave button click - show confirmation for wagered matches
      const handleLeaveClick = useCallback(() => {
        // Show confirmation ONLY for wagered matches during active gameplay
        // Active gameplay = winner is null (game not finished)
        if (isWageredMatch && winner === null) {
          setShowLeaveConfirmation(true);
        } else {
          // Casual match or game finished - immediate leave
          leaveOnlineGame();
        }
      }, [isWageredMatch, winner, leaveOnlineGame]);

      // ========== END ONLINE MULTIPLAYER FUNCTIONS ==========

      const calculateScore = useCallback((x, y) => {
        const dx = x - CENTER;
        const dy = y - CENTER;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > DOUBLE_OUTER) return { score: 0, label: 'MISS', multiplier: 0 };
        if (distance <= INNER_BULL) return { score: 50, label: 'BULL', multiplier: 1 };
        if (distance <= OUTER_BULL) return { score: 25, label: '25', multiplier: 1 };
        
        let angle = Math.atan2(dy, dx) * (180 / Math.PI) + 90;
        if (angle < 0) angle += 360;
        const segmentIndex = Math.floor((angle + 9) / 18) % 20;
        const baseScore = SEGMENTS[segmentIndex];
        
        if (distance >= DOUBLE_INNER && distance <= DOUBLE_OUTER) {
          return { score: baseScore * 2, label: `D${baseScore}`, multiplier: 2, base: baseScore };
        }
        if (distance >= TRIPLE_INNER && distance <= TRIPLE_OUTER) {
          return { score: baseScore * 3, label: `T${baseScore}`, multiplier: 3, base: baseScore };
        }
        return { score: baseScore, label: `${baseScore}`, multiplier: 1, base: baseScore };
      }, []);

      const addRandomness = useCallback((targetX, targetY, power, isInPerfectZone) => {
        // If in perfect zone, guarantee 100% accuracy - no randomness at all
        if (isInPerfectZone) {
          return {
            x: targetX,
            y: targetY
          };
        }

        // Not in perfect zone - apply massive penalty to make hitting targets nearly impossible
        const skillFactor = (100 - skillLevel) / 100;
        const powerFactor = Math.abs(power - 50) / 50;

        const skillRandomness = skillFactor * 25;
        const powerRandomness = powerFactor * 20;

        // Calculate how far from perfect zone (50%)
        const distanceFromPerfect = Math.abs(power - 50);
        // Huge penalty: 80 base + up to 60 more based on distance from 50%
        const perfectZonePenalty = 80 + (distanceFromPerfect * 1.2);

        // Total randomness - very high when outside perfect zone
        const randomness = skillRandomness + powerRandomness + perfectZonePenalty;

        const angle = Math.random() * Math.PI * 2;
        const offset = Math.random() * randomness;

        return {
          x: targetX + Math.cos(angle) * offset,
          y: targetY + Math.sin(angle) * offset
        };
      }, [skillLevel]);

      const getAITarget = useCallback((difficulty, currentScore) => {
        // Calculate angle and distance for a specific segment
        const getSegmentPosition = (segmentValue, multiplier = 1) => {
          const segmentIndex = SEGMENTS.indexOf(segmentValue);
          const angle = (segmentIndex * 18 - 90) * (Math.PI / 180);
          let distance;
          if (multiplier === 3) distance = (TRIPLE_INNER + TRIPLE_OUTER) / 2;
          else if (multiplier === 2) distance = (DOUBLE_INNER + DOUBLE_OUTER) / 2;
          else distance = (TRIPLE_OUTER + DOUBLE_INNER) / 2;

          return {
            x: CENTER + distance * Math.cos(angle),
            y: CENTER + distance * Math.sin(angle)
          };
        };

        // Parse a dart notation (e.g., "T20", "D12", "S19", "Bull") into target position
        const parseDartNotation = (notation) => {
          if (notation === 'Bull') {
            return { x: CENTER, y: CENTER }; // Bullseye
          }
          const prefix = notation[0]; // T, D, or S
          const segment = parseInt(notation.slice(1));
          let multiplier = 1;
          if (prefix === 'T') multiplier = 3;
          else if (prefix === 'D') multiplier = 2;
          return getSegmentPosition(segment, multiplier);
        };

        // For checkout situations - expert and impossible use checkout suggestions
        if (CHECKOUT_SUGGESTIONS[currentScore] && (difficulty === AI_DIFFICULTIES.EXPERT.key || difficulty === AI_DIFFICULTIES.IMPOSSIBLE.key)) {
          const suggestion = CHECKOUT_SUGGESTIONS[currentScore];
          // Get the first target from the suggestion (e.g., "T20 T19 D12" -> "T20")
          const firstTarget = suggestion.split(' ')[0];
          return parseDartNotation(firstTarget);
        }

        switch(difficulty) {
          case AI_DIFFICULTIES.BEGINNER.key:
            // Aim at random segments, single rings
            const randomSegment = SEGMENTS[Math.floor(Math.random() * SEGMENTS.length)];
            return getSegmentPosition(randomSegment, 1);

          case AI_DIFFICULTIES.INTERMEDIATE.key:
            // Aim at high-value segments (19, 20), sometimes triples
            const targetSegment = Math.random() > 0.5 ? 20 : 19;
            const useTriple = Math.random() > 0.6;
            return getSegmentPosition(targetSegment, useTriple ? 3 : 1);

          case AI_DIFFICULTIES.EXPERT.key:
            // Consistently aim for T20, T19, or doubles for checkout
            if (currentScore <= 40 && currentScore % 2 === 0) {
              return getSegmentPosition(currentScore / 2, 2);
            }
            return getSegmentPosition(20, 3);

          case AI_DIFFICULTIES.IMPOSSIBLE.key:
            // Perfect strategy - always aim T20 when not in checkout range
            return getSegmentPosition(20, 3);

          default:
            return { x: CENTER, y: CENTER };
        }
      }, []);

      const getAIAccuracy = (difficulty) => {
        const difficultyConfig = Object.values(AI_DIFFICULTIES).find(d => d.key === difficulty);
        return difficultyConfig ? difficultyConfig.accuracy : 50;
      };

      // NOTE: Achievement callbacks must be defined BEFORE handleLegWin to avoid TDZ errors in production builds
      const unlockAchievement = useCallback((achievementId) => {
        // Check if already unlocked
        if (unlockedAchievements.includes(achievementId)) return;

        const achievement = ACHIEVEMENTS_DATA.find(a => a.id === achievementId);
        if (!achievement) return;

        // Add to unlocked list
        const newUnlocked = [...unlockedAchievements, achievementId];
        setUnlockedAchievements(newUnlocked);

        try {
          localStorage.setItem('quikdarts_achievements', JSON.stringify(newUnlocked));
        } catch (error) {
          console.error('Failed to save achievements to localStorage:', error);
        }

        // Show popup (timeout cleanup handled by useEffect)
        setAchievementPopup(achievement);
        setTimeout(() => setAchievementPopup(null), 4000);
      }, [unlockedAchievements]);

      const checkAchievements = useCallback((stats) => {
        // First game
        if (stats.totalGamesPlayed >= 1) {
          unlockAchievement('first_game');
        }

        // First win
        if (stats.totalGamesWon >= 1) {
          unlockAchievement('first_win');
        }

        // 180 achievements
        if (stats.total180s >= 1) {
          unlockAchievement('first_180');
        }
        if (stats.total180s >= 10) {
          unlockAchievement('ten_180s');
        }
        if (stats.total180s >= 50) {
          unlockAchievement('fifty_180s');
        }

        // Bulls achievements
        if (stats.totalBulls >= 1) {
          unlockAchievement('first_bull');
        }
        if (stats.totalBulls >= 50) {
          unlockAchievement('fifty_bulls');
        }
        if (stats.totalBulls >= 100) {
          unlockAchievement('hundred_bulls');
        }

        // Winning streaks
        if (stats.totalGamesWon >= 5) {
          unlockAchievement('five_wins');
        }
        if (stats.totalGamesWon >= 20) {
          unlockAchievement('twenty_wins');
        }
        if (stats.totalGamesWon >= 50) {
          unlockAchievement('fifty_wins');
        }

        // Online achievements
        if (stats.totalOnlineGames >= 1) {
          unlockAchievement('first_online');
        }
        if (stats.totalOnlineWins >= 1) {
          unlockAchievement('first_online_win');
        }
        if (stats.totalOnlineWins >= 10) {
          unlockAchievement('ten_online_wins');
        }
        if (stats.totalOnlineWins >= 50) {
          unlockAchievement('fifty_online_wins');
        }

        // Checkout achievements
        if (stats.highestCheckout >= 100) {
          unlockAchievement('big_checkout');
        }
        if (stats.highestCheckout >= 150) {
          unlockAchievement('huge_checkout');
        }

        // Triples achievements
        if (stats.totalTriples >= 50) {
          unlockAchievement('fifty_triples');
        }
        if (stats.totalTriples >= 200) {
          unlockAchievement('two_hundred_triples');
        }

        // Perfect 9 Chain (Nine-Darter milestones)
        if (stats.totalNineDarters >= 1) {
          unlockAchievement('perfect9_first');
        }
        if (stats.totalNineDarters >= 10) {
          unlockAchievement('perfect9_ten');
        }
        if (stats.totalNineDarters >= 100) {
          unlockAchievement('perfect9_hundred');
        }
      }, [unlockAchievement]);

      const updateAchievementStats = useCallback((update) => {
        setAchievementStats(prev => {
          const newStats = { ...prev, ...update };

          try {
            localStorage.setItem('quikdarts_stats', JSON.stringify(newStats));
          } catch (error) {
            console.error('Failed to save achievement stats to localStorage:', error);
          }

          checkAchievements(newStats);
          return newStats;
        });
      }, [checkAchievements]);

      // Update weekly challenge stats and check for completion
      const updateWeeklyChallengeStats = useCallback((update) => {
        setWeeklyChallenge(prev => {
          // Check if we need to reset for a new week
          const currentWeek = getCurrentWeekNumber();
          if (prev.weekNumber !== currentWeek) {
            // New week, reset everything but keep completed challenges history
            const activeChallenge = getActiveTimeLimitedAchievement();
            const newData = {
              weekNumber: currentWeek,
              challengeId: activeChallenge?.id,
              stats: { ...update },
              completed: false,
              completedChallenges: prev.completedChallenges || []
            };
            try {
              localStorage.setItem('quikdarts_weekly_challenge', JSON.stringify(newData));
            } catch (error) {
              console.error('Failed to save weekly challenge:', error);
            }
            return newData;
          }

          // Same week, update stats
          const newStats = { ...prev.stats };
          Object.keys(update).forEach(key => {
            newStats[key] = (newStats[key] || 0) + (update[key] || 0);
          });

          // Check if challenge is now completed
          const activeChallenge = getActiveTimeLimitedAchievement();
          let completed = prev.completed;
          let completedChallenges = [...(prev.completedChallenges || [])];

          if (activeChallenge && !completed) {
            const current = newStats[activeChallenge.statKey] || 0;
            if (current >= activeChallenge.target) {
              completed = true;
              if (!completedChallenges.includes(activeChallenge.id)) {
                completedChallenges.push(activeChallenge.id);
              }
              // Sync completion to Firebase for global tracking (requires auth)
              if (database && currentAuthUser) {
                try {
                  database.ref('weekly_completions/' + activeChallenge.id).transaction(count => (count || 0) + 1);
                } catch (error) {
                  console.error('Failed to sync weekly completion to Firebase:', error);
                }
              }
            }
          }

          const newData = {
            ...prev,
            stats: newStats,
            completed,
            completedChallenges
          };

          try {
            localStorage.setItem('quikdarts_weekly_challenge', JSON.stringify(newData));
          } catch (error) {
            console.error('Failed to save weekly challenge:', error);
          }

          return newData;
        });
      }, []);

      // Update daily challenge stats and check for completions
      const updateDailyChallengeStats = useCallback((update) => {
        setDailyChallengeData(prev => {
          const today = getTodayString();
          if (prev.date !== today) {
            // Reset for new day, then apply the update
            const newData = createDefaultDailyChallengeData(today);
            Object.keys(update).forEach(key => {
              newData.stats[key] = (newData.stats[key] || 0) + (update[key] || 0);
            });
            try {
              localStorage.setItem('quikdarts_daily_challenges', JSON.stringify(newData));
            } catch (error) {
              console.error('Failed to save daily challenges:', error);
            }
            return newData;
          }

          const newStats = { ...prev.stats };
          Object.keys(update).forEach(key => {
            newStats[key] = (newStats[key] || 0) + (update[key] || 0);
          });

          const newCompleted = [...prev.completedChallenges];
          prev.challenges.forEach(challenge => {
            if (!newCompleted.includes(challenge.id)) {
              const current = newStats[challenge.statKey] || 0;
              if (current >= challenge.target) {
                newCompleted.push(challenge.id);
              }
            }
          });

          const newData = { ...prev, stats: newStats, completedChallenges: newCompleted };
          try {
            localStorage.setItem('quikdarts_daily_challenges', JSON.stringify(newData));
          } catch (error) {
            console.error('Failed to save daily challenges:', error);
          }
          return newData;
        });
      }, []);

      const handleLegWin = useCallback((playerIndex, dartsInLeg = null) => {
        // Check for nine-darter (only possible in 501)
        // Use passed dartsInLeg if provided, otherwise read from state
        const playerDartsInLeg = dartsInLeg !== null ? dartsInLeg : (legDartsThrown[playerIndex] || 0);
        if (playerSetup.gameMode === 501 && playerDartsInLeg === 9) {
          setShowNineDarter(true);
          playSound('ninedarter'); // Epic crowd roar and fanfare
          setTimeout(() => setShowNineDarter(false), 6000);

          // Track nine-darter achievement (only vs AI or online, not solo play)
          if (!players[playerIndex].isAI) {
            if (onlineMode) {
              unlockAchievement('nine_darter_online');
            } else if (!practiceMode && hasAIOpponent) {
              unlockAchievement('nine_darter_offline');
              updateAchievementStats({ totalNineDarters: achievementStats.totalNineDarters + 1 });
            }
          }
        }

        if (playerSetup.gameMode !== 501 || playerDartsInLeg !== 9) {
          playSound('win'); // Only play regular win sound if not a nine-darter
        }

        // Update leg scores
        const newLegScores = [...legScores];
        newLegScores[playerIndex] = (newLegScores[playerIndex] || 0) + 1;
        setLegScores(newLegScores);

        // Check if player won the set (first to legsPerSet wins)
        if (newLegScores[playerIndex] >= playerSetup.legsPerSet) {
          // Player won the set!
          const newSetScores = [...setScores];
          newSetScores[playerIndex] = (newSetScores[playerIndex] || 0) + 1;
          setSetScores(newSetScores);

          // Check if player won the match (first to setsToWin wins)
          if (newSetScores[playerIndex] >= playerSetup.setsToWin) {
            // Player won the match!
            setMatchWinner(players[playerIndex]);
            setWinner(players[playerIndex]);

            // In online mode, sync winner to Firebase and schedule game deletion
            if (onlineMode && gameRoomRef.current) {
              // Update Firebase with winner so opponent sees it (with retry)
              const roomRef = gameRoomRef.current;
              retryFirebaseOperation(() => roomRef.update({
                winner: playerIndex,
                status: 'finished'
              })).catch(err => console.error('Failed to update winner after retries:', err));

              // For wagered matches, settle the game (release escrow to winner)
              if (isWageredMatch && currentEscrowId && functions && gameRoomId) {
                console.log('[settleGame] Settling wagered match:', gameRoomId);
                const settleGameFn = functions.httpsCallable('settleGame');
                settleGameFn({ gameId: gameRoomId })
                  .then(result => {
                    console.log('[settleGame] Result:', result.data);
                    if (result.data.success && result.data.payout > 0) {
                      // Winner gets the pot - wallet listener will update balance
                      const isWinner = playerIndex === myPlayerIndex;
                      if (isWinner) {
                        alert(`Congratulations! You won ${result.data.payout} coins!`);
                      }
                    }
                    // Clear escrow state
                    setCurrentEscrowId(null);
                    setIsWageredMatch(false);
                    setEscrowData(null);
                  })
                  .catch(err => {
                    console.error('[settleGame] Error:', err);
                    // Don't alert on error - settlement might have been done by opponent
                  });
              }
              // Game cleanup handled server-side by settleWageredGame
            }

            // Track game completion and win (only vs AI or online, not solo play)
            if (!players[playerIndex].isAI && !practiceMode) {
              if (onlineMode) {
                updateAchievementStats({
                  totalOnlineGames: achievementStats.totalOnlineGames + 1,
                  totalOnlineWins: achievementStats.totalOnlineWins + 1
                });
              } else if (hasAIOpponent) {
                updateAchievementStats({
                  totalGamesPlayed: achievementStats.totalGamesPlayed + 1,
                  totalGamesWon: achievementStats.totalGamesWon + 1
                });
                updateWeeklyChallengeStats({ weeklyWins: 1 });
                updateDailyChallengeStats({ dailyWins: 1, dailyGames: 1 });
              }
            } else if (!practiceMode) {
              // Track game played but not won (lost to AI or other player)
              if (onlineMode) {
                updateAchievementStats({ totalOnlineGames: achievementStats.totalOnlineGames + 1 });
              } else if (hasAIOpponent) {
                updateAchievementStats({ totalGamesPlayed: achievementStats.totalGamesPlayed + 1 });
                updateDailyChallengeStats({ dailyGames: 1 });
              }
            }
            return;
          }

          // Reset legs for new set
          setLegScores(new Array(players.length).fill(0));
        }

        // Start new leg
        setTimeout(() => {
          const newPlayers = players.map(p => ({
            ...p,
            score: playerSetup.gameMode
          }));
          setPlayers(newPlayers);
          setDartsThrown(0);
          setCurrentTurnScore(0);
          setDartPositions([]);
          setTriplesHit(0);
          setThrowHistory([]);
          setWinner(null);
          setLegDartsThrown(new Array(players.length).fill(0));
        }, 2000);
      }, [legScores, setScores, players, playerSetup, playSound, legDartsThrown, unlockAchievement, updateAchievementStats, achievementStats, onlineMode, practiceMode, updateWeeklyChallengeStats]);

      // NOTE: updateStats and nextPlayer must be defined BEFORE throwDart to avoid TDZ errors in production builds
      const updateStats = useCallback((playerIndex, result) => {
        setGameStats(prev => {
          const playerStats = prev[playerIndex] || {
            throws: 0, totalScore: 0, doubles: 0, triples: 0, bullseyes: 0,
            misses: 0, highestThrow: 0, averagePerSet: 0
          };

          const newThrows = playerStats.throws + 1;
          const newTotal = playerStats.totalScore + result.score;

          return {
            ...prev,
            [playerIndex]: {
              throws: newThrows, totalScore: newTotal,
              doubles: playerStats.doubles + (result.multiplier === 2 ? 1 : 0),
              triples: playerStats.triples + (result.multiplier === 3 ? 1 : 0),
              bullseyes: playerStats.bullseyes + (result.score === 50 ? 1 : 0),
              misses: playerStats.misses + (result.score === 0 ? 1 : 0),
              highestThrow: Math.max(playerStats.highestThrow, result.score),
              averagePerSet: ((newTotal / newThrows) * 3).toFixed(1)
            }
          };
        });
      }, []);

      const nextPlayer = useCallback((busted) => {
        if (busted) {
          const newPlayers = [...players];
          newPlayers[currentPlayerIndex] = { ...players[currentPlayerIndex], score: players[currentPlayerIndex].score + currentTurnScore };
          setPlayers(newPlayers);
        }

        setDartsThrown(0);
        setCurrentTurnScore(0);
        setDartPositions([]);
        setTriplesHit(0);
        setCurrentTurnThrows([]); // Reset turn throws for wobble detection
        setAimWobble({ x: 0, y: 0 }); // Reset wobble
        setCurrentPlayerIndex((currentPlayerIndex + 1) % players.length);
      }, [currentPlayerIndex, players, currentTurnScore]);

      const throwDart = useCallback(() => {
        // Practice mode: unlimited throws with stat tracking
        if (practiceMode === 'active') {
          playSound('throw');

          // Apply wobble offset to aim position (use ref for current value, avoids stale closure)
          const effectiveAimX = aimPositionRef.current.x + aimWobble.x;
          const effectiveAimY = aimPositionRef.current.y + aimWobble.y;

          // Use practice skill level for difficulty
          const currentSkill = practiceSkillLevel;
          let perfectZoneWidth;
          if (currentSkill <= 40) {
            perfectZoneWidth = 10; // Beginner
          } else {
            const baseZoneWidth = 10;
            const shrinkRate = currentSkill >= 81 ? 3 : 2.5;
            perfectZoneWidth = Math.max(baseZoneWidth - (triplesHit * shrinkRate), 4);
          }
          const perfectZoneLeft = 50 - (perfectZoneWidth / 2);
          const perfectZoneRight = 50 + (perfectZoneWidth / 2);
          const isInPerfectZone = power > perfectZoneLeft && power < perfectZoneRight;

          const finalPosition = addRandomness(effectiveAimX, effectiveAimY, power, isInPerfectZone);
          const result = calculateScore(finalPosition.x, finalPosition.y);

          if (isInPerfectZone) {
            setTriplesHit(prev => prev + 1);
          }

          setAnimatingDart({ start: { x: CENTER, y: BOARD_SIZE + 50 }, end: finalPosition });

          setTimeout(() => {
            setAnimatingDart(null);
            setDartPositions(prev => [...prev, finalPosition]);

            // Update practice stats
            setPracticeStats(prev => {
              const newStats = { ...prev };
              newStats.dartsThrown += 1;
              newStats.totalScore += result.score;

              // Track specific hits
              if (result.score === 50) {
                newStats.bulls += 1;
                playSound('bullseye');
              } else if (result.score === 25) {
                newStats.singleBull += 1;
                playSound('hit');
              } else if (result.multiplier === 3) {
                newStats.triples += 1;
                if (result.label === 'T20') newStats.t20 += 1;
                if (result.label === 'T19') newStats.t19 += 1;
                if (result.label === 'T18') newStats.t18 += 1;
                playSound('hit');
              } else if (result.multiplier === 2) {
                newStats.doubles += 1;
                playSound('hit');
              } else if (result.score > 0) {
                playSound('hit');
              }

              return newStats;
            });

            // Show score popup
            setShowScorePopup({ ...result, position: finalPosition });
            setTimeout(() => setShowScorePopup(null), 1000);

            // Clear board after 3 darts
            if (dartPositions.length + 1 >= 3) {
              setTimeout(() => {
                setDartPositions([]);
                setTriplesHit(0);
                setCurrentTurnThrows([]);
                setAimWobble({ x: 0, y: 0 });
              }, 1000);
            }
          }, 300);

          return; // Exit early for practice mode
        }

        // Regular game mode checks
        if (dartsThrown >= 3 || winner) return;

        // Online mode: only allow throws on your turn
        if (onlineMode && currentPlayerIndex !== playerId) {
          return; // Not your turn
        }

        playSound('throw');

        // Apply wobble offset to aim position (use ref for current value, avoids stale closure)
        const effectiveAimX = aimPositionRef.current.x + aimWobble.x;
        const effectiveAimY = aimPositionRef.current.y + aimWobble.y;

        // Check if player is aiming at the winning double
        const currentPlayer = players[currentPlayerIndex];
        const aimingAt = calculateScore(effectiveAimX, effectiveAimY);
        const isAimingAtWinningDouble = isCheckoutPosition && aimingAt.multiplier === 2 && aimingAt.score === currentPlayer.score;

        // Calculate if power is in perfect zone
        // Beginner mode (40% or below): constant 10% zone, no shrinking
        // Intermediate (41-80%): shrinks by 2.5% for each perfect hit
        // Expert (81%+): shrinks by 3% for each perfect hit
        // Aiming at winning double: ultra-small 2% zone
        let perfectZoneWidth;
        if (skillLevel <= 40) {
          // Beginner mode - constant 10% zone, no shrinking
          perfectZoneWidth = 10;
        } else {
          // Normal mode - shrinking zones
          if (isAimingAtWinningDouble) {
            perfectZoneWidth = 2; // Ultra-small zone for winning double
          } else {
            const baseZoneWidth = 10;
            const shrinkRate = (onlineMode || skillLevel >= 81) ? 3 : 2.5; // 3% for online/expert, 2.5% for intermediate
            perfectZoneWidth = Math.max(baseZoneWidth - (triplesHit * shrinkRate), 4);
          }
        }
        const perfectZoneLeft = 50 - (perfectZoneWidth / 2);
        const perfectZoneRight = 50 + (perfectZoneWidth / 2);
        const isInPerfectZone = power > perfectZoneLeft && power < perfectZoneRight;

        // Use effective aim position (includes wobble for expert mode)
        const finalPosition = addRandomness(effectiveAimX, effectiveAimY, power, isInPerfectZone);
        const result = calculateScore(finalPosition.x, finalPosition.y);

        // Increase difficulty by shrinking perfect zone when perfect throw is hit
        if (isInPerfectZone) {
          setTriplesHit(prev => prev + 1);
        }

        setAnimatingDart({ start: { x: CENTER, y: BOARD_SIZE + 50 }, end: finalPosition });
        
        setTimeout(() => {
          setAnimatingDart(null);
          setDartPositions(prev => [...prev, finalPosition]);

          const currentPlayer = players[currentPlayerIndex];
          const newScore = currentPlayer.score - result.score;

          // Track throw for wobble detection (expert mode 180 challenge)
          setCurrentTurnThrows(prev => [...prev, { score: result.score, multiplier: result.multiplier }]);

          // Check for 180 FIRST (before any sounds or popups)
          const newTurnScore = currentTurnScore + result.score;
          const is180 = newTurnScore === 180 && dartsThrown + 1 === 3;

          if (is180) {
            playSound('180');
            setShowScorePopup({ score: 180, label: '180!!!', position: finalPosition });
            setTimeout(() => setShowScorePopup(null), 2000);

            // Track 180 for achievements (only vs AI, not solo or practice)
            if (!onlineMode && !practiceMode && hasAIOpponent) {
              updateAchievementStats({ total180s: achievementStats.total180s + 1 });
              updateWeeklyChallengeStats({ weekly180s: 1 });
              updateDailyChallengeStats({ daily180s: 1 });
            }
          } else {
            // Play regular hit sounds only if NOT a 180
            if (result.score === 50) {
              playSound('bullseye');
              // Track bull for achievements (only vs AI, not solo or practice)
              if (!onlineMode && !practiceMode && hasAIOpponent) {
                updateAchievementStats({ totalBulls: achievementStats.totalBulls + 1 });
                updateWeeklyChallengeStats({ weeklyBulls: 1 });
                updateDailyChallengeStats({ dailyBulls: 1 });
              }
            } else if (result.score > 0) {
              playSound('hit');
            }

            // Track triples for achievements (only vs AI, not solo or practice)
            if (result.multiplier === 3 && !onlineMode && !practiceMode && hasAIOpponent) {
              updateAchievementStats({ totalTriples: achievementStats.totalTriples + 1 });
              updateWeeklyChallengeStats({ weeklyTriples: 1 });
              updateDailyChallengeStats({ dailyTriples: 1 });
            }

            setShowScorePopup({ ...result, position: finalPosition });
            setTimeout(() => setShowScorePopup(null), 1000);
          }

          // Track daily score for all throws (only vs AI, not solo or practice)
          if (!onlineMode && !practiceMode && hasAIOpponent && result.score > 0) {
            updateDailyChallengeStats({ dailyScore: result.score });
          }

          if (newScore < 0 || newScore === 1 || (newScore === 0 && result.multiplier !== 2)) {
            playSound('bust');
            setShowScorePopup({ score: 'BUST!', label: 'BUST!', position: finalPosition });
            setTimeout(() => {
              setShowScorePopup(null);
              nextPlayer(true);
            }, 1500);
            return;
          }

          if (newScore === 0 && result.multiplier === 2) {
            // CHECKOUT!
            // In online mode, sync to server and let Firebase listener handle game state
            if (onlineMode) {
              console.log('[checkout] Online mode - syncing checkout throw to server');

              // Wagered matches: show confirming state
              if (isWageredMatch) {
                setScoreConfirming(true);
              }

              // Enhanced payload for wagered matches
              const throwPayload = {
                player: currentPlayerIndex,
                score: result.score,
                multiplier: result.multiplier,
                label: result.label,
                newScore: 0,
                remaining: 0,
                dartsThrown: dartsThrown + 1,
                currentTurnScore: currentTurnScore + result.score,
                currentPlayer: currentPlayerIndex,
                position: finalPosition,
                // Enhanced payload for wagered match anti-cheat
                aimPoint: isWageredMatch ? { x: effectiveAimX, y: effectiveAimY } : undefined,
                powerValue: isWageredMatch ? power : undefined
              };

              syncThrowToFirebase(throwPayload).then((serverResult) => {
                setScoreConfirming(false);
                if (serverResult && serverResult.rhythm) {
                  setRhythmState(serverResult.rhythm);
                }
              }).catch(() => {
                setScoreConfirming(false);
              });

              // Server will set winner and status='finished'
              // Firebase listener will detect winner and call handleLegWin
              return;
            }

            // Offline mode: handle checkout locally
            const newPlayers = [...players];
            newPlayers[currentPlayerIndex] = { ...currentPlayer, score: 0 };
            setPlayers(newPlayers);
            updateStats(currentPlayerIndex, result);

            // Track checkout for achievements (only vs AI, not solo or practice)
            const checkoutValue = currentPlayer.score;
            if (!players[currentPlayerIndex].isAI && !practiceMode && hasAIOpponent) {
              if (checkoutValue > (achievementStats.highestCheckout || 0)) {
                updateAchievementStats({ highestCheckout: checkoutValue });
              }
            }

            // Calculate final dart count including this winning dart
            const finalDartCount = (legDartsThrown[currentPlayerIndex] || 0) + 1;

            // Increment leg darts before checking for nine-darter
            setLegDartsThrown(prev => {
              const newLegDarts = [...prev];
              newLegDarts[currentPlayerIndex] = finalDartCount;
              return newLegDarts;
            });

            setWinner(currentPlayer); // Set temporary leg winner for display
            handleLegWin(currentPlayerIndex, finalDartCount);
            return;
          }

          const newCurrentTurnScore = currentTurnScore + result.score;
          const newDartsThrown = dartsThrown + 1;
          const nextPlayerIndex = newDartsThrown >= 3 ? (currentPlayerIndex + 1) % players.length : currentPlayerIndex;

          // In online mode, ONLY sync to Firebase - don't update local state
          // The Firebase listener will update state for both players
          if (onlineMode) {
            // Enhanced payload for wagered matches
            const throwPayload = {
              player: currentPlayerIndex,
              score: result.score,
              multiplier: result.multiplier,
              label: result.label,
              newScore: newScore,
              remaining: newScore,
              dartsThrown: newDartsThrown,
              currentTurnScore: newCurrentTurnScore,
              currentPlayer: nextPlayerIndex,
              position: finalPosition,
              // Enhanced payload for wagered match anti-cheat
              aimPoint: isWageredMatch ? { x: effectiveAimX, y: effectiveAimY } : undefined,
              powerValue: isWageredMatch ? power : undefined
            };

            if (isWageredMatch) {
              // WAGERED MATCH: Tiered optimistic UI
              // Dart animation is instant, but score waits for server confirmation
              setScoreConfirming(true);

              syncThrowToFirebase(throwPayload)
                .then((serverResult) => {
                  setScoreConfirming(false);

                  if (serverResult) {
                    // Update rhythm state from server
                    if (serverResult.rhythm) {
                      setRhythmState(serverResult.rhythm);
                    }

                    // Check for position correction (anti-cheat)
                    // If server adjusted position, animate dart to corrected position
                    if (serverResult.positionAdjusted && serverResult.adjustedPosition) {
                      setPendingDartCorrection({
                        from: finalPosition,
                        to: serverResult.adjustedPosition
                      });
                      // Clear correction after animation
                      setTimeout(() => setPendingDartCorrection(null), 500);
                    }
                  }
                })
                .catch(() => {
                  setScoreConfirming(false);
                });
            } else {
              // CASUAL MATCH: Full optimistic UI - fire and forget
              syncThrowToFirebase(throwPayload);
            }

            // After 3 darts, reset local UI state
            // Note: Server (submitThrow Cloud Function) handles clearing dartPositions/dartsThrown
            if (newDartsThrown >= 3) {
              setTimeout(() => {
                // Reset turn tracking - same as offline mode
                setCurrentTurnThrows([]);
                setTriplesHit(0); // Reset power bar shrinking
                setAimWobble({ x: 0, y: 0 }); // Reset wobble
                setRhythmState('neutral'); // Reset rhythm for next turn
              }, 1000);
            }
          } else {
            // Offline mode: update local state directly
            const newPlayers = [...players];
            newPlayers[currentPlayerIndex] = { ...currentPlayer, score: newScore };
            setPlayers(newPlayers);

            setCurrentTurnScore(newCurrentTurnScore);
            setThrowHistory(prev => [...prev, { player: currentPlayerIndex, ...result, remaining: newScore }]);
            setDartsThrown(newDartsThrown);
            setLegDartsThrown(prev => {
              const newLegDarts = [...prev];
              newLegDarts[currentPlayerIndex] = (newLegDarts[currentPlayerIndex] || 0) + 1;
              return newLegDarts;
            });
            updateStats(currentPlayerIndex, result);

            if (newDartsThrown >= 3) {
              setTimeout(() => nextPlayer(false), 1000);
            }
          }
        }, 300);
      }, [aimWobble, power, dartsThrown, players, currentPlayerIndex, winner, calculateScore, addRandomness, playSound, isCheckoutPosition, triplesHit, handleLegWin, updateStats, nextPlayer, onlineMode, playerId, syncThrowToFirebase, currentTurnScore, practiceMode, practiceSkillLevel, dartPositions, updateAchievementStats, achievementStats, updateWeeklyChallengeStats, isWageredMatch]);

      const handleMouseMove = useCallback((e) => {
        if (!boardRef.current || isPowerCharging) return;
        const rect = boardRef.current.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * BOARD_SIZE;
        const y = ((e.clientY - rect.top) / rect.height) * BOARD_SIZE;
        aimPositionRef.current = { x, y };
        setAimPosition({ x, y });
      }, [isPowerCharging]);

      const handleMouseDown = useCallback((e) => {
        const currentPlayer = players[currentPlayerIndex];
        if (dartsThrown >= 3 || winner || animatingDart || (currentPlayer && currentPlayer.isAI)) return;
        e.preventDefault();

        // Clear any existing interval before starting a new one (safety check)
        if (powerIntervalRef.current) {
          clearInterval(powerIntervalRef.current);
          powerIntervalRef.current = null;
        }

        // Clear any pending power reset timeout
        if (powerResetTimeoutRef.current) {
          clearTimeout(powerResetTimeoutRef.current);
          powerResetTimeoutRef.current = null;
        }

        setIsPowerCharging(true);
        setPower(0);

        let increasing = true;
        let currentPower = 0;

        powerIntervalRef.current = setInterval(() => {
          if (increasing) {
            currentPower += 2;
            if (currentPower >= 100) increasing = false;
          } else {
            currentPower -= 2;
            if (currentPower <= 0) increasing = true;
          }
          setPower(currentPower);
        }, 20);
      }, [dartsThrown, winner, animatingDart, players, currentPlayerIndex]);

      const handleMouseUp = useCallback(() => {
        if (powerIntervalRef.current) {
          clearInterval(powerIntervalRef.current);
          powerIntervalRef.current = null;
        }
        if (isPowerCharging) {
          setIsPowerCharging(false);
          throwDart();
          // Delayed power reset to show where user stopped, then reset
          powerResetTimeoutRef.current = setTimeout(() => {
            setPower(0);
            powerResetTimeoutRef.current = null;
          }, 500);
        }
      }, [isPowerCharging, throwDart]);

      // Touch event handlers for mobile devices (iPhone, iPad, etc.)
      const handleTouchMove = useCallback((e) => {
        if (!boardRef.current || isPowerCharging) return;
        e.preventDefault();
        const touch = e.touches[0];
        const rect = boardRef.current.getBoundingClientRect();
        const x = ((touch.clientX - rect.left) / rect.width) * BOARD_SIZE;
        const y = ((touch.clientY - rect.top) / rect.height) * BOARD_SIZE;
        aimPositionRef.current = { x, y };
        setAimPosition({ x, y });
      }, [isPowerCharging]);

      const handleTouchStart = useCallback((e) => {
        const currentPlayer = players[currentPlayerIndex];
        if (dartsThrown >= 3 || winner || animatingDart || (currentPlayer && currentPlayer.isAI)) return;
        e.preventDefault();

        // Clear any existing interval before starting a new one (safety check)
        if (powerIntervalRef.current) {
          clearInterval(powerIntervalRef.current);
          powerIntervalRef.current = null;
        }

        // Clear any pending power reset timeout
        if (powerResetTimeoutRef.current) {
          clearTimeout(powerResetTimeoutRef.current);
          powerResetTimeoutRef.current = null;
        }

        // Update aim position on touch start
        const touch = e.touches[0];
        const rect = boardRef.current.getBoundingClientRect();
        const x = ((touch.clientX - rect.left) / rect.width) * BOARD_SIZE;
        const y = ((touch.clientY - rect.top) / rect.height) * BOARD_SIZE;
        aimPositionRef.current = { x, y };
        setAimPosition({ x, y });

        setIsPowerCharging(true);
        setPower(0);

        let increasing = true;
        let currentPower = 0;

        powerIntervalRef.current = setInterval(() => {
          if (increasing) {
            currentPower += 2;
            if (currentPower >= 100) increasing = false;
          } else {
            currentPower -= 2;
            if (currentPower <= 0) increasing = true;
          }
          setPower(currentPower);
        }, 20);
      }, [dartsThrown, winner, animatingDart, players, currentPlayerIndex]);

      const handleTouchEnd = useCallback((e) => {
        e.preventDefault();
        if (powerIntervalRef.current) {
          clearInterval(powerIntervalRef.current);
          powerIntervalRef.current = null;
        }
        if (isPowerCharging) {
          setIsPowerCharging(false);
          throwDart();
          // Delayed power reset to show where user stopped, then reset
          powerResetTimeoutRef.current = setTimeout(() => {
            setPower(0);
            powerResetTimeoutRef.current = null;
          }, 500);
        }
      }, [isPowerCharging, throwDart]);

      const handleTouchCancel = useCallback((e) => {
        e.preventDefault();
        // Clean up interval when touch is interrupted (scroll, notification, etc.)
        if (powerIntervalRef.current) {
          clearInterval(powerIntervalRef.current);
          powerIntervalRef.current = null;
        }
        // Reset charging state without throwing dart
        if (isPowerCharging) {
          setIsPowerCharging(false);
          setPower(0);
        }
      }, [isPowerCharging]);

      useEffect(() => {
        return () => {
          if (powerIntervalRef.current) clearInterval(powerIntervalRef.current);
          if (powerResetTimeoutRef.current) clearTimeout(powerResetTimeoutRef.current);
          if (matchmakingIntervalRef.current) clearInterval(matchmakingIntervalRef.current);
        };
      }, []);

      useEffect(() => {
        const currentPlayer = players[currentPlayerIndex];
        if (currentPlayer && CHECKOUT_SUGGESTIONS[currentPlayer.score]) {
          setCheckout(CHECKOUT_SUGGESTIONS[currentPlayer.score]);
          setIsCheckoutPosition(true);
        } else {
          setCheckout(null);
          // Also check for simple double finishes (2-40, even numbers)
          if (currentPlayer && currentPlayer.score >= 2 && currentPlayer.score <= 40 && currentPlayer.score % 2 === 0) {
            setIsCheckoutPosition(true);
          } else {
            setIsCheckoutPosition(false);
          }
        }
      }, [players, currentPlayerIndex]);

      // Wobble mechanics: Apply aim wobble for pressure moments
      useEffect(() => {
        const currentPlayer = players[currentPlayerIndex];
        if (!currentPlayer || currentPlayer.isAI) return; // Only for human players

        // Condition 1: Expert mode (81%+) and 2 T20s hit in a row (180 attempt)
        const twoT20sHit = currentTurnThrows.length === 2 &&
                          currentTurnThrows[0].score === 20 && currentTurnThrows[0].multiplier === 3 &&
                          currentTurnThrows[1].score === 20 && currentTurnThrows[1].multiplier === 3;
        const wobbleFor180 = skillLevel >= 81 && twoT20sHit && dartsThrown === 2;

        // Condition 2: Intermediate/Expert (41%+) aiming at winning double (final dart to win leg)
        const aimingAt = calculateScore(aimPosition.x, aimPosition.y);
        const isAimingAtWinningDouble = isCheckoutPosition && aimingAt.multiplier === 2 && aimingAt.score === currentPlayer.score;
        const wobbleForWinningDart = skillLevel >= 41 && isAimingAtWinningDouble && !isPowerCharging;

        // Apply wobble if either condition is met
        if (wobbleFor180 || wobbleForWinningDart) {
          // Apply continuous wobble
          const wobbleInterval = setInterval(() => {
            const wobbleAmount = 8; // pixels of wobble
            setAimWobble({
              x: (Math.random() - 0.5) * wobbleAmount,
              y: (Math.random() - 0.5) * wobbleAmount
            });
          }, 50); // Update every 50ms for smooth wobble

          return () => clearInterval(wobbleInterval);
        } else {
          // No wobble - reset
          setAimWobble({ x: 0, y: 0 });
        }
      }, [skillLevel, currentTurnThrows, dartsThrown, isPowerCharging, players, currentPlayerIndex, aimPosition, isCheckoutPosition, calculateScore]);

      // Online multiplayer cleanup: Handle disconnection and cleanup
      useEffect(() => {
        return () => {
          // Cleanup when component unmounts or leaves online mode
          if (gameRoomRef.current) {
            gameRoomRef.current.off();
          }
          if (myAuthId && database && onlineMode) {
            database.ref('matchmaking_queue').child(myAuthId).remove();
          }
        };
      }, [onlineMode, myAuthId, database]);

      useEffect(() => {
        const currentPlayer = players[currentPlayerIndex];
        if (currentPlayer && currentPlayer.isAI && gameState === 'playing' && !winner && !animatingDart && dartsThrown < 3) {
          const aiThrowDelay = setTimeout(() => {
            const target = getAITarget(currentPlayer.aiDifficulty, currentPlayer.score);
            const aiAccuracy = getAIAccuracy(currentPlayer.aiDifficulty);
            playSound('throw');

            // Calculate final position based on AI accuracy percentage
            let finalPosition;
            // AI uses its own accuracy to determine hit chance, not affected by human skill level
            const hitChance = aiAccuracy / 100;
            const isAccurateThrow = Math.random() < hitChance;

            if (isAccurateThrow) {
              // Accurate throw - hit near target with minimal deviation
              const minorDeviation = (100 - aiAccuracy) * 0.3; // Small deviation based on accuracy
              const angle = Math.random() * Math.PI * 2;
              const offset = Math.random() * minorDeviation;
              finalPosition = {
                x: target.x + Math.cos(angle) * offset,
                y: target.y + Math.sin(angle) * offset
              };
            } else {
              // Inaccurate throw - apply randomness
              const skillFactor = (100 - aiAccuracy) / 100;
              const randomness = 30 + (skillFactor * 50); // 30-80 pixels of deviation
              const angle = Math.random() * Math.PI * 2;
              const offset = Math.random() * randomness;

              finalPosition = {
                x: target.x + Math.cos(angle) * offset,
                y: target.y + Math.sin(angle) * offset
              };
            }

            const result = calculateScore(finalPosition.x, finalPosition.y);

            // Note: AI throws do NOT increment triplesHit as that affects human player's
            // perfect zone difficulty, and should only be affected by human throws

            setAnimatingDart({ start: { x: CENTER, y: BOARD_SIZE + 50 }, end: finalPosition });

            setTimeout(() => {
              setAnimatingDart(null);
              setDartPositions(prev => [...prev, finalPosition]);

              const newScore = currentPlayer.score - result.score;

              // Check for 180 FIRST (before any sounds or popups)
              const newTurnScore = currentTurnScore + result.score;
              const is180 = newTurnScore === 180 && dartsThrown + 1 === 3;

              if (is180) {
                playSound('180');
                setShowScorePopup({ score: 180, label: '180!!!', position: finalPosition });
                setTimeout(() => setShowScorePopup(null), 2000);
              } else {
                // Play regular hit sounds only if NOT a 180
                if (result.score === 50) playSound('bullseye');
                else if (result.score > 0) playSound('hit');

                setShowScorePopup({ ...result, position: finalPosition });
                setTimeout(() => setShowScorePopup(null), 1000);
              }

              if (newScore < 0 || newScore === 1 || (newScore === 0 && result.multiplier !== 2)) {
                playSound('bust');
                setShowScorePopup({ score: 'BUST!', label: 'BUST!', position: finalPosition });
                // Set dartsThrown to 3 to prevent AI useEffect from re-triggering before nextPlayer
                setDartsThrown(3);
                setTimeout(() => {
                  setShowScorePopup(null);
                  nextPlayer(true);
                }, 1500);
                return;
              }

              if (newScore === 0 && result.multiplier === 2) {
                const newPlayers = [...players];
                newPlayers[currentPlayerIndex] = { ...currentPlayer, score: 0 };
                setPlayers(newPlayers);
                updateStats(currentPlayerIndex, result);

                // Calculate final dart count including this winning dart
                const finalDartCount = (legDartsThrown[currentPlayerIndex] || 0) + 1;

                // Increment leg darts before checking for nine-darter
                setLegDartsThrown(prev => {
                  const newLegDarts = [...prev];
                  newLegDarts[currentPlayerIndex] = finalDartCount;
                  return newLegDarts;
                });

                setWinner(currentPlayer); // Set temporary leg winner for display
                handleLegWin(currentPlayerIndex, finalDartCount);
                return;
              }

              const newPlayers = [...players];
              newPlayers[currentPlayerIndex] = { ...currentPlayer, score: newScore };
              setPlayers(newPlayers);

              setCurrentTurnScore(prev => prev + result.score);
              setThrowHistory(prev => [...prev, { player: currentPlayerIndex, ...result, remaining: newScore }]);
              setDartsThrown(prev => prev + 1);
              setLegDartsThrown(prev => {
                const newLegDarts = [...prev];
                newLegDarts[currentPlayerIndex] = (newLegDarts[currentPlayerIndex] || 0) + 1;
                return newLegDarts;
              });
              updateStats(currentPlayerIndex, result);

              if (dartsThrown + 1 >= 3) {
                setTimeout(() => nextPlayer(false), 1000);
              }
            }, 300);
          }, 800);

          return () => clearTimeout(aiThrowDelay);
        }
      }, [players, currentPlayerIndex, gameState, winner, animatingDart, dartsThrown, getAITarget, calculateScore, playSound, updateStats, nextPlayer, legDartsThrown, handleLegWin, currentTurnScore]);

      const startGame = useCallback(() => {
        const newPlayers = Array.from({ length: playerSetup.count }, (_, i) => {
          // Use profile name/flag for first player if logged in, otherwise use setup defaults
          let playerName = playerSetup.names[i] || `Player ${i + 1}`;
          let playerFlag = playerSetup.flags[i] || 'üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø';

          // For the human player (index 0), use profile data if available
          if (i === 0 && currentUser && !currentUser.isAnonymous) {
            if (userProfile?.displayName) {
              playerName = userProfile.displayName;
            }
            if (userProfile?.flag) {
              playerFlag = userProfile.flag;
            }
          }

          return {
            name: playerName,
            score: playerSetup.gameMode,
            isAI: playerSetup.aiPlayers[i] || false,
            aiDifficulty: playerSetup.aiDifficulty[i] || null,
            flag: playerFlag
          };
        });
        setPlayers(newPlayers);
        setCurrentPlayerIndex(0);
        setDartsThrown(0);
        setCurrentTurnScore(0);
        setThrowHistory([]);
        setDartPositions([]);
        setGameStats({});
        setWinner(null);
        setMatchWinner(null);
        setTriplesHit(0);
        setIsCheckoutPosition(false);
        setLegScores(new Array(playerSetup.count).fill(0));
        setSetScores(new Array(playerSetup.count).fill(0));
        setLegDartsThrown(new Array(playerSetup.count).fill(0));
        setGameState('playing');
      }, [playerSetup, currentUser, userProfile]);

      const resetGame = () => {
        // If in online mode, use leaveOnlineGame to properly clean up Firebase
        if (onlineMode) {
          leaveOnlineGame();
          return;
        }
        setGameState('menu');
        setWinner(null);
      };

      // ============================================
      // AUTH FUNCTIONS
      // ============================================

      // Sanitize OAuth display name - limit length and remove potentially confusing characters
      const sanitizeOAuthDisplayName = (name) => {
        if (!name || typeof name !== 'string') return null;
        return name
          .slice(0, 50)                                    // Limit length
          .replace(/[<>\"'&\\]/g, '')                      // Remove HTML-dangerous chars
          .replace(/[\x00-\x1F\x7F]/g, '')                 // Remove control characters
          .replace(/\s+/g, ' ')                            // Collapse whitespace
          .trim() || null;
      };

      // Validate OAuth photo URL - only allow trusted domains
      const validatePhotoURL = (url) => {
        if (!url || typeof url !== 'string') return null;
        try {
          const parsed = new URL(url);
          // Only allow HTTPS from trusted OAuth providers
          const trustedDomains = [
            'graph.facebook.com',
            'platform-lookaside.fbsbx.com',
            'lh3.googleusercontent.com',
            'googleusercontent.com',
            'fbcdn.net'
          ];
          const isTrusted = parsed.protocol === 'https:' &&
            trustedDomains.some(domain => parsed.hostname === domain || parsed.hostname.endsWith('.' + domain));
          return isTrusted ? url : null;
        } catch {
          return null;
        }
      };

      // Update currentUser when auth state changes
      useEffect(() => {
        if (auth) {
          const unsubscribe = auth.onAuthStateChanged((user) => {
            if (user) {
              // Get photo from providerData (Facebook, Google, etc.)
              let photoURL = user.photoURL;
              let displayName = user.displayName;
              let email = user.email;

              if (user.providerData && user.providerData.length > 0) {
                const provider = user.providerData[0];

                // For Facebook, use Graph API URL (more reliable)
                if (provider.providerId === 'facebook.com' && provider.uid) {
                  // Validate Facebook UID is numeric before constructing URL
                  const fbUid = String(provider.uid).replace(/[^0-9]/g, '');
                  if (fbUid.length > 0 && fbUid.length <= 20) {
                    photoURL = `https://graph.facebook.com/${fbUid}/picture?type=large`;
                  }
                } else if (!photoURL) {
                  photoURL = provider.photoURL;
                }

                if (!displayName) displayName = provider.displayName;
                if (!email) email = provider.email;
              }

              // Sanitize and validate OAuth data before storing
              setCurrentUser({
                uid: user.uid,
                displayName: sanitizeOAuthDisplayName(displayName),
                email: email ? email.slice(0, 100) : null, // Limit email length
                photoURL: validatePhotoURL(photoURL),
                isAnonymous: user.isAnonymous
              });
            } else {
              setCurrentUser(null);
            }
          });
          return () => unsubscribe();
        }
      }, []);

      // Listen for wallet changes and initialize new users
      useEffect(() => {
        if (!database || !currentUser || currentUser.isAnonymous) {
          // Clear wallet state for anonymous/logged out users
          setCoinBalance(0);
          setDailyBonusAvailable(false);
          // Cleanup wallet listener
          if (walletListenerRef.current) {
            walletListenerRef.current();
            walletListenerRef.current = null;
          }
          return;
        }

        // Signed-in user - listen for wallet changes
        const walletRef = database.ref(`users/${currentUser.uid}/wallet`);

        const walletListener = walletRef.on('value', async (snapshot) => {
          const wallet = snapshot.val();
          console.log('[walletListener] Wallet update:', wallet);

          if (!wallet) {
            // New user - initialize their wallet via Cloud Function
            console.log('[walletListener] No wallet found for user', currentUser.uid);
            console.log('[walletListener] Functions available:', !!functions);
            if (functions) {
              try {
                console.log('[walletListener] Calling initializeNewUser...');
                const initFn = functions.httpsCallable('initializeNewUser');
                const result = await initFn();
                console.log('[walletListener] initializeNewUser result:', result.data);
                // Wallet will be created, listener will fire again
              } catch (error) {
                console.error('[walletListener] Failed to initialize user wallet:', error);
                console.error('[walletListener] Error code:', error.code);
                console.error('[walletListener] Error message:', error.message);
                // Show user-friendly error
                if (error.code === 'functions/permission-denied') {
                  alert('Unable to create wallet. Please sign in with Google, Facebook, or Apple.');
                }
              }
            } else {
              console.error('[walletListener] Functions not available!');
            }
          } else {
            // Update coin balance
            setCoinBalance(wallet.coins || 0);

            // Check if daily bonus is available (24 hours since last claim)
            const lastBonus = wallet.lastDailyBonus || 0;
            const now = Date.now();
            const twentyFourHours = 24 * 60 * 60 * 1000;
            const bonusAvailable = now - lastBonus >= twentyFourHours;
            console.log('[walletListener] Daily bonus check:', { lastBonus, now, diff: now - lastBonus, twentyFourHours, bonusAvailable });
            setDailyBonusAvailable(bonusAvailable);

            // Calculate ads remaining today
            const lastAdReward = wallet.lastAdReward || 0;
            const lastAdDay = Math.floor(lastAdReward / twentyFourHours);
            const currentDay = Math.floor(now / twentyFourHours);
            const adsUsedToday = currentDay > lastAdDay ? 0 : (wallet.adRewardsToday || 0);
            setAdsRemainingToday(Math.max(0, 5 - adsUsedToday));
          }
        }, (error) => {
          console.error('Wallet listener error:', error);
        });

        // Store cleanup function
        walletListenerRef.current = () => walletRef.off('value', walletListener);

        return () => {
          if (walletListenerRef.current) {
            walletListenerRef.current();
            walletListenerRef.current = null;
          }
        };
      }, [currentUser]);

      // Listen for profile and progression data
      useEffect(() => {
        if (!database || !currentUser || currentUser.isAnonymous) {
          setUserProfile(null);
          setUserProgression(null);
          setUserStreaks(null);
          if (profileListenerRef.current) {
            profileListenerRef.current();
            profileListenerRef.current = null;
          }
          return;
        }

        // Listen to each path separately (database rules only allow reading specific children)
        const profileRef = database.ref(`users/${currentUser.uid}/profile`);
        const progressionRef = database.ref(`users/${currentUser.uid}/progression`);
        const streaksRef = database.ref(`users/${currentUser.uid}/streaks`);

        const profileListener = profileRef.on('value', (snapshot) => {
          setUserProfile(snapshot.val() || null);
        }, (error) => {
          console.error('Profile listener error:', error);
        });

        const progressionListener = progressionRef.on('value', (snapshot) => {
          setUserProgression(snapshot.val() || null);
        }, (error) => {
          console.error('Progression listener error:', error);
        });

        const streaksListener = streaksRef.on('value', (snapshot) => {
          setUserStreaks(snapshot.val() || null);
        }, (error) => {
          console.error('Streaks listener error:', error);
        });

        profileListenerRef.current = () => {
          profileRef.off('value', profileListener);
          progressionRef.off('value', progressionListener);
          streaksRef.off('value', streaksListener);
        };

        return () => {
          if (profileListenerRef.current) {
            profileListenerRef.current();
            profileListenerRef.current = null;
          }
        };
      }, [currentUser]);

      // Claim daily bonus
      const claimDailyBonus = async () => {
        if (!functions || !currentUser || currentUser.isAnonymous || isClaimingBonus) return;

        setIsClaimingBonus(true);
        try {
          const claimFn = functions.httpsCallable('claimDailyBonus');
          console.log('[claimDailyBonus] Calling function...');
          const result = await claimFn();
          console.log('[claimDailyBonus] Response:', result.data);
          if (result.data.success) {
            // Wallet listener will update the balance
            setDailyBonusAvailable(false);
            console.log('[claimDailyBonus] Bonus claimed successfully! New balance:', result.data.newBalance);
            // Show success feedback with the actual amount and new balance
            alert(`+${result.data.coinsAwarded} coins claimed! New balance: ${result.data.newBalance}`);
          } else {
            // Show error to user
            const errorMsg = result.data.error || 'Failed to claim bonus';
            console.log('[claimDailyBonus] Claim failed:', errorMsg);
            if (result.data.nextClaimTime) {
              const nextTime = new Date(result.data.nextClaimTime);
              alert(`${errorMsg}. Next claim available: ${nextTime.toLocaleString()}`);
            } else {
              alert(errorMsg);
            }
          }
        } catch (error) {
          console.error('[claimDailyBonus] Error:', error);
          alert('Failed to claim daily bonus. Please try again.');
        } finally {
          setIsClaimingBonus(false);
        }
      };

      // Watch ad for coins reward
      // Uses Capacitor AdMob plugin on native, shows placeholder on web
      const watchAdForCoins = async () => {
        if (!functions || !currentUser || currentUser.isAnonymous || isWatchingAd) return;
        if (adsRemainingToday <= 0) {
          alert('Daily ad limit reached. Come back tomorrow for more!');
          return;
        }

        setIsWatchingAd(true);
        setAdError(null);

        try {
          // Check if running in Capacitor (native app)
          const isCapacitor = typeof window !== 'undefined' && window.Capacitor && window.Capacitor.isNativePlatform();

          if (!isCapacitor) {
            // Web browser - ads not available
            alert('Watch rewarded ads in the mobile app to earn free coins!');
            setIsWatchingAd(false);
            return;
          }

          // Import Capacitor AdMob plugin dynamically
          const { AdMob, RewardAdPluginEvents } = await import('@capacitor-community/admob');

          // Configure SSV (Server-Side Verification) with userId
          const ssvOptions = {
            customData: currentUser.uid, // This will be sent to our admobCallback
          };

          // AdMob Rewarded Ad Unit ID
          // NOTE: Replace with your actual ad unit ID from AdMob console
          const rewardedAdOptions = {
            adId: 'ca-app-pub-XXXXXXXXXXXXXXXX/YYYYYYYYYY', // TODO: Replace with real ad unit ID
            isTesting: true, // Set to false in production
            ssv: ssvOptions,
          };

          // Listen for reward event
          let rewardReceived = false;

          const rewardListener = AdMob.addListener(RewardAdPluginEvents.Rewarded, () => {
            rewardReceived = true;
          });

          const dismissListener = AdMob.addListener(RewardAdPluginEvents.Dismissed, async () => {
            rewardListener.remove();
            dismissListener.remove();

            if (rewardReceived) {
              // Ad was watched completely - poll for the SSV callback to process
              // AdMob sends the callback server-to-server, so we need to wait and check
              const maxAttempts = 10;
              const delayMs = 1500;

              for (let attempt = 0; attempt < maxAttempts; attempt++) {
                await new Promise(resolve => setTimeout(resolve, delayMs));

                try {
                  // Query for unclaimed ad rewards for this user
                  const getUnclaimedFn = functions.httpsCallable('getUnclaimedAdReward');
                  const unclaimedResult = await getUnclaimedFn();

                  if (unclaimedResult.data.found && unclaimedResult.data.transactionId) {
                    // Found an unclaimed reward - claim it
                    const claimFn = functions.httpsCallable('claimAdReward');
                    const claimResult = await claimFn({
                      transactionId: unclaimedResult.data.transactionId
                    });

                    if (claimResult.data.success) {
                      setAdsRemainingToday(claimResult.data.adsRemainingToday || 0);
                    } else {
                      setAdError(claimResult.data.error || 'Failed to claim reward');
                    }
                    break;
                  }
                } catch (error) {
                  console.error('[watchAdForCoins] Poll attempt failed:', error);
                }

                // If last attempt and still nothing, reward might be processed later
                // (no need to show error to user)
              }
            }

            setIsWatchingAd(false);
          });

          // Load and show the ad
          await AdMob.prepareRewardVideoAd(rewardedAdOptions);
          await AdMob.showRewardVideoAd();

        } catch (error) {
          console.error('[watchAdForCoins] Ad error:', error);
          setAdError('Unable to load ad. Please try again later.');
          setIsWatchingAd(false);
        }
      };

      // Coin packages for shop
      const COIN_PACKAGES = [
        { id: 'starter', coins: 500, price: '$0.99', popular: false },
        { id: 'popular', coins: 1200, price: '$1.99', popular: true },
        { id: 'best_value', coins: 3500, price: '$4.99', popular: false },
        { id: 'pro', coins: 8000, price: '$9.99', popular: false },
        { id: 'champion', coins: 20000, price: '$19.99', popular: false },
      ];

      // Purchase coins via Stripe
      const purchaseCoins = async (packageId) => {
        if (!functions || !currentUser || currentUser.isAnonymous || isPurchasing) return;

        setIsPurchasing(true);
        try {
          const createCheckout = functions.httpsCallable('createStripeCheckout');
          const result = await createCheckout({
            packageId,
            successUrl: window.location.origin + '?purchase=success',
            cancelUrl: window.location.origin + '?purchase=cancelled',
          });

          if (result.data.success && result.data.url) {
            // Redirect to Stripe Checkout
            window.location.href = result.data.url;
          } else {
            alert('Failed to start checkout. Please try again.');
          }
        } catch (error) {
          console.error('Purchase error:', error);
          alert('Purchase failed. Please try again.');
        } finally {
          setIsPurchasing(false);
        }
      };

      // Handle "Play Online" button click
      // Shows stake selection for signed-in users, starts casual matchmaking for guests
      const handlePlayOnlineClick = () => {
        if (currentUser && !currentUser.isAnonymous) {
          // Signed-in user: show stake selection
          setShowStakeSelection(true);
        } else {
          // Guest/anonymous: start casual matchmaking directly
          startMatchmaking();
        }
      };

      // Start wagered matchmaking with selected stake
      const startWageredMatchmaking = async () => {
        // Check if user has enough coins
        if (coinBalance < selectedStake) {
          alert(`Not enough coins! You need ${selectedStake} coins to play this stake level.`);
          return;
        }

        if (!functions || !database) {
          alert('Online play is temporarily unavailable. Please try again later.');
          return;
        }

        // Use current auth user (not the one-time authReadyPromise which may be stale)
        const authUser = auth?.currentUser;
        if (!authUser || authUser.isAnonymous) {
          alert('Please sign in to play wagered matches.');
          return;
        }

        setShowStakeSelection(false);
        setIsCreatingEscrow(true);
        setMatchmakingState('searching');
        setOnlineMode(true);
        setIsWageredMatch(true);

        const myPlayerId = authUser.uid;
        setMyAuthId(myPlayerId);
        const wageredQueueRef = database.ref(`matchmaking_queue/wagered/${selectedStake}`);

        try {
          // CLEANUP: Fire-and-forget cleanup of stale escrows
          // Don't await - this was causing 10+ second delays due to querying all escrows
          // If user has a pending escrow, createEscrow will fail and we handle it there
          console.log('[wageredMatchmaking] Starting background cleanup of stale escrows...');
          const refundFn = functions.httpsCallable('refundEscrow');
          refundFn({ escrowId: 'cleanup_pending', reason: 'cleanup_before_new_match' })
            .then(() => console.log('[wageredMatchmaking] Background cleanup completed'))
            .catch(() => console.log('[wageredMatchmaking] Background cleanup failed (not critical)'));

          // IMPORTANT: Check queue FIRST before creating any escrow
          // This prevents both players from creating separate escrows
          console.log('[wageredMatchmaking] Checking queue for opponents...');
          const snapshot = await wageredQueueRef.orderByChild('timestamp').limitToFirst(1).once('value');

          if (snapshot.exists()) {
            const opponents = snapshot.val();
            const opponentId = Object.keys(opponents)[0];
            const opponentData = opponents[opponentId];

            // Make sure we're not matching with ourselves
            if (opponentData.playerId !== myPlayerId) {
              // FOUND OPPONENT - Join their escrow first (don't create our own)
              console.log('[wageredMatchmaking] Found opponent:', opponentData.playerId);
              console.log('[wageredMatchmaking] Joining opponent escrow:', opponentData.escrowId);

              try {
                // Step 1: Join opponent's escrow FIRST (this locks it from pending -> locked)
                const joinEscrowFn = functions.httpsCallable('createEscrow');
                const escrowResult = await joinEscrowFn({
                  escrowId: opponentData.escrowId,
                  stakeAmount: selectedStake
                });

                if (!escrowResult.data.success) {
                  throw new Error(escrowResult.data.error || 'Failed to join escrow');
                }

                console.log('[wageredMatchmaking] Joined escrow:', escrowResult.data);
                setCurrentEscrowId(opponentData.escrowId);
                setCoinBalance(escrowResult.data.newBalance);

                // Step 2: Now create game (escrow is now locked, so createGame will succeed)
                const createGameFn = functions.httpsCallable('createGame');
                const result = await createGameFn({
                  player1Id: opponentData.playerId,
                  player1Name: sanitizeName(opponentData.name),
                  player1Flag: sanitizeFlag(opponentData.flag),
                  player2Id: myPlayerId,
                  player2Name: sanitizeName(userProfile?.displayName || currentUser?.displayName) || 'Player',
                  player2Flag: sanitizeFlag(userProfile?.flag) || 'üåç',
                  gameMode: playerSetup.gameMode,
                  isWagered: true,
                  escrowId: opponentData.escrowId,
                  stakeAmount: selectedStake
                });

                if (!result.data.success || !result.data.gameId) {
                  throw new Error(result.data.error || 'Failed to create game');
                }

                const roomId = result.data.gameId;

                // Step 3: Notify opponent by updating their queue entry with matchedGameId
                // (Don't remove yet - they need to see this update to find the game)
                await wageredQueueRef.child(opponentData.playerId).update({
                  matchedGameId: roomId,
                  matchedByName: sanitizeName(userProfile?.displayName || currentUser?.displayName) || 'Player',
                  matchedByFlag: sanitizeFlag(userProfile?.flag) || 'üåç'
                });
                setGameRoomId(roomId);
                gameRoomRef.current = database.ref(`games/${roomId}`);

                // IMPORTANT: Register onDisconnect FIRST to protect against early browser close
                gameRoomRef.current.child('player2/connected').onDisconnect().set(false).then(() => {
                  startHeartbeat(gameRoomRef.current, 'player2', 'player1', () => {
                    stopHeartbeat();
                    alert('Opponent disconnected. Returning to menu.');
                    cancelMatchmaking();
                  });

                  setOpponentName(sanitizeName(opponentData.name));
                  setOpponentFlag(sanitizeFlag(opponentData.flag));
                  setOpponentLevel(sanitizeLevel(opponentData.level));
                  setOpponentAvatar(sanitizeAvatarUrl(opponentData.avatarUrl));
                  setPendingGameInfo({ roomId, playerIndex: 1 });
                  setMatchmakingState('found');
                }).catch((err) => {
                  console.error('[wageredMatchmaking] Failed to register onDisconnect:', err);
                  setOpponentName(sanitizeName(opponentData.name));
                  setOpponentFlag(sanitizeFlag(opponentData.flag));
                  setOpponentLevel(sanitizeLevel(opponentData.level));
                  setOpponentAvatar(sanitizeAvatarUrl(opponentData.avatarUrl));
                  setPendingGameInfo({ roomId, playerIndex: 1 });
                  setMatchmakingState('found');
                });

                setIsCreatingEscrow(false);
                return;
              } catch (error) {
                console.error('[wageredMatchmaking] Error joining opponent:', error);
                // If joining failed, the escrow might already be taken by someone else
                // Fall through to create our own escrow and join queue
                console.log('[wageredMatchmaking] Falling back to creating own escrow...');
              }
            }
          }

          // NO OPPONENT FOUND (or matching self, or failed to join) - Create own escrow and join queue
          console.log('[wageredMatchmaking] No opponent found, creating escrow...');

          // SECURITY: Let server generate escrowId to prevent ID enumeration/collision attacks
          const createEscrowFn = functions.httpsCallable('createEscrow');
          const escrowResult = await createEscrowFn({
            stakeAmount: selectedStake
          });

          if (!escrowResult.data.success) {
            throw new Error(escrowResult.data.error || 'Failed to create escrow');
          }

          // Use the server-generated escrowId
          const escrowId = escrowResult.data.escrowId;
          console.log('[wageredMatchmaking] Escrow created:', escrowResult.data);
          setCurrentEscrowId(escrowId);
          setCoinBalance(escrowResult.data.newBalance);

          // Add self to wagered queue - use profile name, not default "Player 1"
          const myQueueEntry = {
            playerId: myPlayerId,
            name: sanitizeName(userProfile?.displayName || currentUser?.displayName) || 'Player',
            flag: sanitizeFlag(userProfile?.flag) || 'üåç',
            level: userProgression?.level || 1,
            avatarUrl: sanitizeAvatarUrl(userProfile?.avatar) || null,
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            escrowId: escrowId,
            stakeAmount: selectedStake
          };

          wageredQueueRef.child(myPlayerId).set(myQueueEntry);
          wageredQueueRef.child(myPlayerId).onDisconnect().remove();

          // Listen for when someone joins
          listenForWageredMatch(myPlayerId, wageredQueueRef, escrowId);

        } catch (error) {
          console.error('[wageredMatchmaking] Error:', error);
          alert(error.message || 'Failed to start wagered match. Please try again.');
          setMatchmakingState('idle');
          setOnlineMode(false);
          setIsWageredMatch(false);
          setCurrentEscrowId(null);
          setEscrowData(null);
        } finally {
          setIsCreatingEscrow(false);
        }
      };

      // Listen for wagered match opponent
      const listenForWageredMatch = (myPlayerId, wageredQueueRef, escrowId) => {
        let isProcessingMatch = false; // Prevent concurrent match attempts
        const myQueueEntryRef = wageredQueueRef.child(myPlayerId);

        // IMPORTANT: Initialize wageredListenerRef early so cleanup works even during setup
        // Will be updated with timeoutId after timeout is created
        wageredListenerRef.current = {
          ref: myQueueEntryRef,
          callback: null, // Will be set after listener is created
          timeoutId: null // Will be set after timeout is created
        };

        // Use Firebase .on() listener for real-time updates to our queue entry
        // This is more reliable than polling and detects matchedGameId immediately
        const queueEntryListener = myQueueEntryRef.on('value', async (snapshot) => {
          if (isProcessingMatch) return;
          if (!snapshot.exists()) return;

          const myEntry = snapshot.val();

          // Check 1: See if someone matched with us (they wrote matchedGameId to our queue entry)
          if (myEntry.matchedGameId) {
            console.log('[wageredMatchmaking] Found matchedGameId in queue entry:', myEntry.matchedGameId);
            isProcessingMatch = true;

            const roomId = myEntry.matchedGameId;
            const matchedOpponentName = myEntry.matchedByName || 'Opponent';
            const matchedOpponentFlag = myEntry.matchedByFlag || 'üåç';
            const matchedOpponentLevel = myEntry.matchedByLevel || 1;
            const matchedOpponentAvatar = myEntry.matchedByAvatar || null;

            // Clean up listener, interval, timeout, and queue entry
            myQueueEntryRef.off('value', queueEntryListener);
            clearInterval(matchmakingIntervalRef.current);
            if (wageredListenerRef.current && wageredListenerRef.current.timeoutId) {
              clearTimeout(wageredListenerRef.current.timeoutId);
            }
            wageredListenerRef.current = null;
            await myQueueEntryRef.remove();

            setGameRoomId(roomId);
            gameRoomRef.current = database.ref(`games/${roomId}`);

            // SECURITY: Validate game exists and we're actually a player in it
            // This prevents spoofed matchedGameId attacks
            let gameData;
            try {
              const gameSnap = await gameRoomRef.current.once('value');
              gameData = gameSnap.val();
            } catch (readErr) {
              // Permission denied = we're not a player in this game (spoofed matchedGameId)
              console.error('[wageredMatchmaking] Failed to read game - possible spoofed matchedGameId:', readErr);
              isProcessingMatch = false;
              return; // Ignore this matchedGameId and keep waiting
            }

            // Validate game data exists and we're player1 (since we're waiting for matchedGameId)
            if (!gameData || gameData.player1?.id !== myPlayerId) {
              console.error('[wageredMatchmaking] Invalid game data or not player1 - ignoring matchedGameId');
              isProcessingMatch = false;
              return;
            }

            if (gameData.wager) {
              setCurrentEscrowId(gameData.wager.escrowId);
            }

            // IMPORTANT: Register onDisconnect FIRST to protect against early browser close
            gameRoomRef.current.child('player1/connected').onDisconnect().set(false).then(() => {
              gameRoomRef.current.child('player1/connected').set(true);
              opponentWasConnected.current = true;

              startHeartbeat(gameRoomRef.current, 'player1', 'player2', () => {
                stopHeartbeat();
                alert('Opponent disconnected. Returning to menu.');
                // Game cleanup handled server-side
                cancelMatchmaking();
              });

              setOpponentName(sanitizeName(matchedOpponentName));
              setOpponentFlag(sanitizeFlag(matchedOpponentFlag));
              setOpponentLevel(sanitizeLevel(matchedOpponentLevel));
              setOpponentAvatar(sanitizeAvatarUrl(matchedOpponentAvatar));
              setPendingGameInfo({ roomId, playerIndex: 0 });
              setMatchmakingState('found');
            }).catch((err) => {
              console.error('[wageredMatchmaking] Failed to register onDisconnect:', err);
              setOpponentName(sanitizeName(matchedOpponentName));
              setOpponentFlag(sanitizeFlag(matchedOpponentFlag));
              setOpponentLevel(sanitizeLevel(matchedOpponentLevel));
              setOpponentAvatar(sanitizeAvatarUrl(matchedOpponentAvatar));
              setPendingGameInfo({ roomId, playerIndex: 0 });
              setMatchmakingState('found');
            });
            return;
          }
        });

        // Store callback in ref now that listener is created
        if (wageredListenerRef.current) {
          wageredListenerRef.current.callback = queueEntryListener;
        }

        // Check 2: Poll for opponents in queue (handles race condition where both players joined queue simultaneously)
        // Use UID comparison to determine who initiates the match (lower UID initiates)
        matchmakingIntervalRef.current = setInterval(async () => {
          if (isProcessingMatch) return;

          wageredQueueRef.once('value', async (queueSnapshot) => {
            if (isProcessingMatch) return;
            if (!queueSnapshot.exists()) return;

            const queueEntries = queueSnapshot.val();
            const opponents = Object.entries(queueEntries)
              .filter(([id]) => id !== myPlayerId)
              .filter(([, data]) => !data.matchedGameId) // Only match with unmatched players
              .map(([id, data]) => ({ id, ...data }));

            if (opponents.length === 0) return;

            // Find the opponent with the oldest timestamp (first in queue)
            const opponent = opponents.reduce((oldest, current) =>
              (current.timestamp || 0) < (oldest.timestamp || 0) ? current : oldest
            );

            // Use UID comparison to decide who initiates: LOWER UID initiates
            if (myPlayerId < opponent.playerId) {
              console.log('[wageredMatchmaking] I have lower UID, I will initiate match with', opponent.playerId);

              // CRITICAL: Before trying to initiate, check if our escrow is still pending
              // If someone already joined our escrow (status = 'locked'), we should wait
              // for the matchedGameId notification instead of trying to join theirs
              const ourEscrowRef = database.ref(`escrow/${escrowId}`);
              const ourEscrowSnap = await ourEscrowRef.once('value');
              const ourEscrow = ourEscrowSnap.val();

              if (ourEscrow && ourEscrow.status === 'locked') {
                console.log('[wageredMatchmaking] Our escrow is already locked - someone joined us. Waiting for matchedGameId...');
                return; // Don't initiate - wait for the matchedGameId update from whoever joined us
              }

              isProcessingMatch = true;

              try {
                // Refund our escrow first, then join opponent's
                console.log('[wageredMatchmaking] Refunding our escrow before joining opponent');
                const refundFn = functions.httpsCallable('refundEscrow');
                await refundFn({ escrowId, reason: 'switching_to_opponent' });
                console.log('[wageredMatchmaking] Refunded, now joining opponent escrow:', opponent.escrowId);

                // Join opponent's escrow with retry logic
                // Note: Server-side createEscrow validates escrow status
                let escrowResult;
                let retries = 3;
                while (retries > 0) {
                  try {
                    const joinEscrowFn = functions.httpsCallable('createEscrow');
                    escrowResult = await joinEscrowFn({
                      escrowId: opponent.escrowId,
                      stakeAmount: opponent.stakeAmount
                    });
                    if (escrowResult.data.success) break;
                    throw new Error(escrowResult.data.error || 'Failed to join escrow');
                  } catch (joinErr) {
                    retries--;
                    console.log('[wageredMatchmaking] Join attempt failed, retries left:', retries);
                    if (retries === 0) throw joinErr;
                    await new Promise(r => setTimeout(r, 500)); // Wait 500ms before retry
                  }
                }

                console.log('[wageredMatchmaking] Joined escrow successfully:', escrowResult.data);
                setCurrentEscrowId(opponent.escrowId);
                setCoinBalance(escrowResult.data.newBalance);

                // Create game
                console.log('[wageredMatchmaking] Creating game with opponent:', opponent.playerId);
                const createGameFn = functions.httpsCallable('createGame');
                const result = await createGameFn({
                  player1Id: opponent.playerId,
                  player1Name: sanitizeName(opponent.name),
                  player1Flag: sanitizeFlag(opponent.flag),
                  player2Id: myPlayerId,
                  player2Name: sanitizeName(userProfile?.displayName || currentUser?.displayName) || 'Player',
                  player2Flag: sanitizeFlag(userProfile?.flag) || 'üåç',
                  gameMode: playerSetup.gameMode,
                  isWagered: true,
                  escrowId: opponent.escrowId,
                  stakeAmount: opponent.stakeAmount
                });

                if (!result.data.success || !result.data.gameId) {
                  throw new Error(result.data.error || 'Failed to create game');
                }

                console.log('[wageredMatchmaking] Game created successfully:', result.data.gameId);
                const roomId = result.data.gameId;

                // Notify opponent by updating their queue entry with matchedGameId
                await wageredQueueRef.child(opponent.playerId).update({
                  matchedGameId: roomId,
                  matchedByName: sanitizeName(userProfile?.displayName || currentUser?.displayName) || 'Player',
                  matchedByFlag: sanitizeFlag(userProfile?.flag) || 'üåç',
                  matchedByLevel: userProgression?.level || 1,
                  matchedByAvatar: sanitizeAvatarUrl(userProfile?.avatar) || null
                });

                // Clean up our entry, listener, interval, and timeout
                myQueueEntryRef.off('value', queueEntryListener);
                clearInterval(matchmakingIntervalRef.current);
                if (wageredListenerRef.current && wageredListenerRef.current.timeoutId) {
                  clearTimeout(wageredListenerRef.current.timeoutId);
                }
                wageredListenerRef.current = null;
                await myQueueEntryRef.remove();

                setGameRoomId(roomId);
                gameRoomRef.current = database.ref(`games/${roomId}`);

                gameRoomRef.current.child('player2/connected').onDisconnect().set(false).then(() => {
                  startHeartbeat(gameRoomRef.current, 'player2', 'player1', () => {
                    stopHeartbeat();
                    alert('Opponent disconnected. Returning to menu.');
                    cancelMatchmaking();
                  });

                  setOpponentName(sanitizeName(opponent.name));
                  setOpponentFlag(sanitizeFlag(opponent.flag));
                  setOpponentLevel(sanitizeLevel(opponent.level));
                  setOpponentAvatar(sanitizeAvatarUrl(opponent.avatarUrl));
                  setPendingGameInfo({ roomId, playerIndex: 1 });
                  setMatchmakingState('found');
                }).catch((err) => {
                  console.error('[wageredMatchmaking] Failed to register onDisconnect:', err);
                  setOpponentName(sanitizeName(opponent.name));
                  setOpponentFlag(sanitizeFlag(opponent.flag));
                  setOpponentLevel(sanitizeLevel(opponent.level));
                  setOpponentAvatar(sanitizeAvatarUrl(opponent.avatarUrl));
                  setPendingGameInfo({ roomId, playerIndex: 1 });
                  setMatchmakingState('found');
                });
              } catch (error) {
                console.error('[wageredMatchmaking] Error matching from queue:', error);

                // Check if error is "Cannot refund locked escrow" - means someone joined our escrow
                const errorMsg = error.message || error.toString();
                if (errorMsg.includes('locked escrow') || errorMsg.includes('Cannot refund')) {
                  // Our escrow is locked = someone joined us! Wait for matchedGameId notification
                  console.log('[wageredMatchmaking] Our escrow is locked - opponent joined us. Waiting for matchedGameId...');
                  isProcessingMatch = false;
                  return; // Don't create new escrow, just wait
                }

                // For other errors, try to create a new escrow to stay in queue
                try {
                  console.log('[wageredMatchmaking] Match failed, creating new escrow to stay in queue');
                  // SECURITY: Let server generate escrowId
                  const createEscrowFn = functions.httpsCallable('createEscrow');
                  const newEscrowResult = await createEscrowFn({
                    stakeAmount: opponent.stakeAmount
                  });
                  if (newEscrowResult.data.success) {
                    const newEscrowId = newEscrowResult.data.escrowId;
                    setCurrentEscrowId(newEscrowId);
                    setCoinBalance(newEscrowResult.data.newBalance);
                    // Update our queue entry with new escrow ID
                    await myQueueEntryRef.update({ escrowId: newEscrowId });
                    console.log('[wageredMatchmaking] Created new escrow, staying in queue');
                  }
                } catch (escrowErr) {
                  console.error('[wageredMatchmaking] Failed to create new escrow:', escrowErr);
                }
                isProcessingMatch = false;
              }
            }
          });
        }, 2000); // Check every 2 seconds for race condition handling

        // Timeout after 60 seconds - refund escrow and notify user
        const timeoutId = setTimeout(() => {
          console.log('[wageredMatchmaking] Timeout - no opponent found');

          // Clean up listener
          myQueueEntryRef.off('value', queueEntryListener);

          // Clean up interval
          if (matchmakingIntervalRef.current) {
            clearInterval(matchmakingIntervalRef.current);
            matchmakingIntervalRef.current = null;
          }

          // Remove from queue
          myQueueEntryRef.remove();

          // Clear wagered listener ref
          wageredListenerRef.current = null;

          // Refund escrow
          if (functions && escrowId) {
            const refundFn = functions.httpsCallable('refundEscrow');
            refundFn({ escrowId, reason: 'cancelled' })
              .then(result => {
                console.log('[wageredMatchmaking] Escrow refunded on timeout:', result.data);
                if (result.data.refundedAmounts && result.data.refundedAmounts[0]) {
                  setCoinBalance(prev => prev + result.data.refundedAmounts[0]);
                }
              })
              .catch(err => console.error('[wageredMatchmaking] Refund failed:', err));
          }

          // Reset state and notify user
          setMatchmakingState('idle');
          setOnlineMode(false);
          setIsWageredMatch(false);
          setCurrentEscrowId(null);
          setEscrowData(null);
          alert('No opponent found. Your coins have been refunded. Please try again.');
        }, 60000);

        // Update ref with timeoutId now that timeout is created
        if (wageredListenerRef.current) {
          wageredListenerRef.current.timeoutId = timeoutId;
        }
      };

      // Sign in with Google
      const signInWithGoogle = async () => {
        try {
          const provider = new firebase.auth.GoogleAuthProvider();
          await auth.signInWithPopup(provider);
          setShowLoginModal(false);
        } catch (error) {
          alert('Unable to sign in. Please try again or use a different method.');
        }
      };

      // Sign in with Facebook
      const signInWithFacebook = async () => {
        try {
          const provider = new firebase.auth.FacebookAuthProvider();
          await auth.signInWithPopup(provider);
          setShowLoginModal(false);
        } catch (error) {
          // Generic error message to prevent user enumeration
          alert('Unable to sign in. Please try again or use a different method.');
        }
      };

      // Sign out
      const handleSignOut = async () => {
        try {
          await auth.signOut();
          // Sign back in anonymously
          await auth.signInAnonymously();
        } catch (error) {
          // Silent fail - user will see login button
        }
      };

      // Practice Mode Functions
      const enterPracticeMode = () => {
        setPracticeMode('selecting'); // Show skill selection screen
      };

      const startPracticeSession = (skill) => {
        setPracticeSkillLevel(skill);
        setPracticeMode('active');
        setGameState('playing');

        // Reset practice stats
        setPracticeStats({
          dartsThrown: 0,
          t20: 0,
          t19: 0,
          t18: 0,
          bulls: 0,
          singleBull: 0,
          triples: 0,
          doubles: 0,
          totalScore: 0
        });

        // Reset game-related states
        setDartPositions([]);
        setTriplesHit(0);
        setCurrentTurnThrows([]);
        setAimWobble({ x: 0, y: 0 });
      };

      const exitPracticeMode = () => {
        setPracticeMode(false);
        setPracticeSkillLevel(null);
        setGameState('menu');
        setDartPositions([]);
      };

      // Update countdown timer every minute
      useEffect(() => {
        const interval = setInterval(() => {
          setTimeUntilReset(getTimeUntilWeeklyReset());
        }, 60000); // Update every minute
        return () => clearInterval(interval);
      }, []);

      // Auto-hide achievement popup after 4 seconds with proper cleanup
      useEffect(() => {
        if (achievementPopup) {
          const timeoutId = setTimeout(() => {
            setAchievementPopup(null);
          }, 4000);

          // Cleanup function to clear timeout if component unmounts or popup changes
          return () => clearTimeout(timeoutId);
        }
      }, [achievementPopup]);

      const getRarityColor = (rarity) => {
        switch (rarity) {
          case 'common': return '#95a5a6';
          case 'uncommon': return '#27ae60';
          case 'rare': return '#3498db';
          case 'epic': return '#9b59b6';
          case 'legendary': return '#f39c12';
          case 'mythic': return '#e74c3c';
          default: return '#95a5a6';
        }
      };

      // Get rarity-based card styles for unlocked achievements
      const getRarityCardStyle = (rarity, isUnlocked) => {
        if (!isUnlocked) return {};
        const color = getRarityColor(rarity);

        switch (rarity) {
          case 'common':
            return {
              border: `1px solid ${color}30`,
              boxShadow: 'none'
            };
          case 'uncommon':
            return {
              border: `1px solid ${color}50`,
              boxShadow: `0 0 10px ${color}20`
            };
          case 'rare':
            return {
              border: `2px solid ${color}60`,
              boxShadow: `0 0 15px ${color}30`,
              animation: 'rareShimmer 3s ease-in-out infinite'
            };
          case 'epic':
            return {
              border: `2px solid ${color}70`,
              boxShadow: `0 0 20px ${color}40, inset 0 0 30px ${color}10`,
              animation: 'epicGlow 2s ease-in-out infinite'
            };
          case 'legendary':
            return {
              border: `2px solid ${color}`,
              boxShadow: `0 0 25px ${color}50, 0 0 50px ${color}20`,
              animation: 'legendaryPulse 2s ease-in-out infinite',
              background: `linear-gradient(135deg, ${COLORS.backgroundCard}, ${color}15)`
            };
          case 'mythic':
            return {
              border: `3px solid ${color}`,
              boxShadow: `0 0 30px ${color}60, 0 0 60px ${color}30, inset 0 0 40px ${color}10`,
              animation: 'mythicGlow 1.5s ease-in-out infinite',
              background: `linear-gradient(135deg, ${COLORS.backgroundCard}, ${color}20)`
            };
          default:
            return {};
        }
      };

      // Get achievement progress for trackable achievements
      const getAchievementProgress = (achievement, stats) => {
        if (!achievement.statKey || !achievement.target) {
          return null; // One-time achievement, no progress tracking
        }
        const current = stats[achievement.statKey] || 0;
        const target = achievement.target;
        // For threshold achievements (like checkout), show as percentage toward goal
        if (achievement.isThreshold) {
          const progress = Math.min(current / target, 1);
          return { current, target, progress, isThreshold: true };
        }
        // For cumulative achievements
        const progress = Math.min(current / target, 1);
        return { current, target, progress, isThreshold: false };
      };

      const renderDartboard = () => {
        const segments = [];
        const theme = currentTheme;
        const colors = currentThemeColors;
        const effects = theme.effects;

        // Calculate neon glow intensity for pulse animation
        const glowIntensity = effects.pulseAnimation ? 0.6 + 0.4 * Math.sin(neonPulsePhase) : 1;

        // Add SVG gradients and textures for 3D effects
        segments.push(
          <defs key="gradients">
            {/* Radial gradient for board lighting (brighter in center) */}
            {effects.useBoardLighting && (
              <radialGradient id="boardLighting" cx="50%" cy="45%">
                <stop offset="0%" stopColor="rgba(255,255,255,0.15)" />
                <stop offset="60%" stopColor="rgba(255,255,255,0.05)" />
                <stop offset="100%" stopColor="rgba(0,0,0,0.1)" />
              </radialGradient>
            )}
            {/* Gradient for raised bullseye */}
            <radialGradient id="bullGradient" cx="40%" cy="40%">
              <stop offset="0%" stopColor="rgba(255,255,255,0.3)" />
              <stop offset="70%" stopColor="rgba(0,0,0,0)" />
              <stop offset="100%" stopColor="rgba(0,0,0,0.3)" />
            </radialGradient>
            {/* Chrome effect for outer ring */}
            {effects.useChromeGradient && (
              <linearGradient id="chromeGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                <stop offset="0%" stopColor="#f0f0f0" />
                <stop offset="15%" stopColor="#ffffff" />
                <stop offset="30%" stopColor={colors.chromeRing} />
                <stop offset="50%" stopColor="#e8e8e8" />
                <stop offset="70%" stopColor="#a0a0a0" />
                <stop offset="85%" stopColor="#d0d0d0" />
                <stop offset="100%" stopColor="#b0b0b0" />
              </linearGradient>
            )}
            {/* Neon glow filter for neon theme */}
            {effects.glowEffect && (
              <filter id="neonGlow" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation={3 * glowIntensity} result="coloredBlur" />
                <feMerge>
                  <feMergeNode in="coloredBlur" />
                  <feMergeNode in="SourceGraphic" />
                </feMerge>
              </filter>
            )}
            {/* Gold metallic gradient for Gold Elite theme */}
            {effects.useMetallicSheen && (
              <linearGradient id="goldGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stopColor="#ffd700" />
                <stop offset="25%" stopColor="#ffed4a" />
                <stop offset="50%" stopColor="#ffd700" />
                <stop offset="75%" stopColor="#b8860b" />
                <stop offset="100%" stopColor="#ffd700" />
              </linearGradient>
            )}
            {/* Sisal/Cork texture pattern for board segments */}
            {effects.useSisalTexture && (
              <pattern id="sisalTexture" x="0" y="0" width="4" height="4" patternUnits="userSpaceOnUse">
                <rect width="4" height="4" fill="rgba(0,0,0,0)" />
                <circle cx="1" cy="1" r="0.3" fill="rgba(0,0,0,0.08)" />
                <circle cx="3" cy="2" r="0.3" fill="rgba(0,0,0,0.06)" />
                <circle cx="2" cy="3" r="0.3" fill="rgba(0,0,0,0.07)" />
                <circle cx="0.5" cy="3.5" r="0.2" fill="rgba(255,255,255,0.03)" />
                <circle cx="3.5" cy="0.5" r="0.2" fill="rgba(255,255,255,0.03)" />
              </pattern>
            )}
            {/* Wood grain pattern for outer ring */}
            {effects.useWoodGrain && (
              <pattern id="woodGrain" x="0" y="0" width="20" height="100" patternUnits="userSpaceOnUse" patternTransform="rotate(90)">
                <rect width="20" height="100" fill="rgba(80,60,40,0.1)" />
                <path d="M 0 10 Q 5 15, 10 10 T 20 10" stroke="rgba(60,40,20,0.15)" strokeWidth="0.5" fill="none" />
                <path d="M 0 30 Q 5 28, 10 30 T 20 30" stroke="rgba(60,40,20,0.1)" strokeWidth="0.3" fill="none" />
                <path d="M 0 50 Q 5 55, 10 50 T 20 50" stroke="rgba(60,40,20,0.12)" strokeWidth="0.4" fill="none" />
                <path d="M 0 70 Q 5 68, 10 70 T 20 70" stroke="rgba(60,40,20,0.1)" strokeWidth="0.3" fill="none" />
                <path d="M 0 90 Q 5 92, 10 90 T 20 90" stroke="rgba(60,40,20,0.08)" strokeWidth="0.3" fill="none" />
              </pattern>
            )}
          </defs>
        );

        // Number ring background (radius matches iOS: radius - 4*scale for parity)
        segments.push(
          <circle key="number-ring-bg" cx={CENTER} cy={CENTER} r={DOUBLE_OUTER + 24} fill={colors.numberRing} />
        );

        // Chrome/themed outer ring
        if (effects.useChromeGradient) {
          segments.push(
            <circle key="chrome-ring" cx={CENTER} cy={CENTER} r={DOUBLE_OUTER + 8} fill="url(#chromeGradient)" />,
            effects.useWoodGrain && <circle key="chrome-wood" cx={CENTER} cy={CENTER} r={DOUBLE_OUTER + 8} fill="url(#woodGrain)" opacity="0.3" />,
            <circle key="chrome-ring-inner" cx={CENTER} cy={CENTER} r={DOUBLE_OUTER + 2} fill={colors.boardBackground} />
          );
        } else {
          segments.push(
            <circle key="chrome-ring" cx={CENTER} cy={CENTER} r={DOUBLE_OUTER + 8} fill={colors.chromeRing} />,
            <circle key="chrome-ring-inner" cx={CENTER} cy={CENTER} r={DOUBLE_OUTER + 2} fill={colors.boardBackground} />
          );
        }

        for (let i = 0; i < 20; i++) {
          const startAngle = (i * 18 - 99) * (Math.PI / 180);
          const endAngle = ((i + 1) * 18 - 99) * (Math.PI / 180);

          const createArc = (innerR, outerR) => {
            const x1 = CENTER + innerR * Math.cos(startAngle);
            const y1 = CENTER + innerR * Math.sin(startAngle);
            const x2 = CENTER + outerR * Math.cos(startAngle);
            const y2 = CENTER + outerR * Math.sin(startAngle);
            const x3 = CENTER + outerR * Math.cos(endAngle);
            const y3 = CENTER + outerR * Math.sin(endAngle);
            const x4 = CENTER + innerR * Math.cos(endAngle);
            const y4 = CENTER + innerR * Math.sin(endAngle);

            return `M ${x1} ${y1} L ${x2} ${y2} A ${outerR} ${outerR} 0 0 1 ${x3} ${y3} L ${x4} ${y4} A ${innerR} ${innerR} 0 0 0 ${x1} ${y1}`;
          };

          // Use theme colors
          const baseColor = i % 2 === 0 ? colors.segmentPrimary : colors.segmentSecondary;
          const doubleColor = i % 2 === 0 ? colors.doubleTripleEven : colors.doubleTripleOdd;
          const tripleColor = i % 2 === 0 ? colors.doubleTripleEven : colors.doubleTripleOdd;

          // Add subtle shadow to each segment for depth (if shadow intensity > 0)
          const shadowOffset = effects.shadowIntensity > 0 ? 0.5 : 0;
          const shadowOpacity = effects.shadowIntensity;

          if (shadowOpacity > 0) {
            segments.push(
              <path key={`shadow-outer-${i}`} d={createArc(TRIPLE_OUTER, DOUBLE_INNER)} fill={`rgba(0,0,0,${shadowOpacity})`} transform={`translate(${shadowOffset}, ${shadowOffset})`} />,
              <path key={`shadow-double-${i}`} d={createArc(DOUBLE_INNER, DOUBLE_OUTER)} fill={`rgba(0,0,0,${shadowOpacity})`} transform={`translate(${shadowOffset}, ${shadowOffset})`} />,
              <path key={`shadow-inner-${i}`} d={createArc(OUTER_BULL, TRIPLE_INNER)} fill={`rgba(0,0,0,${shadowOpacity})`} transform={`translate(${shadowOffset}, ${shadowOffset})`} />,
              <path key={`shadow-triple-${i}`} d={createArc(TRIPLE_INNER, TRIPLE_OUTER)} fill={`rgba(0,0,0,${shadowOpacity})`} transform={`translate(${shadowOffset}, ${shadowOffset})`} />
            );
          }

          // Main segments (fill only - wires drawn separately via spider overlay for iOS parity)
          segments.push(
            <path key={`outer-${i}`} d={createArc(TRIPLE_OUTER, DOUBLE_INNER)} fill={baseColor} />,
            <path key={`double-${i}`} d={createArc(DOUBLE_INNER, DOUBLE_OUTER)} fill={doubleColor} />,
            <path key={`inner-${i}`} d={createArc(OUTER_BULL, TRIPLE_INNER)} fill={baseColor} />,
            <path key={`triple-${i}`} d={createArc(TRIPLE_INNER, TRIPLE_OUTER)} fill={tripleColor} />
          );

          // Add texture overlay if enabled
          if (effects.useSisalTexture) {
            segments.push(
              <path key={`texture-outer-${i}`} d={createArc(TRIPLE_OUTER, DOUBLE_INNER)} fill="url(#sisalTexture)" stroke="none" />,
              <path key={`texture-double-${i}`} d={createArc(DOUBLE_INNER, DOUBLE_OUTER)} fill="url(#sisalTexture)" stroke="none" />,
              <path key={`texture-inner-${i}`} d={createArc(OUTER_BULL, TRIPLE_INNER)} fill="url(#sisalTexture)" stroke="none" />,
              <path key={`texture-triple-${i}`} d={createArc(TRIPLE_INNER, TRIPLE_OUTER)} fill="url(#sisalTexture)" stroke="none" />
            );
          }

          // Wire highlights (if not in stealth mode or neon mode)
          if (!effects.glowEffect && effects.shadowIntensity > 0.1) {
            const wireHighlightOffset = -0.3;
            segments.push(
              <path key={`wire-highlight-${i}`} d={createArc(TRIPLE_OUTER, DOUBLE_INNER)} fill="none" stroke={colors.wireHighlight} strokeWidth="0.5" transform={`translate(0, ${wireHighlightOffset})`} />,
              <path key={`wire-highlight-double-${i}`} d={createArc(DOUBLE_INNER, DOUBLE_OUTER)} fill="none" stroke={colors.wireHighlight} strokeWidth="0.5" transform={`translate(0, ${wireHighlightOffset})`} />,
              <path key={`wire-highlight-inner-${i}`} d={createArc(OUTER_BULL, TRIPLE_INNER)} fill="none" stroke={colors.wireHighlight} strokeWidth="0.5" transform={`translate(0, ${wireHighlightOffset})`} />,
              <path key={`wire-highlight-triple-${i}`} d={createArc(TRIPLE_INNER, TRIPLE_OUTER)} fill="none" stroke={colors.wireHighlight} strokeWidth="0.5" transform={`translate(0, ${wireHighlightOffset})`} />
            );
          }

        }

        // Bulls with raised 3D effect and texture
        const bullShadowOpacity = effects.shadowIntensity > 0 ? effects.shadowIntensity : 0;

        segments.push(
          // Outer bull shadow
          bullShadowOpacity > 0 && <circle key="outer-bull-shadow" cx={CENTER + 1} cy={CENTER + 1} r={OUTER_BULL} fill={`rgba(0,0,0,${bullShadowOpacity})`} />,
          // Outer bull (wire drawn via ring overlay at OUTER_BULL radius)
          <circle key="outer-bull" cx={CENTER} cy={CENTER} r={OUTER_BULL} fill={colors.outerBull} style={effects.glowEffect ? { filter: 'url(#neonGlow)' } : {}} />,
          // Outer bull texture
          effects.useSisalTexture && <circle key="outer-bull-texture" cx={CENTER} cy={CENTER} r={OUTER_BULL} fill="url(#sisalTexture)" stroke="none" />,
          // Outer bull highlight for raised effect
          !effects.glowEffect && effects.shadowIntensity > 0.1 && <circle key="outer-bull-highlight" cx={CENTER} cy={CENTER} r={OUTER_BULL} fill="url(#bullGradient)" />,

          // Inner bull shadow
          bullShadowOpacity > 0 && <circle key="inner-bull-shadow" cx={CENTER + 1} cy={CENTER + 1} r={INNER_BULL} fill={`rgba(0,0,0,${bullShadowOpacity + 0.1})`} />,
          // Inner bull (wire drawn via ring overlay at INNER_BULL radius)
          <circle key="inner-bull" cx={CENTER} cy={CENTER} r={INNER_BULL} fill={colors.innerBull} style={effects.glowEffect ? { filter: 'url(#neonGlow)' } : {}} />,
          // Inner bull texture
          effects.useSisalTexture && <circle key="inner-bull-texture" cx={CENTER} cy={CENTER} r={INNER_BULL} fill="url(#sisalTexture)" stroke="none" />,
          // Inner bull highlight for shine
          !effects.glowEffect && effects.shadowIntensity > 0.1 && <ellipse key="inner-bull-shine" cx={CENTER - 2} cy={CENTER - 2} rx={INNER_BULL * 0.4} ry={INNER_BULL * 0.3} fill="rgba(255,255,255,0.4)" />
        );

        // Spider wire overlay - 20 radial spokes + 5 concentric ring circles
        // This matches iOS DartboardView exactly for pixel-perfect cross-platform consistency
        // Draw radial spoke wires from outer bull to double outer (on segment boundaries)
        for (let i = 0; i < 20; i++) {
          const angle = (i * 18 - 99) * (Math.PI / 180);
          const x1 = CENTER + OUTER_BULL * Math.cos(angle);
          const y1 = CENTER + OUTER_BULL * Math.sin(angle);
          const x2 = CENTER + DOUBLE_OUTER * Math.cos(angle);
          const y2 = CENTER + DOUBLE_OUTER * Math.sin(angle);

          segments.push(
            <line key={`spider-wire-${i}`} x1={x1} y1={y1} x2={x2} y2={y2} stroke={colors.wireColor} strokeWidth={effects.wireWidth} />
          );
        }

        // Draw concentric ring wires at all scoring boundaries
        [INNER_BULL, OUTER_BULL, TRIPLE_INNER, TRIPLE_OUTER, DOUBLE_INNER, DOUBLE_OUTER].forEach((radius, idx) => {
          segments.push(
            <circle key={`ring-wire-${idx}`} cx={CENTER} cy={CENTER} r={radius} fill="none" stroke={colors.wireColor} strokeWidth={effects.wireWidth} />
          );
        });

        // Neon glow overlay for wire segments
        if (effects.glowEffect && colors.neonPrimary) {
          // Draw glowing wire overlay
          for (let i = 0; i < 20; i++) {
            const startAngle = (i * 18 - 99) * (Math.PI / 180);
            const midAngle = ((i * 18 + 9) - 99) * (Math.PI / 180);

            // Radial wire from bull to double
            const x1 = CENTER + OUTER_BULL * Math.cos(startAngle);
            const y1 = CENTER + OUTER_BULL * Math.sin(startAngle);
            const x2 = CENTER + DOUBLE_OUTER * Math.cos(startAngle);
            const y2 = CENTER + DOUBLE_OUTER * Math.sin(startAngle);

            segments.push(
              <line key={`neon-wire-${i}`} x1={x1} y1={y1} x2={x2} y2={y2} stroke={colors.neonPrimary} strokeWidth={effects.wireWidth} style={{ filter: 'url(#neonGlow)', opacity: glowIntensity }} />
            );
          }

          // Ring wires with glow
          [OUTER_BULL, TRIPLE_INNER, TRIPLE_OUTER, DOUBLE_INNER, DOUBLE_OUTER].forEach((radius, idx) => {
            segments.push(
              <circle key={`neon-ring-${idx}`} cx={CENTER} cy={CENTER} r={radius} fill="none" stroke={colors.neonPrimary} strokeWidth={effects.wireWidth * 0.8} style={{ filter: 'url(#neonGlow)', opacity: glowIntensity }} />
            );
          });
        }

        // Overall radial lighting effect
        if (effects.useBoardLighting) {
          segments.push(
            <circle key="board-lighting" cx={CENTER} cy={CENTER} r={DOUBLE_OUTER + 2} fill="url(#boardLighting)" pointerEvents="none" />
          );
        }

        // Metallic sheen overlay for Gold Elite
        if (effects.useMetallicSheen && colors.metallicSheen) {
          segments.push(
            <circle key="metallic-sheen" cx={CENTER} cy={CENTER} r={DOUBLE_OUTER + 2} fill={colors.metallicSheen} pointerEvents="none" />
          );
        }

        // Numbers - rendered LAST to ensure they appear on top of all other elements
        const textStyle = effects.glowEffect ? { fontFamily: "'Oswald', sans-serif", filter: 'url(#neonGlow)' } : { fontFamily: "'Oswald', sans-serif" };
        const numberRadius = DOUBLE_OUTER + 16; // Position numbers between chrome ring and number ring edge

        for (let i = 0; i < 20; i++) {
          const textAngle = (i * 18 - 90) * (Math.PI / 180);
          const textX = CENTER + numberRadius * Math.cos(textAngle);
          const textY = CENTER + numberRadius * Math.sin(textAngle);

          // Text shadow (if enabled)
          if (effects.shadowIntensity > 0) {
            segments.push(
              <text key={`text-shadow-${i}`} x={textX + 0.5} y={textY + 0.5} fill="rgba(0,0,0,0.5)" fontSize="16" fontWeight="bold" textAnchor="middle" dominantBaseline="middle" style={{ fontFamily: "'Oswald', sans-serif" }}>
                {SEGMENTS[i]}
              </text>
            );
          }
          // Number text
          segments.push(
            <text key={`text-${i}`} x={textX} y={textY} fill={colors.numberText} fontSize="16" fontWeight="bold" textAnchor="middle" dominantBaseline="middle" style={textStyle}>
              {SEGMENTS[i]}
            </text>
          );
        }

        return segments.filter(Boolean); // Remove any false/null elements from conditional rendering
      };

      const renderDart = (position, index) => (
        <g key={index} transform={`translate(${position.x}, ${position.y})`}>
          <ellipse cx="0" cy="2" rx="4" ry="2" fill="rgba(0,0,0,0.3)" />
          <line x1="0" y1="-15" x2="0" y2="5" stroke="#c0c0c0" strokeWidth="2" />
          <polygon points="-4,-15 4,-15 0,-25" fill="#c41e3a" />
          <circle cx="0" cy="0" r="3" fill="#ffd700" />
          <polygon points="-6,5 6,5 0,-2" fill="#1a1a2e" />
        </g>
      );

      // Practice mode skill selection screen
      if (practiceMode === 'selecting') {
        return (
          <div style={{ minHeight: '100vh', background: COLORS.background, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', padding: '20px' }}>
            {/* Background gradient */}
            <div style={{
              position: 'fixed',
              inset: 0,
              background: `radial-gradient(ellipse at 30% 20%, ${COLORS.primary}40 0%, transparent 50%), radial-gradient(ellipse at 70% 80%, ${COLORS.accent}20 0%, transparent 40%), linear-gradient(180deg, ${COLORS.background} 0%, ${COLORS.backgroundLight} 100%)`,
              zIndex: 0
            }} />

            <div style={{
              background: COLORS.backgroundCard,
              borderRadius: '16px',
              padding: '48px 40px',
              border: '1px solid rgba(255, 255, 255, 0.05)',
              boxShadow: '0 25px 60px rgba(0, 0, 0, 0.5)',
              maxWidth: '420px',
              textAlign: 'center',
              width: '100%',
              position: 'relative',
              zIndex: 1
            }}>
              <div style={{ marginBottom: '24px' }}>
                <TargetIcon size={48} color={COLORS.accent} />
              </div>
              <h2 style={{ color: COLORS.text, fontSize: '1.75rem', marginBottom: '8px', fontWeight: '700' }}>Practice Mode</h2>
              <p style={{ color: COLORS.textMuted, fontSize: '1rem', marginBottom: '32px' }}>Select your skill level to begin</p>

              <div style={{ display: 'flex', flexDirection: 'column', gap: '12px', marginBottom: '24px' }}>
                <button
                  className="btn"
                  onClick={() => startPracticeSession(30)}
                  style={{
                    width: '100%',
                    padding: '16px 24px',
                    background: 'linear-gradient(135deg, #2D8A2D, #1f6b1f)',
                    color: '#fff',
                    border: 'none',
                    borderRadius: '10px',
                    cursor: 'pointer',
                    fontSize: '1rem',
                    fontWeight: '600',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    gap: '12px',
                    transition: 'all 0.2s ease'
                  }}
                >
                  <div style={{ width: '10px', height: '10px', borderRadius: '50%', background: '#4ade80' }} />
                  Beginner
                </button>

                <button
                  className="btn"
                  onClick={() => startPracticeSession(60)}
                  style={{
                    width: '100%',
                    padding: '16px 24px',
                    background: 'linear-gradient(135deg, #D4A03A, #B8862E)',
                    color: COLORS.textDark,
                    border: 'none',
                    borderRadius: '10px',
                    cursor: 'pointer',
                    fontSize: '1rem',
                    fontWeight: '600',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    gap: '12px',
                    transition: 'all 0.2s ease'
                  }}
                >
                  <div style={{ width: '10px', height: '10px', borderRadius: '50%', background: '#fcd34d' }} />
                  Intermediate
                </button>

                <button
                  className="btn"
                  onClick={() => startPracticeSession(90)}
                  style={{
                    width: '100%',
                    padding: '16px 24px',
                    background: 'linear-gradient(135deg, #C92A2A, #a82222)',
                    color: '#fff',
                    border: 'none',
                    borderRadius: '10px',
                    cursor: 'pointer',
                    fontSize: '1rem',
                    fontWeight: '600',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    gap: '12px',
                    transition: 'all 0.2s ease'
                  }}
                >
                  <div style={{ width: '10px', height: '10px', borderRadius: '50%', background: '#f87171' }} />
                  Expert
                </button>
              </div>

              <button
                className="btn btn-ghost"
                onClick={exitPracticeMode}
                style={{
                  width: '100%',
                  padding: '14px 24px',
                  fontSize: '0.9rem'
                }}
              >
                Back to Menu
              </button>
            </div>
          </div>
        );
      }

      // Matchmaking screen - check FIRST before menu
      if (matchmakingState === 'searching' || matchmakingState === 'found' || matchmakingState === 'intro') {
        return (
          <MatchmakingOverlay
            visible={true}
            stage={matchmakingState}
            isWagered={isWageredMatch}
            stakeAmount={selectedStake * 2}
            you={{
              name: sanitizeName(userProfile?.displayName) || 'You',
              level: sanitizeLevel(userProgression?.level) || 1,
              avatarUrl: sanitizeAvatarUrl(userProfile?.avatar)
            }}
            opponent={opponentName ? {
              name: opponentName,
              level: opponentLevel,
              avatarUrl: opponentAvatar
            } : null}
            onCancel={cancelMatchmaking}
          />
        );
      }

      // Login Modal
      if (showLoginModal) {
        return (
          <div style={{
            position: 'fixed',
            inset: 0,
            background: 'rgba(0, 0, 0, 0.8)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000,
            padding: '20px'
          }} onClick={() => setShowLoginModal(false)}>
            <div style={{
              background: COLORS.backgroundCard,
              borderRadius: '16px',
              padding: '32px',
              maxWidth: '400px',
              width: '100%',
              position: 'relative',
              border: '1px solid rgba(255, 255, 255, 0.1)'
            }} onClick={(e) => e.stopPropagation()}>
              {/* Close button */}
              <button onClick={() => setShowLoginModal(false)} style={{
                position: 'absolute',
                top: '16px',
                right: '16px',
                background: 'none',
                border: 'none',
                color: COLORS.textMuted,
                cursor: 'pointer',
                padding: '4px',
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center'
              }} aria-label="Close">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                  <line x1="18" y1="6" x2="6" y2="18"></line>
                  <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
              </button>

              {/* Header */}
              <h2 style={{
                color: COLORS.text,
                fontSize: '1.5rem',
                fontWeight: '700',
                textAlign: 'center',
                marginBottom: '24px',
                textTransform: 'uppercase',
                letterSpacing: '2px'
              }}>Login</h2>

              {/* Sign in buttons */}
              <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                {/* Facebook */}
                <button onClick={signInWithFacebook} style={{
                  width: '100%',
                  padding: '14px 20px',
                  borderRadius: '8px',
                  border: 'none',
                  background: '#1877F2',
                  color: 'white',
                  fontSize: '1rem',
                  fontWeight: '600',
                  cursor: 'pointer',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '12px',
                  fontFamily: 'var(--font-primary)'
                }}>
                  <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M24 12.073c0-6.627-5.373-12-12-12s-12 5.373-12 12c0 5.99 4.388 10.954 10.125 11.854v-8.385H7.078v-3.47h3.047V9.43c0-3.007 1.792-4.669 4.533-4.669 1.312 0 2.686.235 2.686.235v2.953H15.83c-1.491 0-1.956.925-1.956 1.874v2.25h3.328l-.532 3.47h-2.796v8.385C19.612 23.027 24 18.062 24 12.073z"/>
                  </svg>
                  Sign in with Facebook
                </button>

                {/* Google */}
                <button onClick={signInWithGoogle} style={{
                  width: '100%',
                  padding: '14px 20px',
                  borderRadius: '8px',
                  border: '1px solid rgba(255, 255, 255, 0.2)',
                  background: 'white',
                  color: '#333',
                  fontSize: '1rem',
                  fontWeight: '600',
                  cursor: 'pointer',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '12px',
                  fontFamily: 'var(--font-primary)'
                }}>
                  <svg width="20" height="20" viewBox="0 0 24 24">
                    <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                    <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                    <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                    <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                  </svg>
                  Sign in with Google
                </button>
              </div>

              {/* Divider */}
              <div style={{
                display: 'flex',
                alignItems: 'center',
                margin: '24px 0',
                gap: '12px'
              }}>
                <div style={{ flex: 1, height: '1px', background: 'rgba(255, 255, 255, 0.1)' }}></div>
                <span style={{ color: COLORS.textMuted, fontSize: '0.85rem' }}>OR</span>
                <div style={{ flex: 1, height: '1px', background: 'rgba(255, 255, 255, 0.1)' }}></div>
              </div>

              {/* Continue as guest */}
              <button onClick={() => setShowLoginModal(false)} style={{
                width: '100%',
                padding: '14px 20px',
                borderRadius: '8px',
                border: '1px solid rgba(255, 255, 255, 0.1)',
                background: 'transparent',
                color: COLORS.textMuted,
                fontSize: '0.95rem',
                cursor: 'pointer',
                fontFamily: 'var(--font-primary)'
              }}>
                Continue as Guest
              </button>

              {/* Info text */}
              <p style={{
                color: COLORS.textMuted,
                fontSize: '0.8rem',
                textAlign: 'center',
                marginTop: '16px',
                lineHeight: '1.5'
              }}>
                Sign in to save your progress, track stats, and compete on leaderboards.
              </p>
            </div>
          </div>
        );
      }

      // Stake Selection Modal
      if (showStakeSelection) {
        const stakeOptions = [
          { amount: 50, label: 'Casual', description: 'Low stakes, perfect for warming up' },
          { amount: 100, label: 'Standard', description: 'The most popular stake level' },
          { amount: 500, label: 'High Roller', description: 'For confident players' },
          { amount: 2500, label: 'Champion', description: 'Maximum risk, maximum reward' }
        ];

        return (
          <div style={{
            position: 'fixed',
            inset: 0,
            background: 'rgba(0, 0, 0, 0.85)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000,
            padding: '20px'
          }} onClick={() => setShowStakeSelection(false)}>
            <div style={{
              background: COLORS.backgroundCard,
              borderRadius: '16px',
              padding: '32px',
              maxWidth: '450px',
              width: '100%',
              position: 'relative',
              border: '1px solid rgba(255, 255, 255, 0.1)'
            }} onClick={(e) => e.stopPropagation()}>
              {/* Close button */}
              <button onClick={() => setShowStakeSelection(false)} style={{
                position: 'absolute',
                top: '16px',
                right: '16px',
                background: 'none',
                border: 'none',
                color: COLORS.textMuted,
                cursor: 'pointer',
                padding: '4px'
              }}>
                <CloseIcon size={24} />
              </button>

              {/* Header */}
              <div style={{ textAlign: 'center', marginBottom: '24px' }}>
                <h2 style={{ color: COLORS.text, fontSize: '1.5rem', fontWeight: '700', marginBottom: '8px' }}>
                  Choose Your Stake
                </h2>
                <div style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '8px',
                  marginBottom: '8px'
                }}>
                  <CoinIcon size={20} />
                  <span style={{ color: '#D4A03A', fontWeight: '600', fontSize: '1.1rem' }}>
                    Your Balance: {formatCoins(coinBalance)}
                  </span>
                </div>
                <p style={{ color: COLORS.textMuted, fontSize: '0.9rem' }}>
                  Winner takes the entire pot!
                </p>
              </div>

              {/* Stake options */}
              <div style={{ display: 'flex', flexDirection: 'column', gap: '12px', marginBottom: '24px' }}>
                {stakeOptions.map((option) => {
                  const isSelected = selectedStake === option.amount;
                  const canAfford = coinBalance >= option.amount;
                  const potAmount = option.amount * 2;

                  return (
                    <button
                      key={option.amount}
                      onClick={() => canAfford && setSelectedStake(option.amount)}
                      disabled={!canAfford}
                      style={{
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'space-between',
                        padding: '16px 20px',
                        borderRadius: '12px',
                        border: isSelected
                          ? '2px solid #D4A03A'
                          : '1px solid rgba(255, 255, 255, 0.1)',
                        background: isSelected
                          ? 'rgba(212, 160, 58, 0.15)'
                          : canAfford
                          ? 'rgba(255, 255, 255, 0.03)'
                          : 'rgba(255, 255, 255, 0.02)',
                        cursor: canAfford ? 'pointer' : 'not-allowed',
                        opacity: canAfford ? 1 : 0.5,
                        transition: 'all 0.2s ease'
                      }}
                    >
                      <div style={{ textAlign: 'left' }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                          <span style={{ color: COLORS.text, fontWeight: '600', fontSize: '1rem' }}>
                            {option.label}
                          </span>
                          {!canAfford && (
                            <span style={{
                              color: COLORS.error,
                              fontSize: '0.7rem',
                              fontWeight: '600',
                              padding: '2px 6px',
                              background: 'rgba(201, 42, 42, 0.2)',
                              borderRadius: '4px'
                            }}>
                              Need {option.amount - coinBalance} more
                            </span>
                          )}
                        </div>
                        <p style={{ color: COLORS.textMuted, fontSize: '0.8rem', margin: '4px 0 0 0' }}>
                          {option.description}
                        </p>
                      </div>
                      <div style={{ textAlign: 'right' }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '4px', color: '#D4A03A', fontWeight: '700' }}>
                          <CoinIcon size={14} />
                          <span>{formatCoins(option.amount)}</span>
                        </div>
                        <p style={{ color: COLORS.success, fontSize: '0.75rem', margin: '4px 0 0 0' }}>
                          Win {formatCoins(potAmount)}
                        </p>
                      </div>
                    </button>
                  );
                })}
              </div>

              {/* Play button */}
              <button
                onClick={startWageredMatchmaking}
                disabled={coinBalance < selectedStake}
                style={{
                  width: '100%',
                  padding: '16px 24px',
                  borderRadius: '10px',
                  border: 'none',
                  background: coinBalance >= selectedStake
                    ? 'linear-gradient(135deg, #D4A03A, #B8862E)'
                    : 'rgba(255, 255, 255, 0.1)',
                  color: coinBalance >= selectedStake ? COLORS.textDark : COLORS.textMuted,
                  fontSize: '1rem',
                  fontWeight: '700',
                  cursor: coinBalance >= selectedStake ? 'pointer' : 'not-allowed',
                  fontFamily: 'var(--font-primary)',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '8px'
                }}
              >
                <GlobeIcon size={20} color={coinBalance >= selectedStake ? COLORS.textDark : COLORS.textMuted} />
                Play for {formatCoins(selectedStake)} Coins
              </button>

              {/* Play free option */}
              <button
                onClick={() => { setShowStakeSelection(false); startMatchmaking(); }}
                style={{
                  width: '100%',
                  marginTop: '12px',
                  padding: '12px',
                  borderRadius: '8px',
                  border: '1px solid rgba(255, 255, 255, 0.1)',
                  background: 'transparent',
                  color: COLORS.textMuted,
                  fontSize: '0.9rem',
                  cursor: 'pointer',
                  fontFamily: 'var(--font-primary)'
                }}
              >
                Play Free (No Stakes)
              </button>
            </div>
          </div>
        );
      }

      // Leave Match Confirmation Modal
      if (showLeaveConfirmation) {
        return (
          <div style={{
            position: 'fixed',
            inset: 0,
            background: 'rgba(0, 0, 0, 0.85)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1001,
            padding: '20px'
          }}>
            <div style={{
              background: COLORS.backgroundCard,
              borderRadius: '16px',
              padding: '32px',
              maxWidth: '400px',
              width: '100%',
              position: 'relative',
              border: '1px solid rgba(255, 255, 255, 0.1)',
              textAlign: 'center'
            }}>
              {/* Warning Icon */}
              <div style={{
                width: '64px',
                height: '64px',
                borderRadius: '50%',
                background: `${COLORS.error}20`,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                margin: '0 auto 20px'
              }}>
                <span style={{ fontSize: '32px' }}>‚ö†Ô∏è</span>
              </div>

              {/* Title */}
              <h2 style={{
                color: COLORS.text,
                fontSize: '1.3rem',
                fontWeight: '700',
                marginBottom: '12px'
              }}>Leave Match?</h2>

              {/* Message */}
              <p style={{
                color: COLORS.textMuted,
                fontSize: '1rem',
                marginBottom: '24px',
                lineHeight: '1.5'
              }}>
                Are you sure you want to leave? You will forfeit your coins.
              </p>

              {/* Stakes display */}
              {escrowData && (
                <div style={{
                  background: 'rgba(255, 255, 255, 0.05)',
                  borderRadius: '8px',
                  padding: '12px',
                  marginBottom: '24px',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '8px'
                }}>
                  <CoinIcon size={18} />
                  <span style={{ color: '#D4A03A', fontWeight: '600' }}>
                    {formatCoins(escrowData.stakeLevel || 0)} at stake
                  </span>
                </div>
              )}

              {/* Buttons */}
              <div style={{ display: 'flex', gap: '12px' }}>
                {/* No - Stay in game */}
                <button
                  onClick={() => setShowLeaveConfirmation(false)}
                  style={{
                    flex: 1,
                    padding: '14px 20px',
                    borderRadius: '10px',
                    border: '1px solid rgba(255, 255, 255, 0.2)',
                    background: 'transparent',
                    color: COLORS.text,
                    fontSize: '1rem',
                    fontWeight: '600',
                    cursor: 'pointer',
                    fontFamily: 'var(--font-primary)'
                  }}
                >
                  No, Stay
                </button>

                {/* Yes - Leave and forfeit */}
                <button
                  onClick={() => {
                    setShowLeaveConfirmation(false);
                    leaveOnlineGame();
                  }}
                  style={{
                    flex: 1,
                    padding: '14px 20px',
                    borderRadius: '10px',
                    border: 'none',
                    background: COLORS.error,
                    color: 'white',
                    fontSize: '1rem',
                    fontWeight: '600',
                    cursor: 'pointer',
                    fontFamily: 'var(--font-primary)'
                  }}
                >
                  Yes, Leave
                </button>
              </div>
            </div>
          </div>
        );
      }

      // Coin Shop Modal
      if (showCoinShop) {
        return (
          <div style={{
            position: 'fixed',
            inset: 0,
            background: 'rgba(0, 0, 0, 0.85)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000,
            padding: '20px'
          }} onClick={() => setShowCoinShop(false)}>
            <div style={{
              background: COLORS.backgroundCard,
              borderRadius: '16px',
              padding: '32px',
              maxWidth: '500px',
              width: '100%',
              position: 'relative',
              border: '1px solid rgba(255, 255, 255, 0.1)',
              maxHeight: '90vh',
              overflowY: 'auto'
            }} onClick={(e) => e.stopPropagation()}>
              {/* Close button */}
              <button onClick={() => setShowCoinShop(false)} style={{
                position: 'absolute',
                top: '16px',
                right: '16px',
                background: 'none',
                border: 'none',
                color: COLORS.textMuted,
                cursor: 'pointer',
                padding: '4px'
              }}>
                <CloseIcon size={24} />
              </button>

              {/* Header */}
              <div style={{ textAlign: 'center', marginBottom: '24px' }}>
                <h2 style={{ color: COLORS.text, fontSize: '1.5rem', fontWeight: '700', marginBottom: '8px' }}>
                  Coin Shop
                </h2>
                <div style={{
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '8px',
                  marginBottom: '8px'
                }}>
                  <CoinIcon size={20} />
                  <span style={{ color: '#D4A03A', fontWeight: '600', fontSize: '1.1rem' }}>
                    Your Balance: {formatCoins(coinBalance)}
                  </span>
                </div>
                <p style={{ color: COLORS.textMuted, fontSize: '0.9rem' }}>
                  Purchase coins to play wagered matches!
                </p>
              </div>

              {/* Coin packages */}
              <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                {COIN_PACKAGES.map((pkg) => (
                  <button
                    key={pkg.id}
                    onClick={() => purchaseCoins(pkg.id)}
                    disabled={isPurchasing}
                    style={{
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'space-between',
                      padding: '16px 20px',
                      borderRadius: '12px',
                      border: pkg.popular
                        ? '2px solid #D4A03A'
                        : '1px solid rgba(255, 255, 255, 0.1)',
                      background: pkg.popular
                        ? 'rgba(212, 160, 58, 0.15)'
                        : 'rgba(255, 255, 255, 0.03)',
                      cursor: isPurchasing ? 'wait' : 'pointer',
                      opacity: isPurchasing ? 0.7 : 1,
                      transition: 'all 0.2s ease',
                      position: 'relative'
                    }}
                  >
                    {pkg.popular && (
                      <span style={{
                        position: 'absolute',
                        top: '-10px',
                        left: '20px',
                        background: 'linear-gradient(135deg, #D4A03A, #B8862E)',
                        color: '#0D1117',
                        padding: '2px 10px',
                        borderRadius: '10px',
                        fontSize: '0.7rem',
                        fontWeight: '700'
                      }}>
                        POPULAR
                      </span>
                    )}
                    <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                      <CoinIcon size={24} />
                      <span style={{ color: COLORS.text, fontWeight: '600', fontSize: '1.1rem' }}>
                        {formatCoins(pkg.coins)}
                      </span>
                    </div>
                    <span style={{
                      color: '#D4A03A',
                      fontWeight: '700',
                      fontSize: '1rem',
                      background: 'rgba(212, 160, 58, 0.2)',
                      padding: '6px 14px',
                      borderRadius: '8px'
                    }}>
                      {pkg.price}
                    </span>
                  </button>
                ))}
              </div>

              {/* Footer */}
              <p style={{
                color: COLORS.textMuted,
                fontSize: '0.75rem',
                textAlign: 'center',
                marginTop: '20px'
              }}>
                Secure payment via Stripe. Coins are non-refundable.
              </p>
            </div>
          </div>
        );
      }

      // Profile Screen - check BEFORE menu
      if (showProfileScreen && currentUser && !currentUser.isAnonymous) {
        // Level system calculations (matching server-side logic)
        const getXPForLevel = (level) => {
          if (level <= 1) return 0;
          return Math.floor(50 * level * Math.pow(1.08, level - 1));
        };

        const level = userProgression?.level || 1;
        const xp = userProgression?.xp || 0;
        const currentLevelXP = getXPForLevel(level);
        const nextLevelXP = getXPForLevel(level + 1);
        const xpProgress = nextLevelXP > currentLevelXP ? (xp - currentLevelXP) / (nextLevelXP - currentLevelXP) : 1;

        const gamesPlayed = userProgression?.gamesPlayed || 0;
        const gamesWon = userProgression?.gamesWon || 0;
        const winPercentage = gamesPlayed > 0 ? ((gamesWon / gamesPlayed) * 100).toFixed(1) : '0.0';
        const bestStreak = userStreaks?.bestWinStreak || 0;
        const currentStreak = userStreaks?.currentWinStreak || 0;

        // Rank titles based on level
        const getRankTitle = (lvl) => {
          if (lvl >= 80) return 'Legend';
          if (lvl >= 60) return 'Master';
          if (lvl >= 40) return 'Expert';
          if (lvl >= 25) return 'Veteran';
          if (lvl >= 15) return 'Skilled';
          if (lvl >= 8) return 'Amateur';
          if (lvl >= 3) return 'Novice';
          return 'Rookie';
        };

        const rankTitle = getRankTitle(level);

        const copyUniqueId = () => {
          const uniqueId = userProfile?.uniqueId || 'N/A';
          navigator.clipboard.writeText(uniqueId).then(() => {
            alert('Player ID copied to clipboard!');
          }).catch(() => {
            alert('Failed to copy ID');
          });
        };

        return (
          <div style={{ minHeight: '100vh', background: COLORS.background, display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '80px 20px 40px' }}>
            {/* Background gradient */}
            <div style={{
              position: 'fixed',
              inset: 0,
              background: `radial-gradient(ellipse at 30% 20%, ${COLORS.primary}40 0%, transparent 50%), radial-gradient(ellipse at 70% 80%, ${COLORS.accent}20 0%, transparent 40%), linear-gradient(180deg, ${COLORS.background} 0%, ${COLORS.backgroundLight} 100%)`,
              zIndex: 0
            }} />

            <div style={{ maxWidth: '900px', width: '100%', position: 'relative', zIndex: 1 }}>
              {/* Header */}
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '32px' }}>
                <h1 style={{ fontSize: 'clamp(1.75rem, 4vw, 2.5rem)', fontWeight: '700', color: COLORS.text, margin: 0 }}>Profile</h1>
                <button className="btn btn-ghost" onClick={() => setShowProfileScreen(false)} style={{ padding: '12px 24px' }}>Back</button>
              </div>

              {/* Main content - two columns on desktop */}
              <div style={{ display: 'grid', gridTemplateColumns: 'minmax(280px, 1fr) 2fr', gap: '24px' }}>
                {/* Left column - Avatar and basic info */}
                <div style={{
                  background: COLORS.backgroundCard,
                  borderRadius: '16px',
                  padding: '32px 24px',
                  border: '1px solid rgba(255, 255, 255, 0.05)',
                  textAlign: 'center'
                }}>
                  {/* Avatar with frame */}
                  <div style={{
                    position: 'relative',
                    width: '120px',
                    height: '120px',
                    margin: '0 auto 20px',
                    borderRadius: '50%',
                    background: `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})`,
                    padding: '4px',
                    boxShadow: `0 0 20px ${COLORS.accent}40`
                  }}>
                    {currentUser.photoURL ? (
                      <img
                        src={currentUser.photoURL}
                        alt="Profile"
                        style={{ width: '100%', height: '100%', borderRadius: '50%', objectFit: 'cover' }}
                        referrerPolicy="no-referrer"
                      />
                    ) : (
                      <div style={{
                        width: '100%',
                        height: '100%',
                        borderRadius: '50%',
                        background: COLORS.backgroundLight,
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        fontSize: '48px',
                        fontWeight: '700',
                        color: COLORS.accent
                      }}>
                        {(userProfile?.displayName || currentUser.displayName || 'P')[0].toUpperCase()}
                      </div>
                    )}
                    {/* Level badge */}
                    <div style={{
                      position: 'absolute',
                      bottom: '-5px',
                      right: '-5px',
                      background: `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})`,
                      borderRadius: '50%',
                      width: '36px',
                      height: '36px',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      fontWeight: '700',
                      fontSize: '14px',
                      color: COLORS.textDark,
                      border: `3px solid ${COLORS.background}`
                    }}>
                      {level}
                    </div>
                  </div>

                  {/* Display name with edit option */}
                  {isEditingNickname ? (
                    <div style={{ marginBottom: '16px' }}>
                      <input
                        type="text"
                        value={nicknameInput}
                        onChange={(e) => setNicknameInput(e.target.value.slice(0, 20))}
                        placeholder="Enter nickname..."
                        maxLength={20}
                        autoFocus
                        style={{
                          width: '100%',
                          padding: '10px 12px',
                          background: 'rgba(255, 255, 255, 0.1)',
                          border: `1px solid ${COLORS.accent}`,
                          borderRadius: '8px',
                          color: COLORS.text,
                          fontSize: '1rem',
                          textAlign: 'center',
                          marginBottom: '10px',
                          outline: 'none',
                          fontFamily: "'Inter', sans-serif"
                        }}
                        onKeyDown={(e) => {
                          if (e.key === 'Enter') saveNickname();
                          if (e.key === 'Escape') {
                            setIsEditingNickname(false);
                            setNicknameInput('');
                          }
                        }}
                      />
                      <div style={{ display: 'flex', gap: '8px', justifyContent: 'center' }}>
                        <button
                          onClick={saveNickname}
                          style={{
                            padding: '8px 16px',
                            background: COLORS.success,
                            color: COLORS.text,
                            border: 'none',
                            borderRadius: '6px',
                            fontSize: '0.85rem',
                            fontWeight: '600',
                            cursor: 'pointer'
                          }}
                        >
                          Save
                        </button>
                        <button
                          onClick={() => {
                            setIsEditingNickname(false);
                            setNicknameInput('');
                          }}
                          style={{
                            padding: '8px 16px',
                            background: 'rgba(255, 255, 255, 0.1)',
                            color: COLORS.textMuted,
                            border: '1px solid rgba(255, 255, 255, 0.2)',
                            borderRadius: '6px',
                            fontSize: '0.85rem',
                            fontWeight: '600',
                            cursor: 'pointer'
                          }}
                        >
                          Cancel
                        </button>
                      </div>
                    </div>
                  ) : (
                    <div style={{ marginBottom: '8px' }}>
                      <h2 style={{ color: COLORS.text, fontSize: '1.5rem', fontWeight: '600', margin: '0 0 4px 0', display: 'inline' }}>
                        {userProfile?.displayName || currentUser.displayName || 'Player'}
                      </h2>
                      <button
                        onClick={() => {
                          setNicknameInput(userProfile?.displayName || currentUser.displayName || '');
                          setIsEditingNickname(true);
                        }}
                        style={{
                          background: 'none',
                          border: 'none',
                          color: COLORS.accent,
                          cursor: 'pointer',
                          padding: '4px 8px',
                          fontSize: '14px',
                          verticalAlign: 'middle',
                          marginLeft: '4px'
                        }}
                        title="Edit display name"
                      >
                        ‚úèÔ∏è
                      </button>
                    </div>
                  )}

                  {/* Flag */}
                  <div style={{ color: COLORS.textMuted, fontSize: '1rem', marginBottom: '16px' }}>
                    {userProfile?.flag || 'üåç'} {rankTitle}
                  </div>

                  {/* Unique ID */}
                  <div style={{
                    background: 'rgba(255, 255, 255, 0.05)',
                    borderRadius: '8px',
                    padding: '12px',
                    marginBottom: '20px'
                  }}>
                    <div style={{ color: COLORS.textMuted, fontSize: '0.75rem', marginBottom: '4px' }}>Player ID</div>
                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px' }}>
                      <span style={{ color: COLORS.accent, fontWeight: '600', fontFamily: 'monospace', fontSize: '1rem' }}>
                        {userProfile?.uniqueId || 'N/A'}
                      </span>
                      <button
                        onClick={copyUniqueId}
                        style={{
                          background: 'none',
                          border: 'none',
                          color: COLORS.textMuted,
                          cursor: 'pointer',
                          padding: '4px',
                          fontSize: '16px'
                        }}
                        title="Copy ID"
                      >
                        üìã
                      </button>
                    </div>
                  </div>

                  {/* Coin balance */}
                  <div style={{
                    background: 'rgba(212, 160, 58, 0.1)',
                    borderRadius: '8px',
                    padding: '12px',
                    border: '1px solid rgba(212, 160, 58, 0.2)'
                  }}>
                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', gap: '8px' }}>
                      <CoinIcon size={20} />
                      <span style={{ color: COLORS.accent, fontWeight: '700', fontSize: '1.25rem' }}>
                        {formatCoins(coinBalance)}
                      </span>
                    </div>
                  </div>
                </div>

                {/* Right column - Stats */}
                <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
                  {/* Level Progress */}
                  <div style={{
                    background: COLORS.backgroundCard,
                    borderRadius: '12px',
                    padding: '20px',
                    border: '1px solid rgba(255, 255, 255, 0.05)'
                  }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                      <span style={{ color: COLORS.textMuted, fontSize: '0.85rem' }}>Level Progress</span>
                      <span style={{ color: COLORS.accent, fontWeight: '600' }}>Level {level}</span>
                    </div>
                    <div style={{ background: 'rgba(255, 255, 255, 0.1)', borderRadius: '8px', height: '12px', overflow: 'hidden', marginBottom: '8px' }}>
                      <div style={{
                        background: `linear-gradient(90deg, ${COLORS.accent}, ${COLORS.accentLight})`,
                        height: '100%',
                        width: `${xpProgress * 100}%`,
                        borderRadius: '8px',
                        transition: 'width 0.5s'
                      }}></div>
                    </div>
                    <div style={{ display: 'flex', justifyContent: 'space-between', color: COLORS.textMuted, fontSize: '0.8rem' }}>
                      <span>{formatCoins(xp)} XP</span>
                      <span>{formatCoins(nextLevelXP)} XP</span>
                    </div>
                  </div>

                  {/* Player Stats Grid */}
                  <div style={{
                    background: COLORS.backgroundCard,
                    borderRadius: '12px',
                    padding: '20px',
                    border: '1px solid rgba(255, 255, 255, 0.05)'
                  }}>
                    <h3 style={{ color: COLORS.text, fontSize: '1rem', fontWeight: '600', margin: '0 0 16px 0' }}>Player Stats</h3>
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '16px' }}>
                      <div style={{ background: 'rgba(255, 255, 255, 0.03)', borderRadius: '8px', padding: '12px' }}>
                        <div style={{ color: COLORS.textMuted, fontSize: '0.75rem', marginBottom: '4px' }}>Games Played</div>
                        <div style={{ color: COLORS.text, fontSize: '1.25rem', fontWeight: '600' }}>{gamesPlayed}</div>
                      </div>
                      <div style={{ background: 'rgba(255, 255, 255, 0.03)', borderRadius: '8px', padding: '12px' }}>
                        <div style={{ color: COLORS.textMuted, fontSize: '0.75rem', marginBottom: '4px' }}>Games Won</div>
                        <div style={{ color: '#27ae60', fontSize: '1.25rem', fontWeight: '600' }}>{gamesWon}</div>
                      </div>
                      <div style={{ background: 'rgba(255, 255, 255, 0.03)', borderRadius: '8px', padding: '12px' }}>
                        <div style={{ color: COLORS.textMuted, fontSize: '0.75rem', marginBottom: '4px' }}>Win Rate</div>
                        <div style={{ color: COLORS.accent, fontSize: '1.25rem', fontWeight: '600' }}>{winPercentage}%</div>
                      </div>
                      <div style={{ background: 'rgba(255, 255, 255, 0.03)', borderRadius: '8px', padding: '12px' }}>
                        <div style={{ color: COLORS.textMuted, fontSize: '0.75rem', marginBottom: '4px' }}>Total Earnings</div>
                        <div style={{ color: COLORS.accent, fontSize: '1.25rem', fontWeight: '600' }}>{formatCoins(coinBalance)}</div>
                      </div>
                    </div>
                  </div>

                  {/* Streaks */}
                  <div style={{
                    background: COLORS.backgroundCard,
                    borderRadius: '12px',
                    padding: '20px',
                    border: '1px solid rgba(255, 255, 255, 0.05)'
                  }}>
                    <h3 style={{ color: COLORS.text, fontSize: '1rem', fontWeight: '600', margin: '0 0 16px 0' }}>Win Streaks</h3>
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '16px' }}>
                      <div style={{ background: 'rgba(255, 255, 255, 0.03)', borderRadius: '8px', padding: '12px' }}>
                        <div style={{ color: COLORS.textMuted, fontSize: '0.75rem', marginBottom: '4px' }}>Current Streak</div>
                        <div style={{ color: currentStreak > 0 ? '#27ae60' : COLORS.text, fontSize: '1.25rem', fontWeight: '600' }}>
                          {currentStreak} {currentStreak > 0 && 'üî•'}
                        </div>
                      </div>
                      <div style={{ background: 'rgba(255, 255, 255, 0.03)', borderRadius: '8px', padding: '12px' }}>
                        <div style={{ color: COLORS.textMuted, fontSize: '0.75rem', marginBottom: '4px' }}>Best Streak</div>
                        <div style={{ color: COLORS.accent, fontSize: '1.25rem', fontWeight: '600' }}>{bestStreak} üèÜ</div>
                      </div>
                    </div>
                  </div>

                  {/* Achievements Progress */}
                  <div style={{
                    background: COLORS.backgroundCard,
                    borderRadius: '12px',
                    padding: '20px',
                    border: '1px solid rgba(255, 255, 255, 0.05)'
                  }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                      <h3 style={{ color: COLORS.text, fontSize: '1rem', fontWeight: '600', margin: 0 }}>Achievements</h3>
                      <button
                        onClick={() => { setShowProfileScreen(false); setShowAchievements(true); }}
                        style={{
                          background: 'none',
                          border: 'none',
                          color: COLORS.accent,
                          cursor: 'pointer',
                          fontSize: '0.85rem',
                          fontWeight: '500'
                        }}
                      >
                        View All ‚Üí
                      </button>
                    </div>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                      <span style={{ color: COLORS.textMuted, fontSize: '0.85rem' }}>Progress</span>
                      <span style={{ color: COLORS.accent, fontWeight: '600' }}>{unlockedAchievements.length} / {ACHIEVEMENTS_DATA.length}</span>
                    </div>
                    <div style={{ background: 'rgba(255, 255, 255, 0.1)', borderRadius: '8px', height: '8px', overflow: 'hidden' }}>
                      <div style={{
                        background: `linear-gradient(90deg, ${COLORS.accent}, ${COLORS.accentLight})`,
                        height: '100%',
                        width: `${(unlockedAchievements.length / ACHIEVEMENTS_DATA.length) * 100}%`,
                        borderRadius: '8px'
                      }}></div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        );
      }

      // Achievements Gallery - check BEFORE menu
      if (showAchievements) {
        return (
          <div style={{ minHeight: '100vh', background: COLORS.background, display: 'flex', flexDirection: 'column', alignItems: 'center', padding: '80px 20px 40px' }}>
            {/* Background gradient */}
            <div style={{
              position: 'fixed',
              inset: 0,
              background: `radial-gradient(ellipse at 30% 20%, ${COLORS.primary}40 0%, transparent 50%), radial-gradient(ellipse at 70% 80%, ${COLORS.accent}20 0%, transparent 40%), linear-gradient(180deg, ${COLORS.background} 0%, ${COLORS.backgroundLight} 100%)`,
              zIndex: 0
            }} />

            <div style={{ maxWidth: '1000px', width: '100%', position: 'relative', zIndex: 1 }}>
              {/* Header */}
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '32px' }}>
                <div>
                  <h1 style={{ fontSize: 'clamp(1.75rem, 4vw, 2.5rem)', fontWeight: '700', color: COLORS.text, margin: 0 }}>Achievements</h1>
                  <p style={{ color: COLORS.textMuted, fontSize: '1rem', marginTop: '4px' }}>Track your progress and unlock rewards</p>
                </div>
                <button className="btn btn-ghost" onClick={() => setShowAchievements(false)} style={{ padding: '12px 24px' }}>Back</button>
              </div>

              {/* Achievement Category Tabs */}
              <div style={{
                display: 'flex',
                gap: '8px',
                marginBottom: '24px',
                background: COLORS.backgroundCard,
                borderRadius: '12px',
                padding: '6px',
                border: '1px solid rgba(255, 255, 255, 0.05)'
              }}>
                {['offline', 'online'].map(tab => {
                  const isActive = achievementTab === tab;
                  const tabAchievements = ACHIEVEMENTS_DATA.filter(a => a.mode === tab);
                  const tabUnlocked = unlockedAchievements.filter(id =>
                    ACHIEVEMENTS_DATA.find(a => a.id === id)?.mode === tab
                  );
                  return (
                    <button
                      key={tab}
                      onClick={() => setAchievementTab(tab)}
                      style={{
                        flex: 1,
                        padding: '14px 20px',
                        borderRadius: '8px',
                        border: 'none',
                        cursor: 'pointer',
                        fontWeight: '600',
                        fontSize: '0.95rem',
                        fontFamily: "'Inter', sans-serif",
                        transition: 'all 0.2s ease',
                        background: isActive
                          ? tab === 'offline'
                            ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})`
                            : 'linear-gradient(135deg, #60a5fa, #3b82f6)'
                          : 'transparent',
                        color: isActive ? (tab === 'offline' ? COLORS.textDark : '#fff') : COLORS.textMuted
                      }}
                    >
                      <span style={{ marginRight: '8px' }}>{tab === 'offline' ? 'üéÆ' : 'üåç'}</span>
                      {tab === 'offline' ? 'Offline' : 'Online'}
                      <span style={{ marginLeft: '8px', fontSize: '0.8rem', opacity: 0.9 }}>
                        {tabUnlocked.length}/{tabAchievements.length}
                      </span>
                    </button>
                  );
                })}
              </div>

              {/* Progress Card - Tab-Specific */}
              {(() => {
                const tabAchievements = ACHIEVEMENTS_DATA.filter(a => a.mode === achievementTab);
                const tabUnlocked = unlockedAchievements.filter(id =>
                  ACHIEVEMENTS_DATA.find(a => a.id === id)?.mode === achievementTab
                );
                const progress = tabAchievements.length > 0 ? (tabUnlocked.length / tabAchievements.length) * 100 : 0;

                return (
                  <div style={{
                    background: COLORS.backgroundCard,
                    borderRadius: '12px',
                    padding: '24px',
                    marginBottom: '32px',
                    border: '1px solid rgba(255, 255, 255, 0.05)'
                  }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '12px' }}>
                      <span style={{ color: COLORS.textMuted, fontSize: '0.9rem' }}>
                        {achievementTab === 'offline' ? 'Offline Progress' : 'Online Progress'}
                      </span>
                      <span style={{ color: achievementTab === 'offline' ? COLORS.accent : '#60a5fa', fontSize: '1rem', fontWeight: '600' }}>
                        {tabUnlocked.length} / {tabAchievements.length}
                      </span>
                    </div>
                    <div style={{ background: 'rgba(255, 255, 255, 0.1)', borderRadius: '8px', height: '8px', overflow: 'hidden' }}>
                      <div style={{
                        background: achievementTab === 'offline'
                          ? `linear-gradient(90deg, ${COLORS.accent}, ${COLORS.accentLight})`
                          : 'linear-gradient(90deg, #60a5fa, #93c5fd)',
                        height: '100%',
                        width: `${progress}%`,
                        transition: 'width 0.5s',
                        borderRadius: '8px'
                      }}></div>
                    </div>
                    <div style={{ marginTop: '8px', fontSize: '0.75rem', color: COLORS.textMuted, textAlign: 'right' }}>
                      Total: {unlockedAchievements.length} / {ACHIEVEMENTS_DATA.length}
                    </div>
                  </div>
                );
              })()}

              {/* Weekly Challenge Section */}
              {(() => {
                const activeChallenge = getActiveTimeLimitedAchievement();
                if (!activeChallenge) return null;
                const current = weeklyChallenge.stats[activeChallenge.statKey] || 0;
                const progress = Math.min(current / activeChallenge.target, 1);
                const isCompleted = weeklyChallenge.completed;
                return (
                  <div style={{
                    background: `linear-gradient(135deg, ${COLORS.backgroundCard}, rgba(155, 89, 182, 0.1))`,
                    borderRadius: '12px',
                    padding: '24px',
                    marginBottom: '32px',
                    border: `1px solid ${isCompleted ? '#27ae60' : '#9b59b6'}40`,
                    position: 'relative',
                    overflow: 'hidden'
                  }}>
                    {/* Time badge */}
                    <div style={{
                      position: 'absolute',
                      top: '16px',
                      right: '16px',
                      background: 'rgba(155, 89, 182, 0.2)',
                      borderRadius: '20px',
                      padding: '6px 12px',
                      display: 'flex',
                      alignItems: 'center',
                      gap: '6px'
                    }}>
                      <span style={{ fontSize: '0.75rem', color: '#9b59b6' }}>Ends in</span>
                      <span style={{ fontSize: '0.85rem', fontWeight: '600', color: COLORS.text }}>{formatTimeRemaining(timeUntilReset)}</span>
                    </div>

                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px', marginBottom: '8px' }}>
                      <span style={{ fontSize: '0.7rem', fontWeight: '600', textTransform: 'uppercase', letterSpacing: '1px', color: '#9b59b6' }}>Weekly Challenge</span>
                      {isCompleted && <span style={{ fontSize: '0.7rem', fontWeight: '600', color: '#27ae60', background: 'rgba(39, 174, 96, 0.2)', padding: '2px 8px', borderRadius: '4px' }}>Completed!</span>}
                    </div>

                    <div style={{ display: 'flex', alignItems: 'center', gap: '16px', marginBottom: '16px' }}>
                      <div style={{
                        fontSize: '40px',
                        background: isCompleted ? 'rgba(39, 174, 96, 0.2)' : 'rgba(155, 89, 182, 0.2)',
                        borderRadius: '12px',
                        padding: '12px',
                        filter: isCompleted ? 'none' : 'none'
                      }}>
                        {isCompleted ? '‚úÖ' : activeChallenge.icon}
                      </div>
                      <div>
                        <h3 style={{ color: COLORS.text, fontSize: '1.25rem', fontWeight: '600', margin: 0 }}>{activeChallenge.name}</h3>
                        <p style={{ color: COLORS.textMuted, fontSize: '0.9rem', margin: '4px 0 0 0' }}>{activeChallenge.description}</p>
                      </div>
                    </div>

                    {/* Progress bar */}
                    <div style={{ marginBottom: '12px' }}>
                      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '8px' }}>
                        <span style={{ color: COLORS.textMuted, fontSize: '0.85rem' }}>{current} / {activeChallenge.target}</span>
                        <span style={{ color: isCompleted ? '#27ae60' : '#9b59b6', fontSize: '0.85rem', fontWeight: '600' }}>{Math.round(progress * 100)}%</span>
                      </div>
                      <div style={{ background: 'rgba(255, 255, 255, 0.1)', borderRadius: '6px', height: '10px', overflow: 'hidden' }}>
                        <div style={{
                          background: isCompleted ? 'linear-gradient(90deg, #27ae60, #2ecc71)' : 'linear-gradient(90deg, #9b59b6, #8e44ad)',
                          height: '100%',
                          width: `${progress * 100}%`,
                          borderRadius: '6px',
                          transition: 'width 0.5s ease'
                        }} />
                      </div>
                    </div>

                    {/* Reward info */}
                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                      <span style={{ color: COLORS.textMuted, fontSize: '0.8rem' }}>Reward:</span>
                      <span style={{ color: '#f39c12', fontSize: '0.8rem', fontWeight: '600' }}>{activeChallenge.reward}</span>
                    </div>
                  </div>
                );
              })()}

              {/* Daily Challenges Section */}
              <div style={{
                background: COLORS.backgroundCard,
                borderRadius: '12px',
                padding: '24px',
                marginBottom: '32px',
                border: `1px solid ${COLORS.accent}30`
              }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '16px' }}>
                  <div>
                    <h2 style={{ color: COLORS.text, fontSize: '1.25rem', fontWeight: '600', margin: 0 }}>Daily Challenges</h2>
                    <p style={{ color: COLORS.textMuted, fontSize: '0.85rem', margin: '4px 0 0 0' }}>Complete challenges to earn rewards. Resets at midnight.</p>
                  </div>
                  <div style={{ background: `${COLORS.accent}20`, borderRadius: '8px', padding: '8px 12px', color: COLORS.accent, fontSize: '0.85rem', fontWeight: '600' }}>
                    {dailyChallengeData.completedChallenges.length} / {dailyChallengeData.challenges.length} Complete
                  </div>
                </div>
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))', gap: '12px' }}>
                  {dailyChallengeData.challenges.map(challenge => {
                    const isCompleted = dailyChallengeData.completedChallenges.includes(challenge.id);
                    const current = dailyChallengeData.stats[challenge.statKey] || 0;
                    const progress = Math.min(current / challenge.target, 1);
                    return (
                      <div key={challenge.id} style={{
                        background: isCompleted ? `${COLORS.success}15` : 'rgba(255, 255, 255, 0.03)',
                        borderRadius: '10px',
                        padding: '16px',
                        border: isCompleted ? `1px solid ${COLORS.success}40` : '1px solid rgba(255, 255, 255, 0.05)'
                      }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '12px', marginBottom: '12px' }}>
                          <div style={{ fontSize: '24px', background: isCompleted ? `${COLORS.success}20` : 'rgba(255, 255, 255, 0.05)', borderRadius: '8px', padding: '8px' }}>
                            {isCompleted ? '‚úÖ' : challenge.icon}
                          </div>
                          <div style={{ flex: 1 }}>
                            <div style={{ color: COLORS.text, fontSize: '0.95rem', fontWeight: '600' }}>{challenge.name}</div>
                            <div style={{ color: COLORS.textMuted, fontSize: '0.8rem' }}>{challenge.description}</div>
                          </div>
                          <span style={{ fontSize: '0.65rem', fontWeight: '600', textTransform: 'uppercase', color: DIFFICULTY_COLORS[challenge.difficulty], background: `${DIFFICULTY_COLORS[challenge.difficulty]}20`, padding: '4px 8px', borderRadius: '4px' }}>
                            {challenge.difficulty}
                          </span>
                        </div>
                        <div style={{ marginBottom: '8px' }}>
                          <div style={{ background: 'rgba(255, 255, 255, 0.1)', borderRadius: '4px', height: '6px', overflow: 'hidden' }}>
                            <div style={{ background: isCompleted ? COLORS.success : `linear-gradient(90deg, ${DIFFICULTY_COLORS[challenge.difficulty]}, ${DIFFICULTY_COLORS[challenge.difficulty]}aa)`, height: '100%', width: `${progress * 100}%`, borderRadius: '4px' }} />
                          </div>
                        </div>
                        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                          <span style={{ color: COLORS.textMuted, fontSize: '0.75rem' }}>{current} / {challenge.target}</span>
                          {isCompleted && <span style={{ color: COLORS.success, fontSize: '0.75rem', fontWeight: '600' }}>Complete!</span>}
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>

              {/* Almost There Section - Achievements at 70-95% (filtered by current tab) */}
              {(() => {
                const almostThereAchievements = ACHIEVEMENTS_DATA
                  .filter(a => a.mode === achievementTab)
                  .filter(achievement => {
                    if (unlockedAchievements.includes(achievement.id)) return false;
                    const progress = getAchievementProgress(achievement, achievementStats);
                    return progress && progress.progress >= 0.7 && progress.progress < 1;
                  });

                if (almostThereAchievements.length === 0) return null;

                return (
                  <div style={{ marginBottom: '32px' }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '16px' }}>
                      <span style={{ fontSize: '1.25rem' }}>üî•</span>
                      <h2 style={{ color: COLORS.accent, fontSize: '1.1rem', fontWeight: '600', margin: 0 }}>Almost There!</h2>
                    </div>
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '12px' }}>
                      {almostThereAchievements.map(achievement => {
                        const progressData = getAchievementProgress(achievement, achievementStats);
                        const remaining = progressData.target - progressData.current;
                        return (
                          <div key={`almost-${achievement.id}`} style={{
                            background: `linear-gradient(135deg, ${COLORS.backgroundCard}, ${COLORS.accent}10)`,
                            border: `1px solid ${COLORS.accent}40`,
                            borderRadius: '12px',
                            padding: '16px',
                            animation: 'almostTherePulse 2s ease-in-out infinite'
                          }}>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                              <div style={{ fontSize: '28px' }}>{achievement.icon}</div>
                              <div style={{ flex: 1 }}>
                                <div style={{ color: COLORS.text, fontSize: '0.95rem', fontWeight: '600', marginBottom: '4px' }}>
                                  {achievement.name}
                                </div>
                                <div style={{ color: COLORS.accent, fontSize: '0.8rem', fontWeight: '500' }}>
                                  {progressData.isThreshold
                                    ? `Need ${progressData.target}+ (Current best: ${progressData.current})`
                                    : `Only ${remaining} more to go!`}
                                </div>
                                {/* Mini progress bar */}
                                <div style={{
                                  background: 'rgba(255, 255, 255, 0.1)',
                                  borderRadius: '3px',
                                  height: '4px',
                                  marginTop: '8px',
                                  overflow: 'hidden'
                                }}>
                                  <div style={{
                                    background: `linear-gradient(90deg, ${COLORS.accent}, ${COLORS.accentLight})`,
                                    height: '100%',
                                    width: `${progressData.progress * 100}%`,
                                    borderRadius: '3px'
                                  }} />
                                </div>
                              </div>
                              <div style={{ color: COLORS.accent, fontSize: '1.1rem', fontWeight: '700' }}>
                                {Math.round(progressData.progress * 100)}%
                              </div>
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  </div>
                );
              })()}

              {/* Achievements Grid - Filtered by Tab */}
              <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '16px' }}>
                <span style={{ fontSize: '1.25rem' }}>{achievementTab === 'offline' ? 'üéÆ' : 'üåç'}</span>
                <h2 style={{ color: COLORS.text, fontSize: '1.1rem', fontWeight: '600', margin: 0 }}>
                  {achievementTab === 'offline' ? 'Offline Achievements' : 'Online Achievements'}
                </h2>
              </div>
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))', gap: '16px' }}>
                {ACHIEVEMENTS_DATA.filter(a => a.mode === achievementTab).map(achievement => {
                  const isUnlocked = unlockedAchievements.includes(achievement.id);
                  const progressData = !isUnlocked ? getAchievementProgress(achievement, achievementStats) : null;
                  const rarityStyle = getRarityCardStyle(achievement.rarity, isUnlocked);
                  return (
                    <div key={achievement.id} style={{
                      background: COLORS.backgroundCard,
                      border: '1px solid rgba(255, 255, 255, 0.05)',
                      borderRadius: '12px',
                      padding: '20px',
                      opacity: isUnlocked ? 1 : (progressData && progressData.progress > 0 ? 0.8 : 0.6),
                      transition: 'all 0.3s ease',
                      position: 'relative',
                      overflow: 'hidden',
                      ...rarityStyle
                    }}>
                      <div style={{ display: 'flex', alignItems: 'flex-start', gap: '16px' }}>
                        <div style={{
                          fontSize: '32px',
                          filter: isUnlocked ? 'none' : 'grayscale(100%)',
                          background: isUnlocked ? `${getRarityColor(achievement.rarity)}20` : 'rgba(255, 255, 255, 0.05)',
                          borderRadius: '10px',
                          padding: '10px',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center'
                        }}>
                          {achievement.icon}
                        </div>
                        <div style={{ flex: 1 }}>
                          <div style={{ color: isUnlocked ? COLORS.text : COLORS.textMuted, fontSize: '1rem', fontWeight: '600', marginBottom: '4px' }}>
                            {achievement.name}
                          </div>
                          <div style={{ color: isUnlocked ? COLORS.textMuted : 'rgba(139, 148, 158, 0.6)', fontSize: '0.85rem', marginBottom: '12px', lineHeight: '1.4' }}>
                            {achievement.description}
                          </div>

                          {/* Progress Bar for locked trackable achievements */}
                          {!isUnlocked && progressData && (
                            <div style={{ marginBottom: '12px' }}>
                              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '6px' }}>
                                <span style={{ color: progressData.progress >= 0.7 ? COLORS.accent : COLORS.textMuted, fontSize: '0.75rem', fontWeight: '600' }}>
                                  {progressData.isThreshold
                                    ? `Best: ${progressData.current}`
                                    : `${progressData.current} / ${progressData.target}`}
                                </span>
                                <span style={{ color: progressData.progress >= 0.7 ? COLORS.accent : COLORS.textMuted, fontSize: '0.75rem' }}>
                                  {Math.round(progressData.progress * 100)}%
                                </span>
                              </div>
                              <div style={{
                                background: 'rgba(255, 255, 255, 0.1)',
                                borderRadius: '4px',
                                height: '6px',
                                overflow: 'hidden'
                              }}>
                                <div style={{
                                  background: progressData.progress >= 0.7
                                    ? `linear-gradient(90deg, ${COLORS.accent}, ${COLORS.accentLight})`
                                    : 'linear-gradient(90deg, #4a5568, #718096)',
                                  height: '100%',
                                  width: `${progressData.progress * 100}%`,
                                  borderRadius: '4px',
                                  transition: 'width 0.5s ease'
                                }} />
                              </div>
                            </div>
                          )}

                          <div style={{ display: 'flex', gap: '8px', alignItems: 'center', flexWrap: 'wrap' }}>
                            <span style={{
                              color: isUnlocked ? getRarityColor(achievement.rarity) : COLORS.textMuted,
                              fontSize: '0.7rem',
                              fontWeight: '600',
                              textTransform: 'uppercase',
                              letterSpacing: '0.5px',
                              background: isUnlocked ? `${getRarityColor(achievement.rarity)}20` : 'rgba(255, 255, 255, 0.05)',
                              borderRadius: '4px',
                              padding: '4px 8px'
                            }}>
                              {achievement.rarity}
                            </span>
                            <span style={{
                              color: achievement.mode === 'online' ? '#60a5fa' : COLORS.accent,
                              fontSize: '0.7rem',
                              fontWeight: '600',
                              textTransform: 'uppercase',
                              letterSpacing: '0.5px',
                              background: achievement.mode === 'online' ? 'rgba(96, 165, 250, 0.15)' : `${COLORS.accent}20`,
                              borderRadius: '4px',
                              padding: '4px 8px'
                            }}>
                              {achievement.mode === 'online' ? 'Online' : 'Offline'}
                            </span>
                            {isUnlocked ? (
                              <span style={{
                                color: COLORS.success,
                                fontSize: '0.7rem',
                                fontWeight: '600',
                                background: 'rgba(45, 138, 45, 0.15)',
                                borderRadius: '4px',
                                padding: '4px 8px',
                                marginLeft: 'auto'
                              }}>
                                Unlocked
                              </span>
                            ) : (
                              <span style={{
                                color: COLORS.textMuted,
                                fontSize: '0.7rem',
                                fontWeight: '600',
                                background: 'rgba(255, 255, 255, 0.05)',
                                borderRadius: '4px',
                                padding: '4px 8px',
                                marginLeft: 'auto'
                              }}>
                                Locked
                              </span>
                            )}
                          </div>
                        </div>
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          </div>
        );
      }

      // ============================================
      // NAVIGATION COMPONENT
      // ============================================
      const Navigation = ({ onNavigate, currentPage }) => (
        <nav className="nav" role="navigation" aria-label="Main navigation">
          <div className="nav-container">
            <a href="#" className="nav-logo" onClick={(e) => { e.preventDefault(); onNavigate('landing'); }}>
              QUIK DARTS
            </a>
            <ul className="nav-links">
              <li><a href="#" className="nav-link" onClick={(e) => { e.preventDefault(); onNavigate('landing'); }}>Home</a></li>
              <li><a href="#" className="nav-link" onClick={(e) => { e.preventDefault(); onNavigate('menu'); }}>Play</a></li>
              <li><a href="#" className="nav-link" onClick={(e) => { e.preventDefault(); enterPracticeMode(); }}>Practice</a></li>
              <li><a href="#" className="nav-link" onClick={(e) => { e.preventDefault(); setShowAchievements(true); }}>Achievements</a></li>
              <li><a href="#" className="nav-link" onClick={(e) => { e.preventDefault(); onNavigate('howToPlay'); }}>How to Play</a></li>
              <li><button className="nav-cta" onClick={() => onNavigate('menu')}>Play Now</button></li>
              {/* Coin balance display for signed-in users */}
              {currentUser && !currentUser.isAnonymous && (
                <li style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                  <div style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: '6px',
                    background: 'rgba(212, 160, 58, 0.15)',
                    padding: '6px 12px',
                    borderRadius: '20px',
                    border: '1px solid rgba(212, 160, 58, 0.3)'
                  }}>
                    <CoinIcon size={16} />
                    <span style={{ color: '#D4A03A', fontWeight: '600', fontSize: '14px' }}>
                      {formatCoins(coinBalance)}
                    </span>
                  </div>
                  {dailyBonusAvailable && (
                    <button
                      onClick={claimDailyBonus}
                      disabled={isClaimingBonus}
                      style={{
                        background: 'linear-gradient(135deg, #2D8A2D, #1B6B1B)',
                        border: 'none',
                        color: 'white',
                        padding: '6px 12px',
                        borderRadius: '20px',
                        cursor: isClaimingBonus ? 'wait' : 'pointer',
                        fontSize: '12px',
                        fontWeight: '600',
                        opacity: isClaimingBonus ? 0.7 : 1,
                        transition: 'all 0.2s ease'
                      }}
                    >
                      {isClaimingBonus ? '...' : '+50 Free!'}
                    </button>
                  )}
                  {adsRemainingToday > 0 && (
                    <button
                      onClick={watchAdForCoins}
                      disabled={isWatchingAd}
                      title={`Watch ad for +25 coins (${adsRemainingToday}/5 remaining)`}
                      style={{
                        background: 'linear-gradient(135deg, #D4A03A, #B8862E)',
                        border: 'none',
                        color: '#0D1117',
                        padding: '6px 10px',
                        borderRadius: '20px',
                        cursor: isWatchingAd ? 'wait' : 'pointer',
                        fontSize: '12px',
                        fontWeight: '600',
                        opacity: isWatchingAd ? 0.7 : 1,
                        transition: 'all 0.2s ease',
                        display: 'flex',
                        alignItems: 'center',
                        gap: '4px'
                      }}
                    >
                      <span style={{ fontSize: '14px' }}>‚ñ∂</span>
                      {isWatchingAd ? '...' : '+25'}
                    </button>
                  )}
                  <button
                    onClick={() => setShowCoinShop(true)}
                    title="Buy coins"
                    style={{
                      background: 'linear-gradient(135deg, #D4A03A, #B8862E)',
                      border: 'none',
                      color: '#0D1117',
                      width: '28px',
                      height: '28px',
                      borderRadius: '50%',
                      cursor: 'pointer',
                      fontSize: '16px',
                      fontWeight: '700',
                      display: 'flex',
                      alignItems: 'center',
                      justifyContent: 'center',
                      transition: 'all 0.2s ease'
                    }}
                  >
                    +
                  </button>
                </li>
              )}
              <li>
                {currentUser && !currentUser.isAnonymous ? (
                  <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                    <button
                      onClick={() => setShowProfileScreen(true)}
                      style={{ background: 'none', border: 'none', padding: 0, cursor: 'pointer' }}
                      title="View Profile"
                    >
                      {currentUser.photoURL ? (
                        <img
                          src={currentUser.photoURL}
                          alt={currentUser.displayName || 'Profile'}
                          style={{ width: '36px', height: '36px', borderRadius: '50%', border: `2px solid ${COLORS.accent}` }}
                          referrerPolicy="no-referrer"
                          onError={(e) => { e.target.style.display = 'none'; e.target.nextSibling.style.display = 'flex'; }}
                        />
                      ) : null}
                      <div style={{
                        width: '36px',
                        height: '36px',
                        borderRadius: '50%',
                        background: `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})`,
                        display: currentUser.photoURL ? 'none' : 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        color: COLORS.textDark,
                        fontWeight: '700',
                        fontSize: '16px',
                        border: `2px solid ${COLORS.accentLight}`
                      }}>
                        {(currentUser.displayName || currentUser.email || 'U')[0].toUpperCase()}
                      </div>
                    </button>
                    <button onClick={handleSignOut} style={{
                      background: 'none',
                      border: '1px solid rgba(255,255,255,0.2)',
                      color: COLORS.textMuted,
                      padding: '6px 12px',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      fontSize: '0.8rem',
                      fontFamily: 'var(--font-primary)'
                    }}>Sign Out</button>
                  </div>
                ) : (
                  <button onClick={() => setShowLoginModal(true)} style={{
                    background: 'none',
                    border: '1px solid rgba(255,255,255,0.3)',
                    color: COLORS.text,
                    padding: '8px 16px',
                    borderRadius: '6px',
                    cursor: 'pointer',
                    fontSize: '0.9rem',
                    fontWeight: '500',
                    fontFamily: 'var(--font-primary)'
                  }}>Login</button>
                )}
              </li>
            </ul>
            <button className="nav-hamburger" onClick={() => setMobileMenuOpen(!mobileMenuOpen)} aria-label="Toggle menu" aria-expanded={mobileMenuOpen}>
              {mobileMenuOpen ? <CloseIcon /> : <MenuIcon />}
            </button>
          </div>
          <div className={`nav-mobile ${mobileMenuOpen ? 'open' : ''}`}>
            <ul className="nav-mobile-links">
              <li><a href="#" className="nav-link" onClick={(e) => { e.preventDefault(); onNavigate('landing'); setMobileMenuOpen(false); }}>Home</a></li>
              <li><a href="#" className="nav-link" onClick={(e) => { e.preventDefault(); onNavigate('menu'); setMobileMenuOpen(false); }}>Play</a></li>
              <li><a href="#" className="nav-link" onClick={(e) => { e.preventDefault(); onNavigate('howToPlay'); setMobileMenuOpen(false); }}>How to Play</a></li>
              <li><a href="#" className="nav-link" onClick={(e) => { e.preventDefault(); setShowAchievements(true); setMobileMenuOpen(false); }}>Achievements</a></li>
              <li><button className="btn btn-primary" style={{ width: '100%', marginTop: '8px' }} onClick={() => { onNavigate('menu'); setMobileMenuOpen(false); }}>Play Now</button></li>
              <li>
                {currentUser && !currentUser.isAnonymous ? (
                  <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginTop: '12px', padding: '12px', background: 'rgba(255,255,255,0.05)', borderRadius: '8px' }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                      {currentUser.photoURL ? (
                        <img src={currentUser.photoURL} alt="" style={{ width: '36px', height: '36px', borderRadius: '50%' }} />
                      ) : (
                        <div style={{ width: '36px', height: '36px', borderRadius: '50%', background: COLORS.accent, display: 'flex', alignItems: 'center', justifyContent: 'center', color: COLORS.textDark, fontWeight: '600' }}>
                          {(currentUser.displayName || currentUser.email || 'U')[0].toUpperCase()}
                        </div>
                      )}
                      <span style={{ color: COLORS.text, fontSize: '0.9rem' }}>{currentUser.displayName || currentUser.email || 'User'}</span>
                    </div>
                    <button onClick={() => { handleSignOut(); setMobileMenuOpen(false); }} style={{
                      background: 'none',
                      border: '1px solid rgba(255,255,255,0.2)',
                      color: COLORS.textMuted,
                      padding: '6px 12px',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      fontSize: '0.8rem',
                      fontFamily: 'var(--font-primary)'
                    }}>Sign Out</button>
                  </div>
                ) : (
                  <button onClick={() => { setShowLoginModal(true); setMobileMenuOpen(false); }} className="btn btn-secondary" style={{ width: '100%', marginTop: '8px' }}>Login</button>
                )}
              </li>
            </ul>
          </div>
        </nav>
      );

      // ============================================
      // WAGERED MATCH HEADER COMPONENT
      // ============================================
      const WageredMatchHeader = ({ pot, player1, player2, phase, winnerUid, isWagered, currentUserId }) => {
        if (!isWagered) return null;

        const [showWinAnimation, setShowWinAnimation] = useState(false);
        const [animationDirection, setAnimationDirection] = useState(0);
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

        // Determine if current user won
        const userWon = winnerUid && winnerUid === currentUserId;

        useEffect(() => {
          if (phase === 'end' && winnerUid) {
            const winnerIsPlayer1 = winnerUid === player1?.uid;
            setAnimationDirection(winnerIsPlayer1 ? -150 : 150);
            setShowWinAnimation(true);
          }
        }, [phase, winnerUid, player1]);

        // Get initials for avatar fallback
        const getInitials = (name) => {
          if (!name) return '?';
          return name.slice(0, 2).toUpperCase();
        };

        // Truncate name to 14 chars
        const truncateName = (name) => {
          if (!name) return 'Player';
          return name.length > 14 ? name.slice(0, 14) + '‚Ä¶' : name;
        };

        const PlayerCard = ({ player, isLeft }) => {
          const isLoading = !player?.name;
          const isMobile = window.innerWidth < 768;

          if (isLoading) {
            // Skeleton placeholder
            return (
              <div style={{
                display: 'flex',
                alignItems: 'center',
                gap: isMobile ? '8px' : '12px',
                flexDirection: isLeft ? 'row' : 'row-reverse',
                maxWidth: isMobile ? '140px' : '200px'
              }}>
                <div style={{
                  width: isMobile ? '36px' : '44px',
                  height: isMobile ? '36px' : '44px',
                  borderRadius: '50%',
                  background: 'rgba(255,255,255,0.1)',
                  animation: 'skeletonPulse 1.5s ease-in-out infinite',
                  flexShrink: 0
                }} />
                <div style={{ overflow: 'hidden' }}>
                  <div style={{ width: '70px', height: '14px', background: 'rgba(255,255,255,0.1)', borderRadius: '4px', marginBottom: '4px' }} />
                  <div style={{ width: '50px', height: '10px', background: 'rgba(255,255,255,0.05)', borderRadius: '4px' }} />
                </div>
              </div>
            );
          }

          return (
            <div style={{
              display: 'flex',
              alignItems: 'center',
              gap: isMobile ? '8px' : '12px',
              flexDirection: isLeft ? 'row' : 'row-reverse',
              maxWidth: isMobile ? '140px' : '200px'
            }}>
              {/* Avatar */}
              <div style={{
                width: isMobile ? '36px' : '44px',
                height: isMobile ? '36px' : '44px',
                borderRadius: '50%',
                background: player.avatarUrl ? `url(${player.avatarUrl}) center/cover` : `linear-gradient(135deg, ${COLORS.primary}, ${COLORS.primaryLight})`,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                color: COLORS.text,
                fontWeight: '700',
                fontSize: isMobile ? '12px' : '14px',
                border: `2px solid ${COLORS.accent}40`,
                flexShrink: 0
              }}>
                {!player.avatarUrl && getInitials(player.name)}
              </div>

              {/* Name & Level */}
              <div style={{ textAlign: isLeft ? 'left' : 'right', overflow: 'hidden', minWidth: 0 }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: '6px', flexDirection: isLeft ? 'row' : 'row-reverse' }}>
                  <span style={{
                    color: COLORS.text,
                    fontSize: isMobile ? '13px' : '15px',
                    fontWeight: '600',
                    whiteSpace: 'nowrap',
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                    maxWidth: isMobile ? '80px' : '100px'
                  }}>
                    {truncateName(player.name)}
                  </span>
                  <span style={{
                    background: 'linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 180, 0, 0.15))',
                    color: '#FFD700',
                    fontSize: isMobile ? '9px' : '10px',
                    fontWeight: '700',
                    padding: '2px 6px',
                    borderRadius: '8px',
                    border: '1px solid rgba(255, 215, 0, 0.2)',
                    flexShrink: 0
                  }}>
                    Lv.{player.level || '?'}
                  </span>
                </div>
                <div style={{
                  color: COLORS.textMuted,
                  fontSize: isMobile ? '10px' : '11px',
                  marginTop: '3px',
                  display: 'flex',
                  alignItems: 'center',
                  gap: '4px',
                  justifyContent: isLeft ? 'flex-start' : 'flex-end'
                }}>
                  <CoinIcon size={isMobile ? 10 : 11} />
                  <span style={{ fontWeight: '600' }}>{formatCompactNumber(player.stake || 0)}</span>
                </div>
              </div>
            </div>
          );
        };

        return (
          <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            height: window.innerWidth < 768 ? '70px' : '76px',
            background: `linear-gradient(180deg, ${COLORS.background} 0%, ${COLORS.backgroundLight} 100%)`,
            borderBottom: `1px solid ${COLORS.accent}30`,
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            padding: '0 24px',
            paddingTop: 'env(safe-area-inset-top)',
            zIndex: 1000,
            boxSizing: 'border-box'
          }}>
            {/* Player 1 (Left) */}
            <PlayerCard player={player1} isLeft={true} />

            {/* Pot (Center) - Hero Element */}
            <div style={{
              position: 'absolute',
              left: '50%',
              top: '50%',
              transform: `translate(-50%, -50%) ${showWinAnimation && !prefersReducedMotion ? `translateX(${animationDirection}px)` : ''}`,
              transition: showWinAnimation ? 'transform 900ms cubic-bezier(0.4, 0, 0.2, 1)' : 'none',
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
              animation: phase === 'prematch' ? 'potPulse 650ms cubic-bezier(0.34, 1.56, 0.64, 1), potGlow 650ms ease-out' : 'none',
              zIndex: 10
            }}>
              <div style={{
                display: 'flex',
                alignItems: 'center',
                gap: '10px',
                background: 'linear-gradient(135deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 180, 0, 0.15) 100%)',
                padding: '10px 20px',
                borderRadius: '24px',
                border: '1px solid rgba(255, 215, 0, 0.3)',
                boxShadow: phase === 'inmatch'
                  ? '0 0 20px rgba(255, 215, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.1)'
                  : '0 0 30px rgba(255, 215, 0, 0.6), 0 4px 20px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1)'
              }}>
                <CoinIcon size={28} />
                <span style={{
                  color: '#FFD700',
                  fontSize: '24px',
                  fontWeight: '700',
                  fontFamily: "'Roboto Mono', monospace",
                  textShadow: '0 0 15px rgba(255, 215, 0, 0.6), 0 2px 4px rgba(0, 0, 0, 0.3)'
                }}>
                  {formatCompactNumber(pot || 0)}
                </span>
              </div>
              <span style={{
                color: '#FFD700',
                fontSize: '9px',
                fontWeight: '700',
                letterSpacing: '2px',
                marginTop: '4px',
                textShadow: '0 0 8px rgba(255, 215, 0, 0.4)'
              }}>
                PRIZE POT
              </span>

              {/* Win amount overlay */}
              {showWinAnimation && userWon && (
                <div style={{
                  position: 'absolute',
                  top: '100%',
                  marginTop: '8px',
                  color: COLORS.success,
                  fontSize: '16px',
                  fontWeight: '700',
                  animation: prefersReducedMotion ? 'none' : 'wagerFadeInUp 400ms ease-out',
                  opacity: 1
                }}>
                  +{formatCompactNumber(pot)}
                </div>
              )}
            </div>

            {/* Player 2 (Right) */}
            <PlayerCard player={player2} isLeft={false} />
          </div>
        );
      };

      // ============================================
      // FOOTER COMPONENT
      // ============================================
      const Footer = ({ onNavigate }) => (
        <footer className="footer" role="contentinfo">
          <div className="footer-container">
            <div className="footer-content">
              <div className="footer-brand">
                <h3>Quik Darts</h3>
                <p>Championship-style online darts.<br />Play anywhere, anytime.</p>
              </div>
              <div className="footer-links">
                <div className="footer-links-group">
                  <h4>Play</h4>
                  <ul>
                    <li><a href="#" onClick={(e) => { e.preventDefault(); onNavigate('menu'); }}>Start Game</a></li>
                    <li><a href="#" onClick={(e) => { e.preventDefault(); onNavigate('menu'); }}>Practice Mode</a></li>
                    <li><a href="#" onClick={(e) => { e.preventDefault(); onNavigate('menu'); }}>Online Match</a></li>
                  </ul>
                </div>
                <div className="footer-links-group">
                  <h4>Learn</h4>
                  <ul>
                    <li><a href="#" onClick={(e) => { e.preventDefault(); onNavigate('howToPlay'); }}>How to Play</a></li>
                    <li><a href="#" onClick={(e) => { e.preventDefault(); onNavigate('howToPlay'); }}>Scoring Rules</a></li>
                    <li><a href="#" onClick={(e) => { e.preventDefault(); onNavigate('howToPlay'); }}>Tips & Strategy</a></li>
                  </ul>
                </div>
              </div>
            </div>
            <div className="footer-bottom">
              <p>Made with <span role="img" aria-label="dart">üéØ</span> | v1.0 Championship Edition</p>
            </div>
          </div>
        </footer>
      );

      // ============================================
      // LANDING PAGE
      // ============================================
      if (gameState === 'landing') {
        return (
          <div style={{ minHeight: '100vh', background: COLORS.background }}>
            <Navigation onNavigate={setGameState} currentPage="landing" />

            {/* Hero Section */}
            <section style={{
              minHeight: '100vh',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              padding: '100px 24px 60px',
              position: 'relative',
              overflow: 'hidden'
            }}>
              {/* Background gradient */}
              <div style={{
                position: 'absolute',
                inset: 0,
                background: `radial-gradient(ellipse at 30% 20%, ${COLORS.primary}40 0%, transparent 50%), radial-gradient(ellipse at 70% 80%, ${COLORS.accent}20 0%, transparent 40%), linear-gradient(180deg, ${COLORS.background} 0%, ${COLORS.backgroundLight} 100%)`,
                zIndex: 0
              }} />


              <div style={{ maxWidth: '1200px', width: '100%', display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', gap: '60px', alignItems: 'center', zIndex: 2, position: 'relative' }}>
                {/* Text Content */}
                <div className="animate-fade-in">
                  <div style={{ display: 'inline-block', background: `${COLORS.accent}20`, color: COLORS.accent, padding: '8px 16px', borderRadius: '20px', fontSize: '0.85rem', fontWeight: '600', marginBottom: '24px' }}>
                    No Download Required
                  </div>
                  <h1 style={{ color: COLORS.text, marginBottom: '16px', fontWeight: '800' }}>
                    Quik Darts
                    <span style={{ display: 'block', color: COLORS.accent, fontSize: '0.5em', fontWeight: '600', letterSpacing: '3px', marginTop: '8px' }}>CHAMPIONSHIP EDITION</span>
                  </h1>
                  <p style={{ color: COLORS.textMuted, fontSize: '1.25rem', marginBottom: '32px', maxWidth: '500px', lineHeight: '1.7' }}>
                    Championship-style online darts. Play solo, challenge friends, or compete online. Experience realistic 501 gameplay right in your browser.
                  </p>
                </div>

                {/* Game Setup Card */}
                <div className="animate-fade-in animate-delay-2" style={{
                  background: COLORS.backgroundCard,
                  borderRadius: '16px',
                  padding: '32px',
                  border: '1px solid rgba(255, 255, 255, 0.05)',
                  boxShadow: '0 25px 60px rgba(0, 0, 0, 0.5)',
                  width: '100%',
                  maxWidth: '420px'
                }}>
                  {/* Main action buttons - 2x2 Grid */}
                  <div style={{
                    display: 'grid',
                    gridTemplateColumns: 'repeat(2, 1fr)',
                    gap: '12px',
                    marginBottom: '24px'
                  }}>
                    <button className="btn btn-primary" onClick={startGame} style={{
                      padding: '20px 16px',
                      fontSize: '0.95rem',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      justifyContent: 'center',
                      gap: '8px',
                      borderRadius: '12px',
                      minHeight: '90px'
                    }}><DartIcon size={24} color={COLORS.textDark} />Start Game</button>

                    <button className="btn btn-secondary" onClick={handlePlayOnlineClick} style={{
                      padding: '20px 16px',
                      fontSize: '0.95rem',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      justifyContent: 'center',
                      gap: '8px',
                      borderRadius: '12px',
                      minHeight: '90px'
                    }}><GlobeIcon size={24} color={COLORS.text} />Play Online</button>

                    <button className="btn btn-ghost" onClick={enterPracticeMode} style={{
                      padding: '20px 16px',
                      fontSize: '0.95rem',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      justifyContent: 'center',
                      gap: '8px',
                      borderRadius: '12px',
                      minHeight: '90px'
                    }}><TargetIcon size={24} color={COLORS.text} />Practice Mode</button>

                    <button className="btn btn-ghost" onClick={() => setShowAchievements(true)} style={{
                      padding: '20px 16px',
                      fontSize: '0.95rem',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center',
                      justifyContent: 'center',
                      gap: '8px',
                      borderRadius: '12px',
                      minHeight: '90px',
                      color: COLORS.accent,
                      borderColor: `${COLORS.accent}40`
                    }}><TrophyIcon size={24} color={COLORS.accent} />Achievements</button>
                  </div>

                  {/* Divider */}
                  <div style={{ height: '1px', background: `linear-gradient(90deg, transparent, ${COLORS.accent}30, transparent)`, marginBottom: '24px' }} />

                  {/* Game Mode */}
                  <div style={{ marginBottom: '20px' }}>
                    <label style={{ color: COLORS.textMuted, fontSize: '0.75rem', letterSpacing: '2px', display: 'block', marginBottom: '10px', fontWeight: '600', textTransform: 'uppercase' }}>Game Mode</label>
                    <div style={{ display: 'flex', gap: '8px' }}>
                      {[301, 501].map(mode => (
                        <button key={mode} onClick={() => setPlayerSetup(prev => ({ ...prev, gameMode: mode }))} style={{ flex: 1, padding: '12px', fontSize: '1rem', fontWeight: '600', background: playerSetup.gameMode === mode ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})` : 'rgba(255, 255, 255, 0.03)', color: playerSetup.gameMode === mode ? COLORS.textDark : COLORS.textMuted, border: playerSetup.gameMode === mode ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '6px', cursor: 'pointer' }}>{mode}</button>
                      ))}
                    </div>
                  </div>

                  {/* Legs Per Set */}
                  <div style={{ marginBottom: '20px' }}>
                    <label style={{ color: COLORS.textMuted, fontSize: '0.75rem', letterSpacing: '2px', display: 'block', marginBottom: '10px', fontWeight: '600', textTransform: 'uppercase' }}>Legs Per Set</label>
                    <div style={{ display: 'flex', gap: '8px' }}>
                      {[1, 3, 5, 7].map(legs => (
                        <button key={legs} onClick={() => setPlayerSetup(prev => ({ ...prev, legsPerSet: legs }))} style={{ flex: 1, padding: '12px', fontSize: '1rem', fontWeight: '600', background: playerSetup.legsPerSet === legs ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})` : 'rgba(255, 255, 255, 0.03)', color: playerSetup.legsPerSet === legs ? COLORS.textDark : COLORS.textMuted, border: playerSetup.legsPerSet === legs ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '6px', cursor: 'pointer' }}>{legs}</button>
                      ))}
                    </div>
                  </div>

                  {/* Sets To Win */}
                  <div style={{ marginBottom: '20px' }}>
                    <label style={{ color: COLORS.textMuted, fontSize: '0.75rem', letterSpacing: '2px', display: 'block', marginBottom: '10px', fontWeight: '600', textTransform: 'uppercase' }}>Sets To Win</label>
                    <div style={{ display: 'flex', gap: '8px' }}>
                      {[1, 3, 5, 7].map(sets => (
                        <button key={sets} onClick={() => setPlayerSetup(prev => ({ ...prev, setsToWin: sets }))} style={{ flex: 1, padding: '12px', fontSize: '1rem', fontWeight: '600', background: playerSetup.setsToWin === sets ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})` : 'rgba(255, 255, 255, 0.03)', color: playerSetup.setsToWin === sets ? COLORS.textDark : COLORS.textMuted, border: playerSetup.setsToWin === sets ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '6px', cursor: 'pointer' }}>{sets}</button>
                      ))}
                    </div>
                  </div>

                  {/* Players */}
                  <div style={{ marginBottom: '20px' }}>
                    <label style={{ color: COLORS.textMuted, fontSize: '0.75rem', letterSpacing: '2px', display: 'block', marginBottom: '10px', fontWeight: '600', textTransform: 'uppercase' }}>Players</label>
                    <div style={{ display: 'flex', gap: '8px' }}>
                      {[1, 2, 3, 4].map(num => (
                        <button key={num} onClick={() => setPlayerSetup(prev => ({ ...prev, count: num }))} style={{ flex: 1, padding: '12px', fontSize: '1rem', fontWeight: '600', background: playerSetup.count === num ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})` : 'rgba(255, 255, 255, 0.03)', color: playerSetup.count === num ? COLORS.textDark : COLORS.textMuted, border: playerSetup.count === num ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '6px', cursor: 'pointer' }}>{num}</button>
                      ))}
                    </div>
                  </div>

                  {/* Player Setup */}
                  {Array.from({ length: playerSetup.count }).map((_, i) => (
                    <div key={i} style={{ marginBottom: '12px', background: 'rgba(0, 0, 0, 0.3)', padding: '14px', borderRadius: '8px', border: '1px solid rgba(255, 255, 255, 0.05)' }}>
                      <input
                        type="text"
                        id={`local-player-name-${i}`}
                        name={`local-player-name-${i}`}
                        aria-label={`Player ${i + 1} name`}
                        value={playerSetup.names[i]}
                        onChange={(e) => {
                          const newNames = [...playerSetup.names];
                          newNames[i] = sanitizeName(e.target.value);
                          setPlayerSetup(prev => ({ ...prev, names: newNames }));
                        }}
                        placeholder={`Player ${i + 1}`}
                        maxLength={20}
                        style={{ width: '100%', padding: '11px 14px', fontSize: '14px', background: 'rgba(255, 255, 255, 0.05)', border: '1px solid rgba(255, 255, 255, 0.1)', borderRadius: '6px', color: 'rgba(255, 255, 255, 0.9)', outline: 'none', boxSizing: 'border-box', marginBottom: '10px' }}
                      />
                      <div>
                        <label htmlFor={`local-player-flag-${i}`} style={{ color: 'rgba(255, 255, 255, 0.4)', fontSize: '10px', letterSpacing: '2px', display: 'block', marginBottom: '6px' }}>NATIONALITY</label>
                        <select id={`local-player-flag-${i}`} name={`local-player-flag-${i}`} value={playerSetup.flags[i]} onChange={(e) => { const newFlags = [...playerSetup.flags]; newFlags[i] = e.target.value; setPlayerSetup(prev => ({ ...prev, flags: newFlags })); }} style={{ width: '100%', padding: '10px 12px', fontSize: '14px', background: 'rgba(255, 255, 255, 0.05)', border: '1px solid rgba(255, 255, 255, 0.1)', borderRadius: '6px', color: 'rgba(255, 255, 255, 0.9)', outline: 'none', cursor: 'pointer', boxSizing: 'border-box' }}>
                          {COUNTRIES.map(country => (
                            <option key={country.name} value={country.flag} style={{ background: '#1a1a1a', color: '#fff' }}>
                              {country.flag} {country.name}
                            </option>
                          ))}
                        </select>
                      </div>

                      {i > 0 && playerSetup.count > 1 && (
                        <>
                          <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginTop: '10px', marginBottom: playerSetup.aiPlayers[i] ? '10px' : '0' }}>
                            <span style={{ color: 'rgba(255, 255, 255, 0.4)', fontSize: '10px', letterSpacing: '2px' }}>AI OPPONENT</span>
                            <button onClick={() => {
                              const newAiPlayers = [...playerSetup.aiPlayers];
                              newAiPlayers[i] = !newAiPlayers[i];
                              const newAiDifficulty = [...playerSetup.aiDifficulty];
                              if (newAiPlayers[i] && !newAiDifficulty[i]) newAiDifficulty[i] = AI_DIFFICULTIES.INTERMEDIATE.key;
                              setPlayerSetup(prev => ({ ...prev, aiPlayers: newAiPlayers, aiDifficulty: newAiDifficulty }));
                            }} style={{ padding: '5px 14px', background: playerSetup.aiPlayers[i] ? 'linear-gradient(180deg, #2d8a2d, #1f6b1f)' : 'rgba(255, 255, 255, 0.05)', color: playerSetup.aiPlayers[i] ? '#fff' : 'rgba(255, 255, 255, 0.4)', border: playerSetup.aiPlayers[i] ? 'none' : '1px solid rgba(255, 255, 255, 0.1)', borderRadius: '4px', cursor: 'pointer', fontSize: '11px', fontWeight: '600', letterSpacing: '1px' }}>
                              {playerSetup.aiPlayers[i] ? 'ON' : 'OFF'}
                            </button>
                          </div>

                          {playerSetup.aiPlayers[i] && (
                            <div>
                              <label style={{ color: 'rgba(255, 255, 255, 0.4)', fontSize: '10px', letterSpacing: '2px', display: 'block', marginBottom: '6px' }}>DIFFICULTY</label>
                              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '5px' }}>
                                {Object.values(AI_DIFFICULTIES).map(d => (
                                  <button key={d.key} onClick={() => {
                                    const newAiDifficulty = [...playerSetup.aiDifficulty];
                                    newAiDifficulty[i] = d.key;
                                    setPlayerSetup(prev => ({ ...prev, aiDifficulty: newAiDifficulty }));
                                  }} style={{ padding: '7px 4px', fontSize: '10px', fontWeight: '600', background: playerSetup.aiDifficulty[i] === d.key ? 'linear-gradient(180deg, #c9a227 0%, #a68b1f 100%)' : 'rgba(255, 255, 255, 0.03)', color: playerSetup.aiDifficulty[i] === d.key ? '#0a0a0f' : 'rgba(255, 255, 255, 0.4)', border: playerSetup.aiDifficulty[i] === d.key ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '4px', cursor: 'pointer', textTransform: 'uppercase', letterSpacing: '0.5px' }}>
                                    {d.label.slice(0, 3).toUpperCase()}
                                  </button>
                                ))}
                              </div>
                            </div>
                          )}
                        </>
                      )}
                    </div>
                  ))}

                  {/* Divider */}
                  <div style={{ height: '1px', background: `linear-gradient(90deg, transparent, ${COLORS.accent}30, transparent)`, margin: '20px 0' }} />

                  {/* Skill Level */}
                  <div style={{ marginBottom: '20px' }}>
                    <label style={{ color: COLORS.textMuted, fontSize: '0.75rem', letterSpacing: '2px', display: 'block', marginBottom: '10px', fontWeight: '600', textTransform: 'uppercase' }}>Skill Level</label>
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '8px' }}>
                      <button onClick={() => setSkillLevel(30)} style={{ padding: '12px 8px', background: skillLevel <= 40 ? 'linear-gradient(135deg, #2d8a2d, #1f6b1f)' : 'rgba(255, 255, 255, 0.03)', color: skillLevel <= 40 ? '#fff' : COLORS.textMuted, border: skillLevel <= 40 ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '6px', cursor: 'pointer', fontSize: '0.75rem', fontWeight: '600' }}>
                        <div style={{ width: '8px', height: '8px', borderRadius: '50%', background: skillLevel <= 40 ? '#90EE90' : 'rgba(144, 238, 144, 0.4)', margin: '0 auto 6px' }} />
                        BEGINNER
                      </button>
                      <button onClick={() => setSkillLevel(60)} style={{ padding: '12px 8px', background: skillLevel >= 41 && skillLevel <= 80 ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})` : 'rgba(255, 255, 255, 0.03)', color: skillLevel >= 41 && skillLevel <= 80 ? COLORS.textDark : COLORS.textMuted, border: skillLevel >= 41 && skillLevel <= 80 ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '6px', cursor: 'pointer', fontSize: '0.75rem', fontWeight: '600' }}>
                        <div style={{ width: '8px', height: '8px', borderRadius: '50%', background: skillLevel >= 41 && skillLevel <= 80 ? COLORS.textDark : 'rgba(255, 193, 7, 0.4)', margin: '0 auto 6px' }} />
                        INTERMEDIATE
                      </button>
                      <button onClick={() => setSkillLevel(90)} style={{ padding: '12px 8px', background: skillLevel >= 81 ? 'linear-gradient(135deg, #a61c1c, #8a1717)' : 'rgba(255, 255, 255, 0.03)', color: skillLevel >= 81 ? '#fff' : COLORS.textMuted, border: skillLevel >= 81 ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '6px', cursor: 'pointer', fontSize: '0.75rem', fontWeight: '600' }}>
                        <div style={{ width: '8px', height: '8px', borderRadius: '50%', background: skillLevel >= 81 ? '#ff6b6b' : 'rgba(255, 107, 107, 0.4)', margin: '0 auto 6px' }} />
                        EXPERT
                      </button>
                    </div>
                  </div>

                  {/* Sound */}
                  <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '12px 0' }}>
                    <span style={{ color: COLORS.textMuted, fontSize: '0.75rem', letterSpacing: '2px', fontWeight: '600' }}>SOUND</span>
                    <button onClick={() => setSoundEnabled(!soundEnabled)} style={{ padding: '6px 16px', background: soundEnabled ? 'linear-gradient(135deg, #2d8a2d, #1f6b1f)' : 'rgba(255, 255, 255, 0.05)', color: soundEnabled ? '#fff' : COLORS.textMuted, border: soundEnabled ? 'none' : '1px solid rgba(255, 255, 255, 0.1)', borderRadius: '4px', cursor: 'pointer', fontSize: '0.75rem', fontWeight: '600' }}>{soundEnabled ? 'ON' : 'OFF'}</button>
                  </div>
                </div>
              </div>
            </section>

            {/* Features Section */}
            <section style={{ padding: '80px 24px', background: COLORS.backgroundLight }}>
              <div style={{ maxWidth: '1200px', margin: '0 auto' }}>
                <h2 style={{ textAlign: 'center', color: COLORS.text, marginBottom: '16px' }}>Why Play Quik Darts?</h2>
                <p style={{ textAlign: 'center', color: COLORS.textMuted, marginBottom: '48px', maxWidth: '600px', margin: '0 auto 48px' }}>
                  Experience the thrill of competitive darts with features designed for players of all skill levels.
                </p>
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))', gap: '24px' }}>
                  {[
                    { icon: <TargetIcon size={32} color={COLORS.accent} />, title: 'Realistic Gameplay', desc: 'Authentic 501 rules with double-out finish. Power meter and aim wobble simulate real darts.' },
                    { icon: <GlobeIcon size={32} color={COLORS.accent} />, title: 'Play Online', desc: 'Challenge players worldwide in real-time matches. No account required to get started.' },
                    { icon: <UsersIcon size={32} color={COLORS.accent} />, title: 'Local Multiplayer', desc: 'Play with up to 4 players on the same device. Perfect for game night with friends.' },
                    { icon: <TrophyIcon size={32} color={COLORS.accent} />, title: 'Track Progress', desc: 'Earn achievements, track your stats, and climb the leaderboards.' }
                  ].map((feature, i) => (
                    <div key={i} style={{
                      background: COLORS.backgroundCard,
                      padding: '32px',
                      borderRadius: '12px',
                      border: `1px solid rgba(255,255,255,0.05)`
                    }}>
                      <div style={{ marginBottom: '16px' }}>{feature.icon}</div>
                      <h3 style={{ color: COLORS.text, fontSize: '1.25rem', marginBottom: '8px' }}>{feature.title}</h3>
                      <p style={{ color: COLORS.textMuted, fontSize: '0.95rem', lineHeight: '1.6' }}>{feature.desc}</p>
                    </div>
                  ))}
                </div>
              </div>
            </section>

            {/* CTA Section */}
            <section style={{ padding: '80px 24px', background: COLORS.background, textAlign: 'center' }}>
              <h2 style={{ color: COLORS.text, marginBottom: '16px' }}>Ready to Play?</h2>
              <p style={{ color: COLORS.textMuted, marginBottom: '32px', maxWidth: '500px', margin: '0 auto 32px' }}>
                Jump into a game now. No downloads, no sign-ups, just darts.
              </p>
              <button className="btn btn-primary" onClick={() => setGameState('menu')} style={{ fontSize: '1.1rem', padding: '16px 40px' }}>
                <PlayIcon /> Start Playing
              </button>
            </section>

            <Footer onNavigate={setGameState} />
          </div>
        );
      }

      // ============================================
      // HOW TO PLAY PAGE
      // ============================================
      if (gameState === 'howToPlay') {
        return (
          <div style={{ minHeight: '100vh', background: COLORS.background }}>
            <Navigation onNavigate={setGameState} currentPage="howToPlay" />

            <main style={{ paddingTop: '100px', paddingBottom: '80px' }}>
              <div style={{ maxWidth: '800px', margin: '0 auto', padding: '0 24px' }}>
                <h1 style={{ color: COLORS.text, marginBottom: '16px' }}>How to Play</h1>
                <p style={{ color: COLORS.textMuted, fontSize: '1.1rem', marginBottom: '48px' }}>
                  Learn the basics of Quik Darts and become a champion.
                </p>

                {/* Section: Basic Rules */}
                <section style={{ marginBottom: '48px' }}>
                  <h2 style={{ color: COLORS.accent, fontSize: '1.5rem', marginBottom: '16px', display: 'flex', alignItems: 'center', gap: '12px' }}>
                    <span style={{ background: COLORS.accent, color: COLORS.textDark, width: '32px', height: '32px', borderRadius: '50%', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '1rem', fontWeight: '700' }}>1</span>
                    Basic 501 Rules
                  </h2>
                  <div style={{ background: COLORS.backgroundCard, padding: '24px', borderRadius: '12px', border: '1px solid rgba(255,255,255,0.05)' }}>
                    <ul style={{ color: COLORS.textMuted, lineHeight: '1.8', paddingLeft: '20px' }}>
                      <li>Each player starts with <strong style={{ color: COLORS.text }}>501 points</strong></li>
                      <li>Throw 3 darts per turn to reduce your score</li>
                      <li>Score is subtracted from your total after each turn</li>
                      <li>You must finish exactly on <strong style={{ color: COLORS.text }}>0 points</strong></li>
                      <li>The final dart must land on a <strong style={{ color: COLORS.accent }}>double</strong> (outer ring) or the bullseye</li>
                      <li>If you go below 0 or hit exactly 1, your turn is "bust" and your score resets</li>
                    </ul>
                  </div>
                </section>

                {/* Section: Scoring */}
                <section style={{ marginBottom: '48px' }}>
                  <h2 style={{ color: COLORS.accent, fontSize: '1.5rem', marginBottom: '16px', display: 'flex', alignItems: 'center', gap: '12px' }}>
                    <span style={{ background: COLORS.accent, color: COLORS.textDark, width: '32px', height: '32px', borderRadius: '50%', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '1rem', fontWeight: '700' }}>2</span>
                    Dartboard Scoring
                  </h2>
                  <div style={{ background: COLORS.backgroundCard, padding: '24px', borderRadius: '12px', border: '1px solid rgba(255,255,255,0.05)' }}>
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '16px' }}>
                      <div style={{ padding: '16px', background: 'rgba(0,0,0,0.2)', borderRadius: '8px' }}>
                        <h4 style={{ color: COLORS.text, marginBottom: '8px' }}>Single (Main Bed)</h4>
                        <p style={{ color: COLORS.textMuted, fontSize: '0.9rem' }}>Face value of the number (1-20)</p>
                      </div>
                      <div style={{ padding: '16px', background: 'rgba(0,0,0,0.2)', borderRadius: '8px' }}>
                        <h4 style={{ color: COLORS.text, marginBottom: '8px' }}>Double (Outer Ring)</h4>
                        <p style={{ color: COLORS.textMuted, fontSize: '0.9rem' }}>2x the number value</p>
                      </div>
                      <div style={{ padding: '16px', background: 'rgba(0,0,0,0.2)', borderRadius: '8px' }}>
                        <h4 style={{ color: COLORS.text, marginBottom: '8px' }}>Triple (Inner Ring)</h4>
                        <p style={{ color: COLORS.textMuted, fontSize: '0.9rem' }}>3x the number value</p>
                      </div>
                      <div style={{ padding: '16px', background: 'rgba(0,0,0,0.2)', borderRadius: '8px' }}>
                        <h4 style={{ color: COLORS.text, marginBottom: '8px' }}>Bullseye</h4>
                        <p style={{ color: COLORS.textMuted, fontSize: '0.9rem' }}>Outer: 25 | Inner: 50 (double)</p>
                      </div>
                    </div>
                  </div>
                </section>

                {/* Section: Controls */}
                <section style={{ marginBottom: '48px' }}>
                  <h2 style={{ color: COLORS.accent, fontSize: '1.5rem', marginBottom: '16px', display: 'flex', alignItems: 'center', gap: '12px' }}>
                    <span style={{ background: COLORS.accent, color: COLORS.textDark, width: '32px', height: '32px', borderRadius: '50%', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '1rem', fontWeight: '700' }}>3</span>
                    How to Throw
                  </h2>
                  <div style={{ background: COLORS.backgroundCard, padding: '24px', borderRadius: '12px', border: '1px solid rgba(255,255,255,0.05)' }}>
                    <ol style={{ color: COLORS.textMuted, lineHeight: '2', paddingLeft: '20px' }}>
                      <li><strong style={{ color: COLORS.text }}>Aim:</strong> Move your mouse/finger to position your aim on the dartboard</li>
                      <li><strong style={{ color: COLORS.text }}>Charge:</strong> Press and hold the mouse button or tap and hold to charge power</li>
                      <li><strong style={{ color: COLORS.text }}>Release:</strong> Let go when the power meter is in the green zone (40-60%) for best accuracy</li>
                      <li><strong style={{ color: COLORS.text }}>Wobble:</strong> Your aim naturally wobbles - this simulates real throwing variance</li>
                    </ol>
                    <div style={{ marginTop: '16px', padding: '16px', background: `${COLORS.accent}15`, borderRadius: '8px', borderLeft: `3px solid ${COLORS.accent}` }}>
                      <p style={{ color: COLORS.text, fontSize: '0.9rem', margin: 0 }}>
                        <strong>Pro Tip:</strong> Higher skill levels reduce wobble. Practice to improve your accuracy!
                      </p>
                    </div>
                  </div>
                </section>

                {/* Section: Game Modes */}
                <section style={{ marginBottom: '48px' }}>
                  <h2 style={{ color: COLORS.accent, fontSize: '1.5rem', marginBottom: '16px', display: 'flex', alignItems: 'center', gap: '12px' }}>
                    <span style={{ background: COLORS.accent, color: COLORS.textDark, width: '32px', height: '32px', borderRadius: '50%', display: 'flex', alignItems: 'center', justifyContent: 'center', fontSize: '1rem', fontWeight: '700' }}>4</span>
                    Game Modes
                  </h2>
                  <div style={{ display: 'grid', gap: '16px' }}>
                    {[
                      { title: 'Local Play', desc: '1-4 players on the same device. Add AI opponents for extra challenge.' },
                      { title: 'Online Match', desc: 'Play against real opponents worldwide. Get matched instantly.' },
                      { title: 'Practice Mode', desc: 'Hone your skills with unlimited throws. No pressure, just practice.' }
                    ].map((mode, i) => (
                      <div key={i} style={{ background: COLORS.backgroundCard, padding: '20px', borderRadius: '12px', border: '1px solid rgba(255,255,255,0.05)' }}>
                        <h4 style={{ color: COLORS.text, marginBottom: '8px' }}>{mode.title}</h4>
                        <p style={{ color: COLORS.textMuted, fontSize: '0.95rem', margin: 0 }}>{mode.desc}</p>
                      </div>
                    ))}
                  </div>
                </section>

                <div style={{ textAlign: 'center', marginTop: '48px' }}>
                  <button className="btn btn-primary" onClick={() => setGameState('menu')} style={{ fontSize: '1.1rem', padding: '16px 40px' }}>
                    <PlayIcon /> Start Playing
                  </button>
                </div>
              </div>
            </main>

            <Footer onNavigate={setGameState} />
          </div>
        );
      }

      // ============================================
      // GAME SETUP MENU
      // ============================================
      if (gameState === 'menu') {
        return (
          <div style={{ minHeight: '100vh', background: COLORS.background }}>
            <Navigation onNavigate={setGameState} currentPage="menu" />

            <main style={{
              minHeight: '100vh',
              display: 'flex',
              flexDirection: 'column',
              alignItems: 'center',
              justifyContent: 'center',
              padding: '100px 20px 40px',
              position: 'relative'
            }}>
              {/* Background accent */}
              <div style={{
                position: 'absolute',
                inset: 0,
                background: `radial-gradient(ellipse at 50% 0%, ${COLORS.primary}30 0%, transparent 50%), radial-gradient(ellipse at 80% 100%, ${COLORS.accent}15 0%, transparent 40%)`,
                zIndex: 0
              }} />

            {/* Decorative dartboard silhouette */}
            <div style={{
              position: 'absolute',
              right: '-150px',
              top: '50%',
              transform: 'translateY(-50%)',
              width: '500px',
              height: '500px',
              opacity: 0.03,
              zIndex: 1,
              background: 'radial-gradient(circle, #fff 0%, #fff 8%, transparent 8%, transparent 15%, #fff 15%, #fff 20%, transparent 20%, transparent 45%, #fff 45%, #fff 48%, transparent 48%, transparent 85%, #fff 85%, #fff 90%, transparent 90%)',
              borderRadius: '50%'
            }} />

            {/* Title section */}
            <div style={{ textAlign: 'center', marginBottom: '40px', zIndex: 2, position: 'relative' }}>
              <h1 style={{
                fontSize: 'clamp(36px, 10vw, 56px)',
                fontWeight: '800',
                margin: '0',
                color: COLORS.text
              }}>Game Setup</h1>
              <p style={{ color: COLORS.textMuted, marginTop: '8px' }}>Configure your match settings</p>
            </div>

            {/* Main content card */}
            <div style={{
              background: COLORS.backgroundCard,
              borderRadius: '16px',
              padding: '32px',
              border: '1px solid rgba(255, 255, 255, 0.05)',
              boxShadow: '0 25px 60px rgba(0, 0, 0, 0.5)',
              width: '100%',
              maxWidth: '480px',
              zIndex: 2,
              position: 'relative'
            }}>
              {/* Main action buttons - 2x2 Grid */}
              <div style={{
                display: 'grid',
                gridTemplateColumns: 'repeat(2, 1fr)',
                gap: '12px',
                marginBottom: '24px'
              }}>
                <button className="btn btn-primary" onClick={startGame} style={{
                  padding: '20px 16px',
                  fontSize: '0.95rem',
                  display: 'flex',
                  flexDirection: 'column',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '8px',
                  borderRadius: '12px',
                  minHeight: '90px'
                }}><DartIcon size={24} color={COLORS.textDark} />Start Game</button>

                <button className="btn btn-secondary" onClick={handlePlayOnlineClick} style={{
                  padding: '20px 16px',
                  fontSize: '0.95rem',
                  display: 'flex',
                  flexDirection: 'column',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '8px',
                  borderRadius: '12px',
                  minHeight: '90px'
                }}><GlobeIcon size={24} color={COLORS.text} />Play Online</button>

                <button className="btn btn-ghost" onClick={enterPracticeMode} style={{
                  padding: '20px 16px',
                  fontSize: '0.95rem',
                  display: 'flex',
                  flexDirection: 'column',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '8px',
                  borderRadius: '12px',
                  minHeight: '90px'
                }}><TargetIcon size={24} color={COLORS.text} />Practice Mode</button>

                <button className="btn btn-ghost" onClick={() => setShowAchievements(true)} style={{
                  padding: '20px 16px',
                  fontSize: '0.95rem',
                  display: 'flex',
                  flexDirection: 'column',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '8px',
                  borderRadius: '12px',
                  minHeight: '90px',
                  color: COLORS.accent,
                  borderColor: `${COLORS.accent}40`
                }}><TrophyIcon size={24} color={COLORS.accent} />Achievements</button>
              </div>

              {/* Divider */}
              <div style={{ height: '1px', background: `linear-gradient(90deg, transparent, ${COLORS.accent}30, transparent)`, marginBottom: '24px' }} />

              <div style={{ marginBottom: '20px' }}>
                <label style={{ color: COLORS.textMuted, fontSize: '0.75rem', letterSpacing: '2px', display: 'block', marginBottom: '10px', fontWeight: '600', textTransform: 'uppercase' }}>Game Mode</label>
                <div style={{ display: 'flex', gap: '8px' }}>
                  {[301, 501].map(mode => (
                    <button key={mode} onClick={() => setPlayerSetup(prev => ({ ...prev, gameMode: mode }))} style={{ flex: 1, padding: '12px', fontSize: '1rem', fontWeight: '600', background: playerSetup.gameMode === mode ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentDark})` : 'rgba(255, 255, 255, 0.03)', color: playerSetup.gameMode === mode ? COLORS.textDark : COLORS.textMuted, border: playerSetup.gameMode === mode ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '6px', cursor: 'pointer', fontFamily: 'var(--font-primary)' }}>{mode}</button>
                  ))}
                </div>
              </div>

              <div style={{ marginBottom: '22px' }}>
                <label style={{ color: 'rgba(201, 162, 39, 0.8)', fontSize: '11px', letterSpacing: '3px', display: 'block', marginBottom: '10px', fontWeight: '500' }}>LEGS PER SET</label>
                <div style={{ display: 'flex', gap: '8px' }}>
                  {[1, 3, 5, 7].map(legs => (
                    <button key={legs} onClick={() => setPlayerSetup(prev => ({ ...prev, legsPerSet: legs }))} style={{ flex: 1, padding: '14px', fontSize: '18px', fontWeight: '600', background: playerSetup.legsPerSet === legs ? 'linear-gradient(180deg, #c9a227 0%, #a68b1f 100%)' : 'rgba(255, 255, 255, 0.03)', color: playerSetup.legsPerSet === legs ? '#0a0a0f' : 'rgba(255, 255, 255, 0.5)', border: playerSetup.legsPerSet === legs ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '6px', cursor: 'pointer', fontFamily: "'Oswald', sans-serif", boxShadow: playerSetup.legsPerSet === legs ? 'inset 0 1px 0 rgba(255, 255, 255, 0.3)' : 'none' }}>{legs}</button>
                  ))}
                </div>
              </div>

              <div style={{ marginBottom: '22px' }}>
                <label style={{ color: 'rgba(201, 162, 39, 0.8)', fontSize: '11px', letterSpacing: '3px', display: 'block', marginBottom: '10px', fontWeight: '500' }}>SETS TO WIN</label>
                <div style={{ display: 'flex', gap: '8px' }}>
                  {[1, 3, 5, 7].map(sets => (
                    <button key={sets} onClick={() => setPlayerSetup(prev => ({ ...prev, setsToWin: sets }))} style={{ flex: 1, padding: '14px', fontSize: '18px', fontWeight: '600', background: playerSetup.setsToWin === sets ? 'linear-gradient(180deg, #c9a227 0%, #a68b1f 100%)' : 'rgba(255, 255, 255, 0.03)', color: playerSetup.setsToWin === sets ? '#0a0a0f' : 'rgba(255, 255, 255, 0.5)', border: playerSetup.setsToWin === sets ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '6px', cursor: 'pointer', fontFamily: "'Oswald', sans-serif", boxShadow: playerSetup.setsToWin === sets ? 'inset 0 1px 0 rgba(255, 255, 255, 0.3)' : 'none' }}>{sets}</button>
                  ))}
                </div>
              </div>

              <div style={{ marginBottom: '22px' }}>
                <label style={{ color: 'rgba(201, 162, 39, 0.8)', fontSize: '11px', letterSpacing: '3px', display: 'block', marginBottom: '10px', fontWeight: '500' }}>PLAYERS</label>
                <div style={{ display: 'flex', gap: '8px' }}>
                  {[1, 2, 3, 4].map(num => (
                    <button key={num} onClick={() => setPlayerSetup(prev => ({ ...prev, count: num }))} style={{ flex: 1, padding: '14px', fontSize: '18px', fontWeight: '600', background: playerSetup.count === num ? 'linear-gradient(180deg, #c9a227 0%, #a68b1f 100%)' : 'rgba(255, 255, 255, 0.03)', color: playerSetup.count === num ? '#0a0a0f' : 'rgba(255, 255, 255, 0.5)', border: playerSetup.count === num ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '6px', cursor: 'pointer', fontFamily: "'Oswald', sans-serif", boxShadow: playerSetup.count === num ? 'inset 0 1px 0 rgba(255, 255, 255, 0.3)' : 'none' }}>{num}</button>
                  ))}
                </div>
              </div>
              
              {Array.from({ length: playerSetup.count }).map((_, i) => (
                <div key={i} style={{ marginBottom: '12px', background: 'rgba(0, 0, 0, 0.3)', padding: '14px', borderRadius: '8px', border: '1px solid rgba(255, 255, 255, 0.05)' }}>
                  <input
                    type="text"
                    id={`online-player-name-${i}`}
                    name={`online-player-name-${i}`}
                    aria-label={`Player ${i + 1} name`}
                    value={playerSetup.names[i]}
                    onChange={(e) => {
                      const newNames = [...playerSetup.names];
                      newNames[i] = sanitizeName(e.target.value);
                      setPlayerSetup(prev => ({ ...prev, names: newNames }));
                    }}
                    placeholder={`Player ${i + 1}`}
                    maxLength={20}
                    style={{ width: '100%', padding: '11px 14px', fontSize: '14px', background: 'rgba(255, 255, 255, 0.05)', border: '1px solid rgba(255, 255, 255, 0.1)', borderRadius: '6px', color: 'rgba(255, 255, 255, 0.9)', outline: 'none', fontFamily: "'Roboto Mono', monospace", boxSizing: 'border-box', marginBottom: '10px' }}
                  />

                  <div style={{ marginBottom: '10px' }}>
                    <label htmlFor={`online-player-flag-${i}`} style={{ color: 'rgba(255, 255, 255, 0.4)', fontSize: '10px', letterSpacing: '2px', display: 'block', marginBottom: '6px' }}>NATIONALITY</label>
                    <select id={`online-player-flag-${i}`} name={`online-player-flag-${i}`} value={playerSetup.flags[i]} onChange={(e) => { const newFlags = [...playerSetup.flags]; newFlags[i] = e.target.value; setPlayerSetup(prev => ({ ...prev, flags: newFlags })); }} style={{ width: '100%', padding: '10px 12px', fontSize: '14px', background: 'rgba(255, 255, 255, 0.05)', border: '1px solid rgba(255, 255, 255, 0.1)', borderRadius: '6px', color: 'rgba(255, 255, 255, 0.9)', outline: 'none', fontFamily: "'Roboto Mono', monospace", cursor: 'pointer', boxSizing: 'border-box' }}>
                      {COUNTRIES.map(country => (
                        <option key={country.name} value={country.flag} style={{ background: '#1a1a1a', color: '#fff' }}>
                          {country.flag} {country.name}
                        </option>
                      ))}
                    </select>
                  </div>

                  {i > 0 && playerSetup.count > 1 && (
                    <>
                      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: playerSetup.aiPlayers[i] ? '10px' : '0' }}>
                        <span style={{ color: 'rgba(255, 255, 255, 0.4)', fontSize: '10px', letterSpacing: '2px' }}>AI OPPONENT</span>
                        <button onClick={() => {
                          const newAiPlayers = [...playerSetup.aiPlayers];
                          newAiPlayers[i] = !newAiPlayers[i];
                          const newAiDifficulty = [...playerSetup.aiDifficulty];
                          if (newAiPlayers[i] && !newAiDifficulty[i]) newAiDifficulty[i] = AI_DIFFICULTIES.INTERMEDIATE.key;
                          setPlayerSetup(prev => ({ ...prev, aiPlayers: newAiPlayers, aiDifficulty: newAiDifficulty }));
                        }} style={{ padding: '5px 14px', background: playerSetup.aiPlayers[i] ? 'linear-gradient(180deg, #2d8a2d, #1f6b1f)' : 'rgba(255, 255, 255, 0.05)', color: playerSetup.aiPlayers[i] ? '#fff' : 'rgba(255, 255, 255, 0.4)', border: playerSetup.aiPlayers[i] ? 'none' : '1px solid rgba(255, 255, 255, 0.1)', borderRadius: '4px', cursor: 'pointer', fontFamily: "'Oswald', sans-serif", fontSize: '11px', fontWeight: '600', letterSpacing: '1px' }}>
                          {playerSetup.aiPlayers[i] ? 'ON' : 'OFF'}
                        </button>
                      </div>

                      {playerSetup.aiPlayers[i] && (
                        <div>
                          <label style={{ color: 'rgba(255, 255, 255, 0.4)', fontSize: '10px', letterSpacing: '2px', display: 'block', marginBottom: '6px' }}>DIFFICULTY</label>
                          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(4, 1fr)', gap: '5px' }}>
                            {Object.values(AI_DIFFICULTIES).map(d => (
                              <button key={d.key} onClick={() => {
                                const newAiDifficulty = [...playerSetup.aiDifficulty];
                                newAiDifficulty[i] = d.key;
                                setPlayerSetup(prev => ({ ...prev, aiDifficulty: newAiDifficulty }));
                              }} style={{ padding: '7px 4px', fontSize: '10px', fontWeight: '600', background: playerSetup.aiDifficulty[i] === d.key ? 'linear-gradient(180deg, #c9a227 0%, #a68b1f 100%)' : 'rgba(255, 255, 255, 0.03)', color: playerSetup.aiDifficulty[i] === d.key ? '#0a0a0f' : 'rgba(255, 255, 255, 0.4)', border: playerSetup.aiDifficulty[i] === d.key ? 'none' : '1px solid rgba(255, 255, 255, 0.08)', borderRadius: '4px', cursor: 'pointer', fontFamily: "'Oswald', sans-serif", textTransform: 'uppercase', letterSpacing: '0.5px' }}>
                                {d.label.slice(0, 3).toUpperCase()}
                              </button>
                            ))}
                          </div>
                        </div>
                      )}
                    </>
                  )}
                </div>
              ))}
              
              {/* Divider */}
              <div style={{ height: '1px', background: 'linear-gradient(90deg, transparent, rgba(201, 162, 39, 0.2), transparent)', margin: '20px 0' }} />

              <div style={{ marginBottom: '20px' }}>
                <label style={{ color: 'rgba(201, 162, 39, 0.8)', fontSize: '11px', letterSpacing: '3px', display: 'block', marginBottom: '10px', fontWeight: '500' }}>SKILL LEVEL</label>
                <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '8px' }}>
                  <button
                    onClick={() => setSkillLevel(30)}
                    style={{
                      padding: '14px 8px',
                      background: skillLevel <= 40 ? 'linear-gradient(180deg, #2d8a2d, #1f6b1f)' : 'rgba(255, 255, 255, 0.03)',
                      color: skillLevel <= 40 ? '#fff' : 'rgba(255, 255, 255, 0.5)',
                      border: skillLevel <= 40 ? 'none' : '1px solid rgba(255, 255, 255, 0.08)',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      fontFamily: "'Oswald', sans-serif",
                      fontSize: '12px',
                      fontWeight: '600',
                      letterSpacing: '1px',
                      boxShadow: skillLevel <= 40 ? 'inset 0 1px 0 rgba(255, 255, 255, 0.2)' : 'none'
                    }}
                  >
                    <div style={{ width: '8px', height: '8px', borderRadius: '50%', background: skillLevel <= 40 ? '#90EE90' : 'rgba(144, 238, 144, 0.4)', margin: '0 auto 6px' }} />
                    BEGINNER
                  </button>
                  <button
                    onClick={() => setSkillLevel(60)}
                    style={{
                      padding: '14px 8px',
                      background: skillLevel >= 41 && skillLevel <= 80 ? 'linear-gradient(180deg, #c9a227, #a68b1f)' : 'rgba(255, 255, 255, 0.03)',
                      color: skillLevel >= 41 && skillLevel <= 80 ? '#0a0a0f' : 'rgba(255, 255, 255, 0.5)',
                      border: skillLevel >= 41 && skillLevel <= 80 ? 'none' : '1px solid rgba(255, 255, 255, 0.08)',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      fontFamily: "'Oswald', sans-serif",
                      fontSize: '12px',
                      fontWeight: '600',
                      letterSpacing: '1px',
                      boxShadow: skillLevel >= 41 && skillLevel <= 80 ? 'inset 0 1px 0 rgba(255, 255, 255, 0.3)' : 'none'
                    }}
                  >
                    <div style={{ width: '8px', height: '8px', borderRadius: '50%', background: skillLevel >= 41 && skillLevel <= 80 ? '#0a0a0f' : 'rgba(255, 193, 7, 0.4)', margin: '0 auto 6px' }} />
                    INTERMEDIATE
                  </button>
                  <button
                    onClick={() => setSkillLevel(90)}
                    style={{
                      padding: '14px 8px',
                      background: skillLevel >= 81 ? 'linear-gradient(180deg, #a61c1c, #8a1717)' : 'rgba(255, 255, 255, 0.03)',
                      color: skillLevel >= 81 ? '#fff' : 'rgba(255, 255, 255, 0.5)',
                      border: skillLevel >= 81 ? 'none' : '1px solid rgba(255, 255, 255, 0.08)',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      fontFamily: "'Oswald', sans-serif",
                      fontSize: '12px',
                      fontWeight: '600',
                      letterSpacing: '1px',
                      boxShadow: skillLevel >= 81 ? 'inset 0 1px 0 rgba(255, 255, 255, 0.2)' : 'none'
                    }}
                  >
                    <div style={{ width: '8px', height: '8px', borderRadius: '50%', background: skillLevel >= 81 ? '#ff6b6b' : 'rgba(255, 107, 107, 0.4)', margin: '0 auto 6px' }} />
                    EXPERT
                  </button>
                </div>
              </div>

              <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '12px 0' }}>
                <span style={{ color: 'rgba(255, 255, 255, 0.5)', fontSize: '12px', letterSpacing: '2px' }}>SOUND</span>
                <button onClick={() => setSoundEnabled(!soundEnabled)} style={{ padding: '6px 16px', background: soundEnabled ? 'linear-gradient(180deg, #2d8a2d, #1f6b1f)' : 'rgba(255, 255, 255, 0.05)', color: soundEnabled ? '#fff' : 'rgba(255, 255, 255, 0.4)', border: soundEnabled ? 'none' : '1px solid rgba(255, 255, 255, 0.1)', borderRadius: '4px', cursor: 'pointer', fontFamily: "'Oswald', sans-serif", fontSize: '12px', fontWeight: '600', letterSpacing: '1px' }}>{soundEnabled ? 'ON' : 'OFF'}</button>
              </div>
            </div>

            <p style={{ color: COLORS.textMuted, marginTop: '24px', fontSize: '0.85rem', zIndex: 2, position: 'relative' }}>Hold to charge power ‚Ä¢ Release to throw</p>
            </main>

            <Footer onNavigate={setGameState} />
          </div>
        );
      }

      return (
        <div style={{ minHeight: '100vh', background: COLORS.background, padding: '20px', paddingTop: onlineMode && isWageredMatch ? (window.innerWidth < 768 ? '84px' : '92px') : '20px', fontFamily: "'Inter', sans-serif", position: 'relative' }}>
          {/* Wagered Match Header */}
          {onlineMode && isWageredMatch && (
            <WageredMatchHeader
              pot={escrowData?.totalPot || (selectedStake * 2)}
              player1={{
                uid: players[0]?.uid || '',
                name: players[0]?.name || '',
                level: players[0]?.level || userProgression?.level || 1,
                avatarUrl: players[0]?.avatarUrl,
                stake: selectedStake
              }}
              player2={{
                uid: players[1]?.uid || '',
                name: players[1]?.name || opponentName || 'Opponent',
                level: players[1]?.level || 1,
                avatarUrl: players[1]?.avatarUrl,
                stake: selectedStake
              }}
              phase={matchWinner ? 'end' : 'inmatch'}
              winnerUid={matchWinner !== null ? (matchWinner === 0 ? players[0]?.uid : players[1]?.uid) : null}
              isWagered={isWageredMatch}
              currentUserId={currentUser?.uid}
            />
          )}
          {/* Background gradient matching home screen */}
          <div style={{ position: 'absolute', inset: 0, background: `radial-gradient(ellipse at 30% 20%, ${COLORS.primary}40 0%, transparent 50%), radial-gradient(ellipse at 70% 80%, ${COLORS.accent}20 0%, transparent 40%)`, zIndex: 0, pointerEvents: 'none' }} />
          <div className="game-layout" style={{ display: 'flex', flexWrap: 'wrap', gap: '30px', maxWidth: '1400px', margin: '0 auto', justifyContent: 'center', position: 'relative', zIndex: 1 }}>
            {/* Scoreboard or Practice Stats */}
            <div className="game-scoreboard" style={{ background: COLORS.backgroundCard, borderRadius: '16px', padding: '25px', minWidth: '280px', backdropFilter: 'blur(10px)', border: practiceMode === 'active' ? `1px solid ${COLORS.primary}50` : `1px solid ${COLORS.accent}30` }}>
              {practiceMode === 'active' ? (
                <>
                  <h2 style={{ color: COLORS.primary, margin: '0 0 20px 0', letterSpacing: '2px', fontSize: '16px', fontWeight: '700', display: 'flex', alignItems: 'center', gap: '10px' }}>
                    <span>üéØ</span> PRACTICE MODE
                  </h2>

                  <div style={{ background: `${COLORS.primary}15`, borderRadius: '10px', padding: '15px', marginBottom: '20px', border: `1px solid ${COLORS.primary}30` }}>
                    <div style={{ color: COLORS.textMuted, fontSize: '11px', letterSpacing: '1px', marginBottom: '5px' }}>SKILL LEVEL</div>
                    <div style={{ color: COLORS.text, fontSize: '16px', fontWeight: '600' }}>
                      {practiceSkillLevel <= 40 && 'üü¢ BEGINNER'}
                      {practiceSkillLevel > 40 && practiceSkillLevel <= 80 && 'üü° INTERMEDIATE'}
                      {practiceSkillLevel > 80 && 'üî¥ EXPERT'}
                    </div>
                  </div>

                  <div style={{ background: 'rgba(255, 255, 255, 0.03)', borderRadius: '10px', padding: '15px', marginBottom: '15px', border: '1px solid rgba(255, 255, 255, 0.05)' }}>
                    <div style={{ color: COLORS.accent, fontSize: '11px', letterSpacing: '2px', marginBottom: '10px', fontWeight: '600' }}>SESSION STATS</div>
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px', fontSize: '14px' }}>
                      <div>
                        <div style={{ color: COLORS.textMuted, fontSize: '11px' }}>Darts Thrown</div>
                        <div style={{ fontSize: '20px', fontWeight: '600', color: COLORS.text }}>{practiceStats.dartsThrown}</div>
                      </div>
                      <div>
                        <div style={{ color: COLORS.textMuted, fontSize: '11px' }}>Total Score</div>
                        <div style={{ fontSize: '20px', fontWeight: '600', color: COLORS.text }}>{practiceStats.totalScore}</div>
                      </div>
                      <div>
                        <div style={{ color: COLORS.textMuted, fontSize: '11px' }}>Average</div>
                        <div style={{ fontSize: '20px', fontWeight: '600', color: COLORS.success }}>
                          {practiceStats.dartsThrown > 0 ? (practiceStats.totalScore / practiceStats.dartsThrown).toFixed(1) : '0.0'}
                        </div>
                      </div>
                      <div>
                        <div style={{ color: COLORS.textMuted, fontSize: '11px' }}>Bulls</div>
                        <div style={{ fontSize: '20px', fontWeight: '600', color: COLORS.error }}>{practiceStats.bulls}</div>
                      </div>
                    </div>
                  </div>

                  <div style={{ background: 'rgba(255, 255, 255, 0.03)', borderRadius: '10px', padding: '15px', marginBottom: '20px', border: '1px solid rgba(255, 255, 255, 0.05)' }}>
                    <div style={{ color: COLORS.accent, fontSize: '11px', letterSpacing: '2px', marginBottom: '10px', fontWeight: '600' }}>ACCURACY</div>
                    <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '10px', fontSize: '14px' }}>
                      <div>
                        <div style={{ color: COLORS.textMuted, fontSize: '11px' }}>Triples</div>
                        <div style={{ fontSize: '18px', fontWeight: '600', color: COLORS.text }}>{practiceStats.triples}</div>
                      </div>
                      <div>
                        <div style={{ color: COLORS.textMuted, fontSize: '11px' }}>Doubles</div>
                        <div style={{ fontSize: '18px', fontWeight: '600', color: COLORS.text }}>{practiceStats.doubles}</div>
                      </div>
                      <div>
                        <div style={{ color: COLORS.textMuted, fontSize: '11px' }}>T20</div>
                        <div style={{ fontSize: '18px', fontWeight: '600', color: COLORS.success }}>{practiceStats.t20}</div>
                      </div>
                      <div>
                        <div style={{ color: COLORS.textMuted, fontSize: '11px' }}>T19</div>
                        <div style={{ fontSize: '18px', fontWeight: '600', color: COLORS.text }}>{practiceStats.t19}</div>
                      </div>
                    </div>
                  </div>

                  <button
                    onClick={exitPracticeMode}
                    style={{
                      width: '100%',
                      padding: '15px',
                      background: `linear-gradient(135deg, ${COLORS.error}, #e74c3c)`,
                      color: COLORS.text,
                      border: 'none',
                      borderRadius: '10px',
                      fontSize: '14px',
                      fontWeight: '600',
                      cursor: 'pointer',
                      fontFamily: "'Inter', sans-serif",
                      letterSpacing: '1px',
                      textTransform: 'uppercase'
                    }}
                  >
                    Exit Practice
                  </button>
                </>
              ) : (
                <>
                  <h2 style={{ color: COLORS.accent, margin: '0 0 20px 0', letterSpacing: '2px', fontSize: '16px', fontWeight: '700' }}>SCOREBOARD</h2>

                  {players.map((player, index) => (
                <div key={index} style={{ background: currentPlayerIndex === index ? `linear-gradient(135deg, ${COLORS.accent}20, ${COLORS.accent}10)` : 'rgba(255, 255, 255, 0.03)', borderRadius: '12px', padding: '20px', marginBottom: '15px', border: currentPlayerIndex === index ? `2px solid ${COLORS.accent}` : '1px solid rgba(255, 255, 255, 0.08)' }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '5px' }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                      <span style={{ fontSize: '20px' }}>{player.flag}</span>
                      <span style={{ color: COLORS.text, fontSize: '15px', fontWeight: '500' }}>{player.name}</span>
                      {player.isAI && <span style={{ background: `${COLORS.primary}40`, color: COLORS.primaryLight, padding: '2px 8px', borderRadius: '10px', fontSize: '10px', fontWeight: '600', letterSpacing: '1px' }}>AI</span>}
                    </div>
                    {currentPlayerIndex === index && <span style={{ color: COLORS.accent, fontSize: '11px', fontWeight: '600' }}>‚ñ∂ THROWING</span>}
                  </div>
                  {player.isAI && <div style={{ fontSize: '10px', color: COLORS.primaryLight, marginBottom: '5px', textTransform: 'uppercase', fontWeight: '500' }}>{player.aiDifficulty}</div>}
                  <div style={{ fontSize: '48px', fontWeight: '700', color: player.score <= 170 ? COLORS.success : COLORS.text, textAlign: 'center', margin: '10px 0', fontFamily: "'Roboto Mono', monospace" }}>{player.score}</div>
                  {gameStats[index] && <div style={{ fontSize: '12px', color: COLORS.textMuted, textAlign: 'center' }}>Avg: {gameStats[index].averagePerSet} (3-dart)</div>}
                  {(playerSetup.legsPerSet > 1 || playerSetup.setsToWin > 1) && (
                    <div style={{ fontSize: '11px', color: COLORS.accent, textAlign: 'center', marginTop: '8px', letterSpacing: '1px' }}>
                      Sets: {setScores[index] || 0} | Legs: {legScores[index] || 0}
                    </div>
                  )}
                </div>
              ))}
              
              {checkout && (
                <div style={{ background: `linear-gradient(135deg, ${COLORS.success}20, ${COLORS.success}10)`, borderRadius: '10px', padding: '15px', marginTop: '20px', border: `1px solid ${COLORS.success}40` }}>
                  <div style={{ color: COLORS.success, fontSize: '11px', letterSpacing: '2px', marginBottom: '5px', fontWeight: '600' }}>CHECKOUT</div>
                  <div style={{ color: COLORS.text, fontSize: '18px', fontWeight: '600' }}>{checkout}</div>
                </div>
              )}

              {onlineMode && (
                <div style={{ marginTop: '20px', padding: '15px', background: `linear-gradient(135deg, ${COLORS.primary}30, ${COLORS.primary}20)`, borderRadius: '10px', border: `2px solid ${COLORS.primaryLight}` }}>
                  <div style={{ color: COLORS.primaryLight, fontSize: '11px', fontWeight: '600', letterSpacing: '2px', marginBottom: '8px' }}>
                    {isWageredMatch ? 'üí∞ WAGERED MATCH' : 'üåç ONLINE MATCH'}
                  </div>
                  <div style={{ color: currentPlayerIndex === playerId ? COLORS.success : COLORS.accent, fontSize: '15px', fontWeight: '700', letterSpacing: '1px' }}>
                    {currentPlayerIndex === playerId ? '‚ñ∂ YOUR TURN' : '‚è∏ OPPONENT\'S TURN'}
                  </div>
                </div>
              )}

              {/* Rhythm Indicator - shows during your turn in online matches */}
              {onlineMode && currentPlayerIndex === playerId && rhythmState !== 'neutral' && (
                <div
                  className="rhythm-indicator"
                  style={{
                    marginTop: '15px',
                    padding: '12px 16px',
                    borderRadius: '10px',
                    textAlign: 'center',
                    animation: 'rhythmPulse 0.5s ease-out',
                    background: rhythmState === 'flow' ? 'rgba(255, 215, 0, 0.15)' :
                               rhythmState === 'perfect' ? 'rgba(76, 175, 80, 0.15)' :
                               'rgba(255, 152, 0, 0.15)',
                    border: `2px solid ${
                      rhythmState === 'flow' ? '#FFD700' :
                      rhythmState === 'perfect' ? '#4CAF50' :
                      '#FF9800'
                    }`,
                  }}
                >
                  <div style={{
                    fontSize: '20px',
                    marginBottom: '4px'
                  }}>
                    {rhythmState === 'flow' ? 'üî•' :
                     rhythmState === 'perfect' ? 'üéØ' :
                     rhythmState === 'rushing' ? '‚ö°' :
                     rhythmState === 'hesitating' ? '‚è≥' : ''}
                  </div>
                  <div style={{
                    fontSize: '12px',
                    fontWeight: '600',
                    letterSpacing: '1px',
                    color: rhythmState === 'flow' ? '#FFD700' :
                           rhythmState === 'perfect' ? '#4CAF50' :
                           '#FF9800'
                  }}>
                    {rhythmState === 'flow' ? 'IN THE ZONE!' :
                     rhythmState === 'perfect' ? 'PERFECT RHYTHM' :
                     rhythmState === 'rushing' ? 'SLOW DOWN' :
                     rhythmState === 'hesitating' ? 'KEEP MOVING' : ''}
                  </div>
                </div>
              )}

              <div style={{ marginTop: '20px', padding: '15px', background: 'rgba(255, 255, 255, 0.03)', borderRadius: '10px', border: '1px solid rgba(255, 255, 255, 0.05)' }}>
                <div style={{ color: COLORS.textMuted, fontSize: '11px', marginBottom: '5px', letterSpacing: '1px' }}>TURN SCORE</div>
                <div style={{
                  color: scoreConfirming ? COLORS.textMuted : COLORS.accent,
                  fontSize: '32px',
                  fontWeight: '700',
                  fontFamily: "'Roboto Mono', monospace",
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center',
                  gap: '10px'
                }}>
                  {currentTurnScore}
                  {scoreConfirming && (
                    <span style={{
                      fontSize: '12px',
                      color: COLORS.primary,
                      animation: 'confirmingPulse 1s ease-in-out infinite'
                    }}>
                      ‚è≥ Confirming...
                    </span>
                  )}
                </div>
                <div style={{ color: COLORS.textMuted, fontSize: '14px', marginTop: '5px' }}>Darts: {'üéØ'.repeat(dartsThrown)}{'‚óã'.repeat(3 - dartsThrown)}</div>
              </div>

              <div style={{ marginTop: '20px', display: 'flex', gap: '10px' }}>
                <button onClick={() => setShowStats(true)} style={{ flex: 1, padding: '12px', background: 'rgba(255, 255, 255, 0.05)', color: COLORS.text, border: '1px solid rgba(255, 255, 255, 0.1)', borderRadius: '10px', cursor: 'pointer', fontFamily: "'Inter', sans-serif", fontSize: '13px', fontWeight: '500' }}>STATS</button>
                <button onClick={onlineMode ? handleLeaveClick : resetGame} style={{ flex: 1, padding: '12px', background: `${COLORS.error}30`, color: COLORS.text, border: 'none', borderRadius: '10px', cursor: 'pointer', fontFamily: "'Inter', sans-serif", fontSize: '13px', fontWeight: '500' }}>{onlineMode ? 'LEAVE' : 'MENU'}</button>
              </div>
                </>
              )}
            </div>
            
            {/* Dartboard */}
            <div className="game-dartboard" style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
              <div ref={boardRef} onMouseMove={handleMouseMove} onMouseDown={handleMouseDown} onMouseUp={handleMouseUp} onMouseLeave={handleMouseUp} onTouchMove={handleTouchMove} onTouchStart={handleTouchStart} onTouchEnd={handleTouchEnd} onTouchCancel={handleTouchCancel} style={{ width: `min(${BOARD_SIZE}px, 85vw)`, height: `min(${BOARD_SIZE}px, 85vw)`, borderRadius: '50%', cursor: isPowerCharging ? 'grabbing' : 'crosshair', boxShadow: '0 0 60px rgba(0, 0, 0, 0.8), inset 0 0 30px rgba(0, 0, 0, 0.5)', position: 'relative', userSelect: 'none' }}>
                <svg viewBox={`0 0 ${BOARD_SIZE} ${BOARD_SIZE}`} style={{ width: '100%', height: '100%', filter: 'drop-shadow(0 0 10px rgba(0,0,0,0.5))' }}>
                  <defs><radialGradient id="boardGradient" cx="50%" cy="50%" r="50%"><stop offset="0%" stopColor={COLORS.backgroundCard} /><stop offset="100%" stopColor={COLORS.background} /></radialGradient></defs>
                  <circle cx={CENTER} cy={CENTER} r={CENTER - 5} fill="url(#boardGradient)" stroke="none" strokeWidth="0" />
                  {renderDartboard()}
                  
                  {!isPowerCharging && !animatingDart && (
                    <g>
                      {/* Apply wobble offset for expert mode 180 challenge */}
                      <circle cx={aimPosition.x + aimWobble.x} cy={aimPosition.y + aimWobble.y} r="15" fill="none" stroke={`${COLORS.accent}80`} strokeWidth="2" strokeDasharray="5,5" />
                      <line x1={aimPosition.x + aimWobble.x - 20} y1={aimPosition.y + aimWobble.y} x2={aimPosition.x + aimWobble.x + 20} y2={aimPosition.y + aimWobble.y} stroke={`${COLORS.accent}80`} strokeWidth="1" />
                      <line x1={aimPosition.x + aimWobble.x} y1={aimPosition.y + aimWobble.y - 20} x2={aimPosition.x + aimWobble.x} y2={aimPosition.y + aimWobble.y + 20} stroke={`${COLORS.accent}80`} strokeWidth="1" />
                    </g>
                  )}
                  
                  {dartPositions.map((pos, i) => renderDart(pos, i))}
                  {animatingDart && <g style={{ animation: 'throwDart 0.3s ease-out forwards' }}>{renderDart(animatingDart.end, 'animating')}</g>}
                </svg>
                
                {showScorePopup && (
                  <div style={{
                    position: 'absolute',
                    left: showScorePopup.position.x,
                    top: showScorePopup.position.y - 40,
                    transform: 'translateX(-50%)',
                    background: showScorePopup.label === '180!!!' ? `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentLight})` : showScorePopup.label === 'BUST!' ? COLORS.error : showScorePopup.score === 50 ? COLORS.accent : COLORS.success,
                    color: (showScorePopup.score === 50 || showScorePopup.label === '180!!!') ? COLORS.background : COLORS.text,
                    padding: showScorePopup.label === '180!!!' ? '12px 24px' : '8px 16px',
                    borderRadius: '20px',
                    fontSize: showScorePopup.label === '180!!!' ? '32px' : '20px',
                    fontWeight: '700',
                    animation: 'popUp 0.5s ease-out',
                    pointerEvents: 'none',
                    zIndex: 10,
                    boxShadow: showScorePopup.label === '180!!!' ? `0 0 30px ${COLORS.accent}CC` : 'none'
                  }}>{showScorePopup.label}</div>
                )}
              </div>

              {/* Achievement Unlock Popup - Enhanced */}
              {achievementPopup && (
                <div style={{
                  position: 'fixed',
                  top: '50%',
                  left: '50%',
                  transform: 'translate(-50%, -50%)',
                  background: 'linear-gradient(135deg, rgba(0, 0, 0, 0.98), rgba(20, 20, 40, 0.98))',
                  border: `3px solid ${getRarityColor(achievementPopup.rarity)}`,
                  borderRadius: '20px',
                  padding: '32px',
                  minWidth: '340px',
                  maxWidth: '420px',
                  boxShadow: `0 20px 60px ${getRarityColor(achievementPopup.rarity)}60, 0 0 40px ${getRarityColor(achievementPopup.rarity)}30, inset 0 0 60px ${getRarityColor(achievementPopup.rarity)}10`,
                  animation: 'achievementUnlock 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275)',
                  zIndex: 1000,
                  textAlign: 'center'
                }}>
                  {/* Confetti for legendary/mythic */}
                  {(achievementPopup.rarity === 'legendary' || achievementPopup.rarity === 'mythic') && (
                    <>
                      {[...Array(12)].map((_, i) => (
                        <div key={i} style={{
                          position: 'absolute',
                          width: '8px',
                          height: '8px',
                          background: getRarityColor(achievementPopup.rarity),
                          borderRadius: '50%',
                          top: '50%',
                          left: '50%',
                          animation: `confetti${i % 4} 1s ease-out forwards`,
                          animationDelay: `${i * 0.05}s`
                        }} />
                      ))}
                    </>
                  )}

                  {/* Header */}
                  <div style={{
                    color: getRarityColor(achievementPopup.rarity),
                    fontSize: '0.75rem',
                    fontWeight: '700',
                    letterSpacing: '3px',
                    marginBottom: '16px',
                    textTransform: 'uppercase'
                  }}>
                    üèÜ Achievement Unlocked
                  </div>

                  {/* Icon with glow */}
                  <div style={{
                    fontSize: '64px',
                    marginBottom: '16px',
                    filter: `drop-shadow(0 0 20px ${getRarityColor(achievementPopup.rarity)})`,
                    animation: 'iconBounce 0.5s ease-out 0.3s'
                  }}>
                    {achievementPopup.icon}
                  </div>

                  {/* Name */}
                  <div style={{
                    color: '#fff',
                    fontSize: '1.5rem',
                    fontWeight: '700',
                    marginBottom: '8px',
                    textShadow: `0 0 20px ${getRarityColor(achievementPopup.rarity)}80`
                  }}>
                    {achievementPopup.name}
                  </div>

                  {/* Description */}
                  <div style={{
                    color: COLORS.textMuted,
                    fontSize: '0.9rem',
                    marginBottom: '16px',
                    lineHeight: '1.4'
                  }}>
                    {achievementPopup.description}
                  </div>

                  {/* Rarity Badge */}
                  <div style={{
                    display: 'inline-block',
                    color: getRarityColor(achievementPopup.rarity),
                    fontSize: '0.7rem',
                    fontWeight: '700',
                    letterSpacing: '2px',
                    textTransform: 'uppercase',
                    background: `${getRarityColor(achievementPopup.rarity)}20`,
                    border: `1px solid ${getRarityColor(achievementPopup.rarity)}`,
                    borderRadius: '20px',
                    padding: '6px 16px'
                  }}>
                    {achievementPopup.rarity}
                  </div>

                  {/* Next Achievement Teaser */}
                  {(() => {
                    // Find next achievement in same category
                    const currentIndex = ACHIEVEMENTS_DATA.findIndex(a => a.id === achievementPopup.id);
                    const nextAchievement = ACHIEVEMENTS_DATA[currentIndex + 1];
                    if (nextAchievement && nextAchievement.statKey === achievementPopup.statKey) {
                      return (
                        <div style={{
                          marginTop: '20px',
                          padding: '12px',
                          background: 'rgba(255, 255, 255, 0.05)',
                          borderRadius: '10px',
                          fontSize: '0.8rem'
                        }}>
                          <div style={{ color: COLORS.textMuted, marginBottom: '4px' }}>Next Target:</div>
                          <div style={{ color: COLORS.text, fontWeight: '600' }}>
                            {nextAchievement.icon} {nextAchievement.name}
                          </div>
                        </div>
                      );
                    }
                    return null;
                  })()}
                </div>
              )}

              {/* Backdrop overlay for achievement popup */}
              {achievementPopup && (
                <div style={{
                  position: 'fixed',
                  inset: 0,
                  background: 'rgba(0, 0, 0, 0.7)',
                  zIndex: 999,
                  animation: 'fadeIn 0.3s ease-out'
                }} />
              )}
              
              <div style={{ width: `min(${BOARD_SIZE}px, 85vw)`, marginTop: '20px' }}>
                <div style={{ background: 'rgba(255, 255, 255, 0.05)', borderRadius: '10px', height: '30px', overflow: 'hidden', position: 'relative', border: '1px solid rgba(255, 255, 255, 0.08)' }}>
                  {(() => {
                    // Check if player is aiming at the winning double
                    const currentPlayer = players[currentPlayerIndex];
                    const aimingAt = currentPlayer ? calculateScore(aimPosition.x, aimPosition.y) : { multiplier: 0, score: 0 };
                    const isAimingAtWinningDouble = isCheckoutPosition && aimingAt.multiplier === 2 && aimingAt.score === currentPlayer?.score;

                    // Calculate perfect zone width
                    // Beginner mode (40% or below): constant 10% zone, no shrinking
                    // Intermediate (41-80%): shrinks by 2.5% for each perfect hit
                    // Expert (81%+): shrinks by 3% for each perfect hit
                    // Aiming at winning double: ultra-small 2% zone
                    let perfectZoneWidth;
                    if (skillLevel <= 40) {
                      // Beginner mode - constant 10% zone, no shrinking
                      perfectZoneWidth = 10;
                    } else {
                      // Normal mode - shrinking zones
                      if (isAimingAtWinningDouble) {
                        perfectZoneWidth = 2; // Ultra-small zone for winning double
                      } else {
                        const baseZoneWidth = 10;
                        const shrinkRate = (onlineMode || skillLevel >= 81) ? 3 : 2.5; // 3% for online/expert, 2.5% for intermediate
                        perfectZoneWidth = Math.max(baseZoneWidth - (triplesHit * shrinkRate), 4);
                      }
                    }

                    const perfectZoneLeft = 50 - (perfectZoneWidth / 2);
                    const perfectZoneRight = 50 + (perfectZoneWidth / 2);
                    const isInPerfectZone = power > perfectZoneLeft && power < perfectZoneRight;
                    return (
                      <>
                        <div style={{ height: '100%', width: `${power}%`, background: isInPerfectZone ? 'linear-gradient(90deg, #228b22, #32cd32)' : `linear-gradient(90deg, ${COLORS.error}, #e74c3c)`, transition: isPowerCharging ? 'none' : 'width 0.2s', borderRadius: '10px' }} />
                        <div style={{ position: 'absolute', left: '50%', top: 0, bottom: 0, width: '4px', marginLeft: '-2px', background: COLORS.accent, opacity: 0.5 }} />
                        <div style={{ position: 'absolute', left: `${perfectZoneLeft}%`, top: 0, bottom: 0, width: `${perfectZoneWidth}%`, background: 'rgba(50, 205, 50, 0.25)', borderRadius: '5px' }} />
                      </>
                    );
                  })()}
                </div>
                <div style={{ display: 'flex', justifyContent: 'space-between', color: COLORS.textMuted, fontSize: '11px', marginTop: '5px' }}>
                  <span>WEAK</span>
                  <span style={{ color: isCheckoutPosition ? COLORS.accent : COLORS.success, fontWeight: isCheckoutPosition ? '700' : 'normal' }}>
                    {(() => {
                      if (skillLevel <= 40) {
                        return isCheckoutPosition ? 'CHECKOUT!' : 'PERFECT';
                      }
                      const shrinkRate = (onlineMode || skillLevel >= 81) ? 3 : 2.5;
                      const totalShrink = triplesHit > 0 ? triplesHit * shrinkRate : 0;
                      return isCheckoutPosition
                        ? `CHECKOUT! ${totalShrink > 0 ? `(-${totalShrink}%)` : ''}`
                        : `PERFECT ${totalShrink > 0 ? `(-${totalShrink}%)` : ''}`;
                    })()}
                  </span>
                  <span>STRONG</span>
                </div>
              </div>

              <p style={{ color: COLORS.textMuted, marginTop: '15px', fontSize: '13px', textAlign: 'center' }}>{isPowerCharging ? 'Release to throw!' : 'Click and hold to charge, release to throw'}</p>
            </div>
            
            {/* History */}
            <div className="game-history" style={{ background: COLORS.backgroundCard, borderRadius: '16px', padding: '25px', minWidth: '200px', maxHeight: '500px', overflowY: 'auto', backdropFilter: 'blur(10px)', border: `1px solid ${COLORS.accent}30` }}>
              <h2 style={{ color: COLORS.accent, margin: '0 0 20px 0', letterSpacing: '2px', fontSize: '16px', fontWeight: '700' }}>HISTORY</h2>
              {throwHistory.slice(-15).reverse().map((throw_, index) => (
                <div key={index} style={{ display: 'flex', justifyContent: 'space-between', padding: '10px', background: 'rgba(255, 255, 255, 0.03)', borderRadius: '8px', marginBottom: '8px', fontSize: '13px', border: '1px solid rgba(255, 255, 255, 0.05)' }}>
                  <span style={{ color: COLORS.textMuted }}>{players[throw_.player]?.name}</span>
                  <span style={{ color: throw_.multiplier === 3 ? COLORS.accent : throw_.multiplier === 2 ? COLORS.success : COLORS.text, fontWeight: '600' }}>{throw_.label}</span>
                </div>
              ))}
              {throwHistory.length === 0 && <p style={{ color: COLORS.textMuted, textAlign: 'center', fontSize: '13px' }}>No throws yet</p>}
            </div>
          </div>

          {/* Nine-Darter Star Celebration */}
          {showNineDarter && (
            <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, zIndex: 200, pointerEvents: 'none', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
              {/* Background glow effect */}
              <div style={{
                position: 'absolute',
                top: '50%',
                left: '50%',
                transform: 'translate(-50%, -50%)',
                width: '400px',
                height: '400px',
                background: 'radial-gradient(circle, rgba(255,215,0,0.3) 0%, rgba(255,215,0,0) 70%)',
                animation: 'pulseGlow 2s ease-in-out infinite',
                borderRadius: '50%'
              }} />

              {/* Sparkle particles */}
              {[...Array(20)].map((_, i) => (
                <div key={i} style={{
                  position: 'absolute',
                  top: '50%',
                  left: '50%',
                  width: '6px',
                  height: '6px',
                  background: '#ffd700',
                  borderRadius: '50%',
                  boxShadow: '0 0 10px #ffd700',
                  animation: `sparkle${i % 4} 2s ease-out infinite`,
                  animationDelay: `${i * 0.1}s`,
                  opacity: 0
                }} />
              ))}

              {/* Star container with epic animation */}
              <div style={{
                position: 'relative',
                animation: 'epicStarEntry 6s cubic-bezier(0.34, 1.56, 0.64, 1)',
                transformOrigin: 'center center'
              }}>
                <svg width="250" height="250" viewBox="0 0 200 200" style={{
                  filter: 'drop-shadow(0 0 20px rgba(255,215,0,0.8)) drop-shadow(0 0 40px rgba(255,215,0,0.4))',
                  animation: 'starGlowSequence 6s cubic-bezier(0.34, 1.56, 0.64, 1)'
                }}>
                  <defs>
                    {/* Gold gradient for star */}
                    <radialGradient id="starGradient">
                      <stop offset="0%" stopColor="#ffed4a" />
                      <stop offset="50%" stopColor="#ffd700" />
                      <stop offset="100%" stopColor="#daa520" />
                    </radialGradient>

                    {/* Inner glow gradient */}
                    <radialGradient id="starInnerGlow">
                      <stop offset="0%" stopColor="#fff" stopOpacity="0.8" />
                      <stop offset="50%" stopColor="#ffd700" stopOpacity="0.4" />
                      <stop offset="100%" stopColor="#ffd700" stopOpacity="0" />
                    </radialGradient>
                  </defs>

                  {/* Outer glow circles (pulsing) */}
                  <circle cx="100" cy="100" r="70" fill="url(#starInnerGlow)" opacity="0.6" style={{ animation: 'starPulse 2s ease-in-out infinite' }} />
                  <circle cx="100" cy="100" r="50" fill="url(#starInnerGlow)" opacity="0.4" style={{ animation: 'starPulse 2s ease-in-out infinite 0.3s' }} />

                  {/* Main 5-pointed star */}
                  <path
                    d="M 100 20 L 115 70 L 170 75 L 125 110 L 140 165 L 100 135 L 60 165 L 75 110 L 30 75 L 85 70 Z"
                    fill="url(#starGradient)"
                    stroke="#daa520"
                    strokeWidth="3"
                    style={{ animation: 'starRotate 4s linear infinite 2s' }}
                  />

                  {/* Inner star for depth */}
                  <path
                    d="M 100 40 L 110 80 L 150 85 L 118 108 L 127 148 L 100 125 L 73 148 L 82 108 L 50 85 L 90 80 Z"
                    fill="#ffed4a"
                    opacity="0.7"
                    style={{ animation: 'starRotate 4s linear infinite 2s' }}
                  />

                  {/* Center brilliant point */}
                  <circle cx="100" cy="100" r="15" fill="#fff" opacity="0.9" style={{ animation: 'starTwinkle 1.5s ease-in-out infinite' }} />
                  <circle cx="100" cy="100" r="8" fill="#ffed4a" style={{ animation: 'starTwinkle 1.5s ease-in-out infinite 0.2s' }} />
                </svg>

                {/* Epic text */}
                <div style={{
                  position: 'absolute',
                  top: '-80px',
                  left: '50%',
                  transform: 'translateX(-50%)',
                  fontSize: '64px',
                  fontWeight: '900',
                  color: '#ffd700',
                  textShadow: '0 0 30px rgba(255,215,0,1), 0 0 60px rgba(255,215,0,0.8), 0 4px 10px rgba(0,0,0,0.5)',
                  whiteSpace: 'nowrap',
                  fontFamily: "'Oswald', sans-serif",
                  letterSpacing: '4px',
                  animation: 'textPulse 2s ease-in-out infinite 3s',
                  opacity: 0,
                  animationFillMode: 'forwards'
                }}>
                  NINE DARTER!!!
                </div>

                {/* Subtitle */}
                <div style={{
                  position: 'absolute',
                  bottom: '-60px',
                  left: '50%',
                  transform: 'translateX(-50%)',
                  fontSize: '24px',
                  fontWeight: '600',
                  color: '#ffed4a',
                  textShadow: '0 0 20px rgba(255,215,0,0.8)',
                  whiteSpace: 'nowrap',
                  fontFamily: "'Oswald', sans-serif",
                  letterSpacing: '2px',
                  animation: 'textPulse 2s ease-in-out infinite 3.5s',
                  opacity: 0,
                  animationFillMode: 'forwards'
                }}>
                  LEGENDARY!
                </div>
              </div>
            </div>
          )}

          {/* Stats Modal */}
          {showStats && (
            <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0, 0, 0, 0.8)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 100 }} onClick={() => setShowStats(false)}>
              <div style={{ background: COLORS.backgroundCard, borderRadius: '16px', padding: '30px', maxWidth: '600px', width: '90%', border: `1px solid ${COLORS.accent}30` }} onClick={e => e.stopPropagation()}>
                <h2 style={{ color: COLORS.accent, margin: '0 0 25px 0', letterSpacing: '2px', fontSize: '18px', fontWeight: '700' }}>GAME STATISTICS</h2>
                {players.map((player, index) => (
                  <div key={index} style={{ background: 'rgba(255, 255, 255, 0.03)', borderRadius: '12px', padding: '20px', marginBottom: '15px', border: '1px solid rgba(255, 255, 255, 0.05)' }}>
                    <h3 style={{ color: COLORS.text, margin: '0 0 15px 0', fontSize: '16px', fontWeight: '600' }}>{player.name}</h3>
                    {gameStats[index] ? (
                      <div style={{ display: 'grid', gridTemplateColumns: 'repeat(3, 1fr)', gap: '15px' }}>
                        <div style={{ textAlign: 'center' }}><div style={{ color: COLORS.accent, fontSize: '24px', fontWeight: '700' }}>{gameStats[index].throws}</div><div style={{ color: COLORS.textMuted, fontSize: '12px' }}>Throws</div></div>
                        <div style={{ textAlign: 'center' }}><div style={{ color: COLORS.accent, fontSize: '24px', fontWeight: '700' }}>{gameStats[index].averagePerSet}</div><div style={{ color: COLORS.textMuted, fontSize: '12px' }}>3-Dart Avg</div></div>
                        <div style={{ textAlign: 'center' }}><div style={{ color: COLORS.accent, fontSize: '24px', fontWeight: '700' }}>{gameStats[index].highestThrow}</div><div style={{ color: COLORS.textMuted, fontSize: '12px' }}>Best</div></div>
                        <div style={{ textAlign: 'center' }}><div style={{ color: COLORS.success, fontSize: '24px', fontWeight: '700' }}>{gameStats[index].triples}</div><div style={{ color: COLORS.textMuted, fontSize: '12px' }}>Triples</div></div>
                        <div style={{ textAlign: 'center' }}><div style={{ color: COLORS.primaryLight, fontSize: '24px', fontWeight: '700' }}>{gameStats[index].doubles}</div><div style={{ color: COLORS.textMuted, fontSize: '12px' }}>Doubles</div></div>
                        <div style={{ textAlign: 'center' }}><div style={{ color: COLORS.error, fontSize: '24px', fontWeight: '700' }}>{gameStats[index].bullseyes}</div><div style={{ color: COLORS.textMuted, fontSize: '12px' }}>Bullseyes</div></div>
                      </div>
                    ) : <p style={{ color: COLORS.textMuted, margin: 0 }}>No stats yet</p>}
                  </div>
                ))}
                <button onClick={() => setShowStats(false)} style={{ width: '100%', padding: '15px', background: `linear-gradient(135deg, ${COLORS.accent}, ${COLORS.accentLight})`, color: COLORS.background, border: 'none', borderRadius: '10px', fontSize: '14px', fontWeight: '600', cursor: 'pointer', fontFamily: "'Inter', sans-serif" }}>CLOSE</button>
              </div>
            </div>
          )}

          {/* Winner Modal */}
          {winner && (
            <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0, 0, 0, 0.9)', display: 'flex', alignItems: 'center', justifyContent: 'center', zIndex: 100 }}>
              <div style={{ textAlign: 'center', animation: 'fadeIn 0.5s ease-out' }}>
                <div style={{ fontSize: '100px', marginBottom: '20px' }}>{matchWinner ? 'üèÜ' : '‚úì'}</div>
                <h1 style={{ fontSize: '42px', color: COLORS.accent, margin: '0 0 10px 0', textShadow: `0 0 30px ${COLORS.accent}80`, fontWeight: '700' }}>{winner.name} {matchWinner ? 'WINS THE MATCH!' : 'WINS THE LEG!'}</h1>
                <p style={{ color: COLORS.textMuted, fontSize: '18px', marginBottom: '30px' }}>{matchWinner ? 'Match Complete - Champion Crowned!' : 'Next leg starting soon...'}</p>
                {matchWinner && (
                  <div style={{ display: 'flex', gap: '15px', justifyContent: 'center' }}>
                    <button onClick={startGame} style={{ padding: '15px 40px', background: `linear-gradient(135deg, ${COLORS.primary}, ${COLORS.primaryLight})`, color: COLORS.text, border: 'none', borderRadius: '10px', fontSize: '16px', fontWeight: '600', cursor: 'pointer', fontFamily: "'Inter', sans-serif" }}>PLAY AGAIN</button>
                    <button onClick={resetGame} style={{ padding: '15px 40px', background: 'rgba(255, 255, 255, 0.05)', color: COLORS.text, border: '1px solid rgba(255, 255, 255, 0.1)', borderRadius: '10px', fontSize: '16px', fontWeight: '600', cursor: 'pointer', fontFamily: "'Inter', sans-serif" }}>MAIN MENU</button>
                  </div>
                )}
              </div>
            </div>
          )}
          
          <style>{`
            @keyframes popUp { 0% { transform: translateX(-50%) scale(0.5); opacity: 0; } 50% { transform: translateX(-50%) scale(1.2); } 100% { transform: translateX(-50%) scale(1); opacity: 1; } }
            @keyframes fadeIn { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
            @keyframes throwDart { from { opacity: 0; transform: translateY(50px); } to { opacity: 1; transform: translateY(0); } }
            @keyframes slideInRight { 0% { transform: translateX(400px); opacity: 0; } 100% { transform: translateX(0); opacity: 1; } }

            /* Rhythm Indicator Animations */
            @keyframes rhythmPulse {
              0% { transform: scale(0.8); opacity: 0; }
              50% { transform: scale(1.05); }
              100% { transform: scale(1); opacity: 1; }
            }

            /* Score Confirming Animation */
            @keyframes confirmingPulse {
              0%, 100% { opacity: 0.5; }
              50% { opacity: 1; }
            }

            /* Epic Nine-Darter Star Animations */
            @keyframes epicStarEntry {
              0% { transform: scale(0.3) translateY(100px); opacity: 0; }
              15% { transform: scale(1.3) translateY(-80px) rotate(0deg); opacity: 1; }
              30% { transform: scale(1.2) translateY(-60px) rotate(360deg); }
              45% { transform: scale(1.25) translateY(-40px) rotate(360deg); }
              60% { transform: scale(1.1) translateY(0px) rotate(720deg); }
              75% { transform: scale(1.15) translateY(-10px) rotate(720deg); }
              85% { transform: scale(1.05) translateY(5px) rotate(720deg); }
              100% { transform: scale(1.1) translateY(0px) rotate(720deg); }
            }

            @keyframes starGlowSequence {
              0% { filter: drop-shadow(0 0 10px rgba(255,215,0,0.3)); }
              50% { filter: drop-shadow(0 0 50px rgba(255,215,0,1)) drop-shadow(0 0 100px rgba(255,215,0,0.8)); }
              100% { filter: drop-shadow(0 0 40px rgba(255,215,0,0.9)) drop-shadow(0 0 80px rgba(255,215,0,0.6)); }
            }

            @keyframes starRotate {
              0% { transform: rotate(0deg); }
              100% { transform: rotate(360deg); }
            }

            @keyframes starPulse {
              0%, 100% { transform: scale(1); opacity: 0.6; }
              50% { transform: scale(1.2); opacity: 0.3; }
            }

            @keyframes starTwinkle {
              0%, 100% { opacity: 0.9; transform: scale(1); }
              50% { opacity: 0.4; transform: scale(0.7); }
            }

            @keyframes pulseGlow {
              0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.4; }
              50% { transform: translate(-50%, -50%) scale(1.3); opacity: 0.7; }
            }

            @keyframes textPulse {
              0% { opacity: 0; transform: translateX(-50%) scale(0.5); }
              10% { opacity: 1; transform: translateX(-50%) scale(1.2); }
              20% { opacity: 1; transform: translateX(-50%) scale(1); }
              30%, 100% { opacity: 1; transform: translateX(-50%) scale(1); }
            }

            @keyframes sparkle0 {
              0% { transform: translate(0, 0) scale(0); opacity: 0; }
              10% { opacity: 1; }
              100% { transform: translate(120px, -150px) scale(1); opacity: 0; }
            }

            @keyframes sparkle1 {
              0% { transform: translate(0, 0) scale(0); opacity: 0; }
              10% { opacity: 1; }
              100% { transform: translate(-130px, -140px) scale(1); opacity: 0; }
            }

            @keyframes sparkle2 {
              0% { transform: translate(0, 0) scale(0); opacity: 0; }
              10% { opacity: 1; }
              100% { transform: translate(140px, 120px) scale(1); opacity: 0; }
            }

            @keyframes sparkle3 {
              0% { transform: translate(0, 0) scale(0); opacity: 0; }
              10% { opacity: 1; }
              100% { transform: translate(-110px, 130px) scale(1); opacity: 0; }
            }
          `}</style>
        </div>
      );
    };

    ReactDOM.render(<DartsGame />, document.getElementById('root'));
  </script>
</body>
</html>
